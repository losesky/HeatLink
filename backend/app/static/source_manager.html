<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>HeatLink 新闻源管理器</title>
    <!-- Bootstrap CSS -->
    <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.1.3/dist/css/bootstrap.min.css" rel="stylesheet">
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap-icons@1.8.1/font/bootstrap-icons.css">
    <!-- CodeMirror CSS -->
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/codemirror/5.65.2/codemirror.min.css">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/codemirror/5.65.2/theme/monokai.min.css">
    <style>
        body {
            font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, "Helvetica Neue", Arial, sans-serif;
            background-color: #f8f9fa;
            padding-bottom: 50px;
        }
        .navbar {
            margin-bottom: 20px;
        }
        .card {
            margin-bottom: 20px;
            box-shadow: 0 0.125rem 0.25rem rgba(0, 0, 0, 0.075);
        }
        .loading {
            display: inline-block;
            width: 25px;
            height: 25px;
            border: 3px solid rgba(0, 0, 0, 0.1);
            border-radius: 50%;
            border-top-color: #0d6efd;
            animation: spin 1s ease-in-out infinite;
        }
        @keyframes spin {
            to { transform: rotate(360deg); }
        }
        .CodeMirror {
            height: 350px !important;
            border: 1px solid #ced4da;
            border-radius: 0.25rem;
            font-size: 14px;
            line-height: 1.5;
            min-height: 200px;
            z-index: 0; /* 防止与其他UI元素发生冲突 */
        }
        .cm-s-monokai .CodeMirror-gutters {
            background-color: #272822;
        }
        #htmlEditor {
            margin-bottom: 10px;
        }
        #globalLoader {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(255, 255, 255, 0.8);
            display: none;
            justify-content: center;
            align-items: center;
            flex-direction: column;
            z-index: 1051;
        }
        .source-list-item {
            cursor: pointer;
            transition: background-color 0.2s;
        }
        .source-list-item:hover {
            background-color: #f8f9fa;
        }
        .source-list-item.active {
            background-color: #e9ecef;
        }
        .nav-tabs {
            margin-bottom: 15px;
        }
        .alert {
            margin-bottom: 10px;
        }
        /* HTML Visualization Styles */
        .html-visualization-container {
            font-family: monospace;
            overflow-x: auto;
            background-color: #f8f9fa;
            border-radius: 0;
            padding: 0;
        }
        #htmlVisualization {
            white-space: pre-wrap;
            font-size: 14px;
            line-height: 1.5;
        }
        .tag-name {
            color: #0000ff;
            font-weight: bold;
        }
        .attribute-name {
            color: #008000;
        }
        .attribute-value {
            color: #dd0000;
        }
        .html-comment {
            color: #808080;
            font-style: italic;
        }
        .text-content {
            color: #000000;
        }
        .nested-level {
            border-left: 1px dotted #ccc;
            margin-left: 20px;
            padding-left: 5px;
        }
        .hover-highlight:hover {
            background-color: rgba(0, 123, 255, 0.1);
        }
        /* 调整HTML边距 */
        .CodeMirror-lines {
            padding: 10px 0;
        }
        /* 使HTML编辑器在小屏幕上也能正确显示 */
        @media (max-width: 768px) {
            .CodeMirror {
                height: 250px !important;
            }
        }
    </style>
</head>
<body>
    <!-- Global Loader -->
    <div id="globalLoader">
        <div class="loading"></div>
        <p class="mt-3" id="loaderMessage">加载中...</p>
    </div>

    <!-- Navigation -->
    <nav class="navbar navbar-expand-lg navbar-dark bg-primary">
        <div class="container">
            <a class="navbar-brand" href="#">HeatLink 新闻源管理器</a>
            <button class="navbar-toggler" type="button" data-bs-toggle="collapse" data-bs-target="#navbarNav">
                <span class="navbar-toggler-icon"></span>
            </button>
            <div class="collapse navbar-collapse" id="navbarNav">
                <ul class="navbar-nav ms-auto">
                    <li class="nav-item">
                        <a class="nav-link active" id="navCreate" href="#">创建源</a>
                    </li>
                    <li class="nav-item">
                        <a class="nav-link" id="navManage" href="#">管理源</a>
                    </li>
                </ul>
            </div>
        </div>
    </nav>

    <div class="container mt-4">
        <!-- Main content area -->
        <div id="createSourceSection">
            <h2 class="mb-3">创建新闻源适配器</h2>
            <div class="alert alert-info">
                <p><strong>提示：</strong>这个工具将基于提供的URL和代码样本生成自定义新闻源适配器。</p>
            </div>
            
            <!-- Create Source Form -->
            <div class="card">
                <div class="card-body">
                    <form id="createSourceForm">
                        <div class="row mb-3">
                            <div class="col-md-6">
                                <label for="sourceId" class="form-label">源ID <span class="text-danger">*</span></label>
                                <input type="text" class="form-control" id="sourceId" required 
                                       placeholder="例如：news-website">
                                <div class="form-text">此源的唯一标识符，使用小写字母和连字符。会自动添加"custom-"前缀</div>
                            </div>
                            <div class="col-md-6">
                                <label for="sourceName" class="form-label">源名称 <span class="text-danger">*</span></label>
                                <input type="text" class="form-control" id="sourceName" required 
                                       placeholder="例如：自定义新闻门户">
                                <div class="form-text">此源的显示名称</div>
                            </div>
                        </div>
                        
                        <div class="row mb-3">
                            <div class="col-md-6">
                                <label for="sourceUrl" class="form-label">源URL <span class="text-danger">*</span></label>
                                <input type="url" class="form-control" id="sourceUrl" required 
                                       placeholder="https://example.com/news">
                                <div class="form-text">要抓取的新闻页面URL</div>
                            </div>
                            <div class="col-md-6">
                                <label for="sourceCategory" class="form-label">类别</label>
                                <select class="form-select" id="sourceCategory">
                                    <option value="news">新闻</option>
                                    <option value="technology">科技</option>
                                    <option value="finance">财经</option>
                                    <option value="sports">体育</option>
                                    <option value="entertainment">娱乐</option>
                                    <option value="science">科学</option>
                                    <option value="health">健康</option>
                                    <option value="politics">政治</option>
                                    <option value="business">商业</option>
                                    <option value="other">其他</option>
                                </select>
                                <div class="form-text">新闻源的类别</div>
                            </div>
                        </div>
                        
                        <div class="row mb-3">
                            <div class="col-md-6">
                                <label for="sourceCountry" class="form-label">国家</label>
                                <input type="text" class="form-control" id="sourceCountry" 
                                       placeholder="例如：US, CN, JP" value="CN">
                                <div class="form-text">国家代码 (ISO 3166-1 alpha-2)</div>
                            </div>
                            <div class="col-md-6">
                                <label for="sourceLanguage" class="form-label">语言</label>
                                <input type="text" class="form-control" id="sourceLanguage" 
                                       placeholder="例如：en, zh-CN, ja" value="zh-CN">
                                <div class="form-text">语言代码 (ISO 639-1)</div>
                            </div>
                        </div>
                        
                        <div class="row mb-3">
                            <div class="col-md-6">
                                <label for="updateInterval" class="form-label">更新间隔 (秒)</label>
                                <input type="number" class="form-control" id="updateInterval" 
                                       value="1800" min="300" max="86400">
                                <div class="form-text">多久获取一次新数据 (最小: 5分钟)</div>
                            </div>
                            <div class="col-md-6">
                                <label for="cacheTtl" class="form-label">缓存TTL (秒)</label>
                                <input type="number" class="form-control" id="cacheTtl" 
                                       value="900" min="60" max="43200">
                                <div class="form-text">数据缓存多长时间 (最小: 1分钟)</div>
                            </div>
                        </div>
                        
                        <div class="mb-3">
                            <label for="htmlExample" class="form-label">HTML示例 <span class="text-danger">*</span></label>
                            <div id="htmlEditor" class="html-editor-container"></div>
                            <div class="form-text">粘贴包含新闻条目的新闻页面HTML示例</div>
                            <div class="mt-2">
                                <button type="button" id="analyzeHtmlBtn" class="btn btn-info">
                                    <i class="bi bi-magic"></i> 分析HTML结构并推荐选择器
                                </button>
                            </div>
                        </div>
                        
                        <div class="row mb-3">
                            <div class="col-md-6">
                                <label for="itemSelector" class="form-label">条目选择器 <span class="text-danger">*</span></label>
                                <input type="text" class="form-control" id="itemSelector" required 
                                       placeholder="例如：div.news-item, article.post">
                                <div class="form-text">用于在HTML中找到新闻条目的CSS选择器</div>
                            </div>
                            <div class="col-md-6">
                                <label for="titleSelector" class="form-label">标题选择器 <span class="text-danger">*</span></label>
                                <input type="text" class="form-control" id="titleSelector" required 
                                       placeholder="例如：h3.title, .headline">
                                <div class="form-text">用于在每个条目中找到标题的CSS选择器</div>
                            </div>
                        </div>
                        
                        <div class="row mb-3">
                            <div class="col-md-6">
                                <label for="linkSelector" class="form-label">链接选择器</label>
                                <input type="text" class="form-control" id="linkSelector" 
                                       placeholder="例如：a, .link">
                                <div class="form-text">用于在每个条目中找到链接的CSS选择器</div>
                            </div>
                            <div class="col-md-6">
                                <label for="dateSelector" class="form-label">日期选择器</label>
                                <input type="text" class="form-control" id="dateSelector" 
                                       placeholder="例如：.date, time">
                                <div class="form-text">用于在每个条目中找到日期的CSS选择器</div>
                            </div>
                        </div>
                        
                        <div class="row mb-3">
                            <div class="col-md-6">
                                <label for="summarySelector" class="form-label">摘要选择器</label>
                                <input type="text" class="form-control" id="summarySelector" 
                                       placeholder="例如：.summary, p.excerpt">
                                <div class="form-text">用于在每个条目中找到摘要的CSS选择器</div>
                            </div>
                            <div class="col-md-6">
                                <label for="contentSelector" class="form-label">内容选择器</label>
                                <input type="text" class="form-control" id="contentSelector" 
                                       placeholder="例如：.content, .article-body">
                                <div class="form-text">用于在每个条目中找到完整内容的CSS选择器（如果有）</div>
                            </div>
                        </div>
                        
                        <div class="mb-3 form-check">
                            <input type="checkbox" class="form-check-input" id="useSelenium">
                            <label class="form-check-label" for="useSelenium">使用Selenium处理JavaScript页面</label>
                            <div class="form-text">如果页面需要JavaScript才能加载内容，请启用此选项</div>
                        </div>
                        
                        <!-- 代理设置选项 -->
                        <div class="mb-3 form-check">
                            <input type="checkbox" class="form-check-input" id="needProxy">
                            <label class="form-check-label" for="needProxy">使用代理访问</label>
                            <div class="form-text">如果目标网站需要通过代理访问，请启用此选项</div>
                        </div>
                        
                        <!-- 隐藏字段 - 不显示但会保存默认值 -->
                        <input type="hidden" id="containerSelector">
                        <input type="hidden" id="proxyFallback" value="true">
                        <input type="hidden" id="proxyGroup" value="default">
                        
                        <div class="mb-3 form-check">
                            <input type="checkbox" class="form-check-input" id="autoRegister" checked>
                            <label class="form-check-label" for="autoRegister">自动注册源</label>
                            <div class="form-text">在数据库中注册此源并使其可用</div>
                        </div>
                        
                        <div class="row">
                            <div class="col-md-6">
                                <button type="button" id="previewSourceBtn" class="btn btn-secondary w-100">预览源代码</button>
                            </div>
                            <div class="col-md-6">
                                <button type="submit" id="createSourceBtn" class="btn btn-primary w-100">创建源适配器</button>
                            </div>
                        </div>
                    </form>
                </div>
            </div>
            
            <!-- Preview Modal -->
            <div class="modal fade" id="previewModal" tabindex="-1" aria-hidden="true">
                <div class="modal-dialog modal-xl">
                    <div class="modal-content">
                        <div class="modal-header">
                            <h5 class="modal-title">源适配器预览</h5>
                            <button type="button" class="btn-close" data-bs-dismiss="modal" aria-label="Close" onclick="clearModalBackdrops()"></button>
                        </div>
                        <div class="modal-body">
                            <div id="previewEditor"></div>
                        </div>
                        <div class="modal-footer">
                            <button type="button" class="btn btn-secondary" data-bs-dismiss="modal" onclick="clearModalBackdrops()">关闭</button>
                            <button type="button" class="btn btn-primary" id="copyPreviewBtn">复制代码</button>
                        </div>
                    </div>
                </div>
            </div>
            
            <!-- Result Modal -->
            <div class="modal fade" id="resultModal" tabindex="-1" aria-hidden="true">
                <div class="modal-dialog">
                    <div class="modal-content">
                        <div class="modal-header">
                            <h5 class="modal-title" id="resultModalTitle">源已创建</h5>
                            <button type="button" class="btn-close" data-bs-dismiss="modal" aria-label="Close" onclick="clearModalBackdrops()"></button>
                        </div>
                        <div class="modal-body" id="resultModalBody">
                        </div>
                        <div class="modal-footer">
                            <button type="button" class="btn btn-secondary" data-bs-dismiss="modal" onclick="clearModalBackdrops()">关闭</button>
                            <button type="button" class="btn btn-primary" id="testNewSourceBtn">测试源</button>
                        </div>
                    </div>
                </div>
            </div>
        </div>

        <div id="manageSourcesSection" style="display: none;">
            <h2 class="mb-3">管理新闻源</h2>
            
            <!-- Source Management Content -->
            <div class="row">
                <div class="col-md-4">
                    <div class="card mb-4">
                        <div class="card-header d-flex justify-content-between align-items-center">
                            <h5 class="mb-0">源列表</h5>
                            <button class="btn btn-sm btn-outline-primary" id="refreshSourcesBtn">
                                <i class="bi bi-arrow-clockwise"></i>
                            </button>
                        </div>
                        <div class="card-body">
                            <div class="mb-3">
                                <input type="text" class="form-control" id="sourceSearchInput" placeholder="搜索源...">
                            </div>
                            <div class="list-group" id="sourceListContainer">
                                <div class="text-center py-3">
                                    <div class="loading"></div>
                                    <p class="mt-2">加载源中...</p>
                                </div>
                            </div>
                        </div>
                    </div>
                    
                    <div class="card">
                        <div class="card-header">
                            <h5 class="mb-0">操作</h5>
                        </div>
                        <div class="card-body">
                            <div class="d-grid gap-2">
                                <button class="btn btn-outline-primary" id="testSelectedSourceBtn" disabled>
                                    <i class="bi bi-play-fill"></i> 测试源
                                </button>
                                <button class="btn btn-outline-success" id="activateSourceBtn" disabled>
                                    <i class="bi bi-check-circle"></i> 激活
                                </button>
                                <button class="btn btn-outline-warning" id="deactivateSourceBtn" disabled>
                                    <i class="bi bi-pause-circle"></i> 停用
                                </button>
                                <button class="btn btn-outline-danger" id="deleteSourceBtn" disabled>
                                    <i class="bi bi-trash"></i> 删除
                                </button>
                            </div>
                        </div>
                    </div>
                </div>
                
                <div class="col-md-8">
                    <div class="card">
                        <div class="card-header">
                            <ul class="nav nav-tabs card-header-tabs" id="sourceDetailTabs">
                                <li class="nav-item">
                                    <a class="nav-link active" id="detailsTab" data-bs-toggle="tab" href="#details">详情</a>
                                </li>
                                <li class="nav-item">
                                    <a class="nav-link" id="configTab" data-bs-toggle="tab" href="#config">配置</a>
                                </li>
                                <li class="nav-item">
                                    <a class="nav-link" id="testResultTab" data-bs-toggle="tab" href="#testResult">测试结果</a>
                                </li>
                            </ul>
                        </div>
                        <div class="card-body">
                            <div class="tab-content">
                                <div class="tab-pane fade show active" id="details">
                                    <div id="sourceDetailsContainer">
                                        <div class="alert alert-info">
                                            <p>从列表中选择一个源以查看其详情。</p>
                                        </div>
                                    </div>
                                </div>
                                <div class="tab-pane fade" id="stats">
                                    <div id="sourceStatsContainer">
                                        <div class="alert alert-info">
                                            <p>从列表中选择一个源以查看其统计信息。</p>
                                        </div>
                                    </div>
                                </div>
                                <div class="tab-pane fade" id="config">
                                    <div id="sourceConfigContainer">
                                        <div class="alert alert-info">
                                            <p>从列表中选择一个源以查看和编辑其配置。</p>
                                        </div>
                                    </div>
                                </div>
                                <div class="tab-pane fade" id="testResult">
                                    <div id="sourceTestResultContainer">
                                        <div class="alert alert-info">
                                            <p>点击"测试源"来运行测试并查看结果。</p>
                                        </div>
                                    </div>
                                </div>
                            </div>
                        </div>
                    </div>
                </div>
            </div>
            
            <!-- Edit Source Modal -->
            <div class="modal fade" id="editSourceModal" tabindex="-1" aria-hidden="true">
                <div class="modal-dialog modal-lg">
                    <div class="modal-content">
                        <div class="modal-header">
                            <h5 class="modal-title">编辑源</h5>
                            <button type="button" class="btn-close" data-bs-dismiss="modal" aria-label="Close" onclick="clearModalBackdrops()"></button>
                        </div>
                        <div class="modal-body">
                            <form id="editSourceForm">
                                <input type="hidden" id="editSourceId">
                                
                                <div class="mb-3">
                                    <label for="editSourceName" class="form-label">源名称</label>
                                    <input type="text" class="form-control" id="editSourceName" required>
                                </div>
                                
                                <div class="mb-3">
                                    <label for="editSourceDescription" class="form-label">描述</label>
                                    <textarea class="form-control" id="editSourceDescription" rows="2"></textarea>
                                </div>
                                
                                <div class="mb-3">
                                    <label for="editSourceUrl" class="form-label">源URL</label>
                                    <input type="url" class="form-control" id="editSourceUrl">
                                </div>
                                
                                <div class="row mb-3">
                                    <div class="col-md-6">
                                        <label for="editSourceCategory" class="form-label">类别</label>
                                        <select class="form-select" id="editSourceCategory">
                                            <option value="">-- 加载类别中 --</option>
                                        </select>
                                    </div>
                                    <div class="col-md-6">
                                        <label for="editSourceStatus" class="form-label">状态</label>
                                        <select class="form-select" id="editSourceStatus">
                                            <option value="active">激活</option>
                                            <option value="inactive">未激活</option>
                                            <option value="error">错误</option>
                                            <option value="warning">警告</option>
                                        </select>
                                    </div>
                                </div>
                                
                                <div class="row mb-3">
                                    <div class="col-md-6">
                                        <label for="editUpdateInterval" class="form-label">更新间隔 (秒)</label>
                                        <input type="number" class="form-control" id="editUpdateInterval" min="300" max="86400">
                                    </div>
                                    <div class="col-md-6">
                                        <label for="editCacheTtl" class="form-label">缓存TTL (秒)</label>
                                        <input type="number" class="form-control" id="editCacheTtl" min="60" max="43200">
                                    </div>
                                </div>
                                
                                <div class="mb-3">
                                    <label for="editSourceConfig" class="form-label">源配置 (JSON)</label>
                                    <div id="configEditor"></div>
                                </div>
                            </form>
                        </div>
                        <div class="modal-footer">
                            <button type="button" class="btn btn-secondary" data-bs-dismiss="modal" onclick="clearModalBackdrops()">取消</button>
                            <button type="button" class="btn btn-primary" id="saveSourceBtn">保存更改</button>
                        </div>
                    </div>
                </div>
            </div>
            
            <!-- Delete Confirmation Modal -->
            <div class="modal fade" id="deleteConfirmModal" tabindex="-1" aria-hidden="true">
                <div class="modal-dialog">
                    <div class="modal-content">
                        <div class="modal-header">
                            <h5 class="modal-title">确认删除</h5>
                            <button type="button" class="btn-close" data-bs-dismiss="modal" aria-label="Close" onclick="clearModalBackdrops()"></button>
                        </div>
                        <div class="modal-body">
                            <p>您确定要删除源 <strong id="deleteSourceName"></strong> 吗？</p>
                            <p class="text-danger">此操作无法撤消。</p>
                        </div>
                        <div class="modal-footer">
                            <button type="button" class="btn btn-secondary" data-bs-dismiss="modal" onclick="clearModalBackdrops()">取消</button>
                            <button type="button" class="btn btn-danger" id="confirmDeleteBtn">删除</button>
                        </div>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <!-- HTML Display Modal -->
    <div class="modal fade" id="htmlDisplayModal" tabindex="-1" aria-hidden="true">
        <div class="modal-dialog modal-xl modal-dialog-scrollable">
            <div class="modal-content">
                <div class="modal-header">
                    <h5 class="modal-title">HTML结构可视化</h5>
                    <button type="button" class="btn-close" data-bs-dismiss="modal" aria-label="Close" onclick="clearModalBackdrops()"></button>
                </div>
                <div class="modal-body p-0">
                    <div class="html-visualization-container">
                        <div id="htmlVisualization" class="p-3"></div>
                    </div>
                </div>
                <div class="modal-footer">
                    <button type="button" class="btn btn-secondary" data-bs-dismiss="modal" onclick="clearModalBackdrops()">关闭</button>
                    <button type="button" class="btn btn-primary" id="copyVisualizedHtmlBtn">复制格式化HTML</button>
                </div>
            </div>
        </div>
    </div>

    <!-- Bootstrap JS Bundle with Popper -->
    <script src="https://cdn.jsdelivr.net/npm/bootstrap@5.1.3/dist/js/bootstrap.bundle.min.js"></script>
    
    <!-- 添加clearModalBackdrops函数 -->
    <script>
        /**
         * 清除所有模态框背景并重置body样式
         * 在模态框关闭按钮点击后执行以解决Bootstrap模态框可能遗留的背景层问题
         */
        function clearModalBackdrops() {
            // 使用setTimeout确保在模态框开始关闭后执行清理
            setTimeout(function() {
                // 移除所有模态背景
                document.querySelectorAll('.modal-backdrop').forEach(function(backdrop) {
                    backdrop.remove();
                });
                
                // 重置body样式和类
                document.body.style.overflow = '';
                document.body.style.paddingRight = '';
                document.body.classList.remove('modal-open');
                console.log('已清除模态框背景和重置body样式');
            }, 150); // 延迟150毫秒执行，确保在模态关闭动画开始后
        }
    </script>
    
    <!-- CodeMirror JS -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/codemirror/5.65.2/codemirror.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/codemirror/5.65.2/mode/htmlmixed/htmlmixed.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/codemirror/5.65.2/mode/javascript/javascript.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/codemirror/5.65.2/mode/python/python.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/codemirror/5.65.2/mode/xml/xml.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/codemirror/5.65.2/mode/css/css.min.js"></script>
    <!-- 添加CodeMirror额外插件 -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/codemirror/5.65.2/addon/edit/closetag.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/codemirror/5.65.2/addon/edit/closebrackets.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/codemirror/5.65.2/addon/hint/show-hint.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/codemirror/5.65.2/addon/hint/html-hint.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/codemirror/5.65.2/addon/fold/xml-fold.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/codemirror/5.65.2/addon/selection/active-line.min.js"></script>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/codemirror/5.65.2/addon/hint/show-hint.min.css">

    <!-- Main Script -->
    <script>
        // Global variables
        const API_BASE_URL = '/api';
        let htmlEditor;
        let previewEditor;
        let configEditor;
        let selectedSource = null;
        // 调试模式开关，设置为true时会显示更多的调试信息
        const DEBUG_MODE = true;
        
        // 全局错误处理
        window.onerror = function(message, source, lineno, colno, error) {
            console.error(`JavaScript错误: ${message} (${source}:${lineno}:${colno})`, error);
            if (DEBUG_MODE) {
                showToast('JavaScript错误', `${message} (行${lineno})`, 'danger');
            }
            return false; // 允许默认错误处理继续
        };
        
        // 添加未捕获的Promise拒绝处理
        window.addEventListener('unhandledrejection', function(event) {
            console.error('未处理的Promise拒绝:', event.reason);
            if (DEBUG_MODE) {
                showToast('Promise错误', `${event.reason}`, 'danger');
            }
        });
        
        // 调试日志函数
        function debugLog(...args) {
            if (DEBUG_MODE) {
                console.log('[DEBUG]', ...args);
            }
        }
        
        // Basic navigation functionality
        document.addEventListener('DOMContentLoaded', function() {
            const navCreate = document.getElementById('navCreate');
            const navManage = document.getElementById('navManage');
            const createSection = document.getElementById('createSourceSection');
            const manageSection = document.getElementById('manageSourcesSection');
            
            // Initialize editors
            htmlEditor = CodeMirror(document.getElementById('htmlEditor'), {
                mode: 'htmlmixed',
                theme: 'monokai',
                lineNumbers: true,
                lineWrapping: true,
                autoCloseTags: true,
                autoCloseBrackets: true,
                matchBrackets: true,
                styleActiveLine: true,
                viewportMargin: Infinity,
                tabSize: 2,
                indentWithTabs: false,
                inputStyle: 'contenteditable', // 使用contenteditable模式以提高粘贴性能
                value: ''  // 初始值为空字符串
            });
            
            // 添加HTML编辑器变化监听
            htmlEditor.on('change', function() {
                // 如果HTML内容变化且长度超过一定阈值，启用分析按钮
                const htmlContent = htmlEditor.getValue();
                const contentLength = htmlContent.length;
                document.getElementById('analyzeHtmlBtn').disabled = contentLength < 100;
            });
            
            // 添加一个API健康检查按钮
            const headerNav = document.querySelector('.navbar-nav');
            if (headerNav) {
                const apiCheckLi = document.createElement('li');
                apiCheckLi.className = 'nav-item';
                apiCheckLi.innerHTML = `
                    <a class="nav-link" href="#" id="apiHealthCheck">
                        <i class="bi bi-activity"></i> API检查
                    </a>
                `;
                headerNav.appendChild(apiCheckLi);
                
                document.getElementById('apiHealthCheck').addEventListener('click', function(e) {
                    e.preventDefault();
                    checkApiHealth();
                });
            }
            
            // 添加分析HTML按钮事件
            document.getElementById('analyzeHtmlBtn').addEventListener('click', analyzeHtml);
            
            // 添加复制可视化HTML按钮事件
            document.getElementById('copyVisualizedHtmlBtn').addEventListener('click', function() {
                const htmlContent = htmlEditor.getValue();
                
                // 复制到剪贴板
                navigator.clipboard.writeText(htmlContent).then(function() {
                    showToast('成功', '已复制格式化后的HTML到剪贴板', 'success');
                }).catch(function(err) {
                    console.error('无法复制文本: ', err);
                    showToast('错误', '复制到剪贴板失败，请手动复制', 'danger');
                });
            });
            
            previewEditor = CodeMirror(document.getElementById('previewEditor'), {
                mode: 'python',
                theme: 'monokai',
                lineNumbers: true,
                readOnly: true
            });
            
            configEditor = CodeMirror(document.getElementById('configEditor'), {
                mode: { name: 'javascript', json: true },
                theme: 'monokai',
                lineNumbers: true
            });
            
            // Navigation
            navCreate.addEventListener('click', (e) => {
                e.preventDefault();
                createSection.style.display = 'block';
                manageSection.style.display = 'none';
                navCreate.classList.add('active');
                navManage.classList.remove('active');
            });
            
            navManage.addEventListener('click', (e) => {
                e.preventDefault();
                createSection.style.display = 'none';
                manageSection.style.display = 'block';
                navCreate.classList.remove('active');
                navManage.classList.add('active');
                
                // Load sources
                loadSources();
            });
            
            // Set up form handlers
            document.getElementById('previewSourceBtn').addEventListener('click', function() {
                const sourceCode = generateSourceCode();
                previewEditor.setValue(sourceCode);
                new bootstrap.Modal(document.getElementById('previewModal')).show();
            });
            
            document.getElementById('createSourceForm').addEventListener('submit', function(e) {
                e.preventDefault();
                createSource();
            });
            
            // Set up action buttons in management section
            document.getElementById('refreshSourcesBtn').addEventListener('click', loadSources);
            
            document.getElementById('testSelectedSourceBtn').addEventListener('click', function() {
                if (selectedSource) {
                    testSource(selectedSource);
                    
                    // 切换到测试结果选项卡
                    const testResultTab = document.querySelector('#sourceDetailTabs a[href="#testResult"]');
                    const tabInstance = new bootstrap.Tab(testResultTab);
                    tabInstance.show();
                }
            });
            
            document.getElementById('activateSourceBtn').addEventListener('click', function() {
                if (selectedSource) {
                    showLoader(`激活源中: ${selectedSource}...`);
                    
                    fetch(`/api/sources/${selectedSource}`, {
                        method: 'PUT',
                        headers: {
                            'Content-Type': 'application/json'
                            // Removed auth headers:
                            // 'Authorization': 'Bearer ' + (localStorage.getItem('auth_token') || ''),
                            // 'X-API-Key': localStorage.getItem('api_key') || ''
                        },
                        body: JSON.stringify({
                            status: 'active'
                        }),
                        credentials: 'include' // 包含cookies，这对于会话认证很重要
                    })
                    .then(response => {
                        if (!response.ok) {
                            // 详细记录错误
                            console.error('激活源失败，状态码:', response.status, response.statusText);
                            return response.text().then(text => {
                                let errorDetail = '激活源失败';
                                try {
                                    const errorJson = JSON.parse(text);
                                    errorDetail = errorJson.detail || `API错误: ${response.status} ${response.statusText}`;
                                    console.error('API错误详情:', errorJson);
                                } catch (e) {
                                    // 如果不是JSON，直接使用文本
                                    errorDetail = `API错误: ${response.status} ${response.statusText}. ${text}`;
                                    console.error('API响应内容:', text);
                                }
                                throw new Error(errorDetail);
                            });
                        }
                        return response.json();
                    })
                    .then(result => {
                        hideLoader();
                        
                        // 显示成功提示
                        const toast = new bootstrap.Toast(document.getElementById('notificationToast'));
                        document.getElementById('toastMessage').textContent = `源 "${result.name}" 已成功激活！`;
                        toast.show();
                        
                        // 更新源列表以反映状态变化
                        loadSources();
                        
                        // Show success message
                        document.getElementById('resultModalTitle').textContent = '源已激活';
                        document.getElementById('resultModalBody').innerHTML = `
                            <div class="alert alert-success">
                                <p><strong>源 "${result.name}" 已成功激活！</strong></p>
                                <p>源现在处于活动状态，将用于新闻聚合。</p>
                            </div>
                            <p>您可以在"管理源"部分管理此源。</p>
                        `;
                        
                        // 显示模态框
                        new bootstrap.Modal(document.getElementById('resultModal')).show();
                    })
                    .catch(error => {
                        hideLoader();
                        
                        console.error('激活源时出错:', error);
                        
                        // 检查是否是认证错误
                        if (error.message.includes('Not authenticated') || 
                            error.message.includes('401') || 
                            error.message.includes('auth') || 
                            error.message.includes('认证')) {
                            
                            // 处理认证错误
                            handleAuthError(error, () => {
                                // 认证成功后重新尝试激活
                                activateSource(selectedSource);
                            });
                            return;
                        }
                        
                        // 使用Toast显示错误
                        const toast = new bootstrap.Toast(document.getElementById('notificationToast'));
                        document.getElementById('toastMessage').textContent = `激活源失败: ${error.message}`;
                        document.getElementById('notificationToast').classList.add('bg-danger', 'text-white');
                        toast.show();
                        
                        // 5秒后恢复原来的样式
                        setTimeout(() => {
                            document.getElementById('notificationToast').classList.remove('bg-danger', 'text-white');
                        }, 5000);
                        
                        // Show error message
                        document.getElementById('resultModalTitle').textContent = '错误';
                        document.getElementById('resultModalBody').innerHTML = `
                            <div class="alert alert-danger">
                                <p><strong>激活源失败</strong></p>
                                <p>${error.message}</p>
                            </div>
                        `;
                        
                        // 显示模态框
                        new bootstrap.Modal(document.getElementById('resultModal')).show();
                    });
                }
            });
            
            document.getElementById('deactivateSourceBtn').addEventListener('click', function() {
                if (selectedSource) {
                    showLoader(`停用源中: ${selectedSource}...`);
                    
                    fetch(`/api/sources/${selectedSource}`, {
                        method: 'PUT',
                        headers: {
                            'Content-Type': 'application/json'
                        },
                        body: JSON.stringify({
                            status: 'inactive'
                        })
                    })
                    .then(response => {
                        if (!response.ok) {
                            return response.json().then(err => {
                                throw new Error(err.detail || '停用源失败');
                            });
                        }
                        return response.json();
                    })
                    .then(result => {
                        hideLoader();
                        
                        // Reload sources
                        loadSources();
                        
                        // Reload source details
                        loadSourceDetails(selectedSource);
                        
                        // Show notification
                        alert(`源 "${result.name}" 已成功停用！`);
                    })
                    .catch(error => {
                        hideLoader();
                        
                        alert('停用源失败: ' + error.message);
                    });
                }
            });
            
            document.getElementById('deleteSourceBtn').addEventListener('click', function() {
                if (selectedSource) {
                    // Confirm deletion
                    fetch(`/api/sources/${selectedSource}`)
                    .then(response => response.json())
                    .then(source => {
                        document.getElementById('deleteSourceName').textContent = source.name;
                        new bootstrap.Modal(document.getElementById('deleteConfirmModal')).show();
                        
                        // Set up confirm button
                        document.getElementById('confirmDeleteBtn').onclick = function() {
                            deleteSource(selectedSource);
                            bootstrap.Modal.getInstance(document.getElementById('deleteConfirmModal')).hide();
                        };
                    })
                    .catch(error => {
                        console.error('Error loading source details:', error);
                        alert('Failed to load source details: ' + error.message);
                    });
                }
            });
            
        });
        
        // Helper functions
        function showLoader(message = 'Loading...') {
            document.getElementById('loaderMessage').textContent = message;
            document.getElementById('globalLoader').style.display = 'flex';
        }
        
        function hideLoader() {
            document.getElementById('globalLoader').style.display = 'none';
            
            // 也清除其他可能的遮罩层
            document.querySelectorAll('.loading-overlay, .overlay').forEach(overlay => {
                overlay.style.display = 'none';
            });
            
            // 确保body样式正常
            document.body.style.overflow = '';
            document.body.style.position = '';
        }
        
        function getFormData() {
            return {
                id: document.getElementById('sourceId').value,
                name: document.getElementById('sourceName').value,
                url: document.getElementById('sourceUrl').value,
                category: document.getElementById('sourceCategory').value,
                country: document.getElementById('sourceCountry').value,
                language: document.getElementById('sourceLanguage').value,
                update_interval: parseInt(document.getElementById('updateInterval').value),
                cache_ttl: parseInt(document.getElementById('cacheTtl').value),
                use_selenium: document.getElementById('useSelenium').checked,
                need_proxy: document.getElementById('needProxy').checked,
                proxy_fallback: document.getElementById('proxyFallback').checked,
                proxy_group: document.getElementById('proxyGroup').value,
                selectors: {
                    item: document.getElementById('itemSelector').value,
                    title: document.getElementById('titleSelector').value,
                    link: document.getElementById('linkSelector').value || '',
                    date: document.getElementById('dateSelector').value || '',
                    summary: document.getElementById('summarySelector').value || '',
                    content: document.getElementById('contentSelector').value || ''
                },
                html_example: htmlEditor.getValue()
            };
        }
        
        function generateSourceCode() {
            const data = getFormData();
            
            // Generate simple Python source code preview
            return `# Auto-generated source adapter for ${data.name}
import logging
from bs4 import BeautifulSoup
from worker.sources.web import WebNewsSource
from worker.sources.base import NewsItemModel

logger = logging.getLogger(__name__)

class ${data.id.split('-').map(word => word.charAt(0).toUpperCase() + word.slice(1)).join('')}Source(WebNewsSource):
    """
    ${data.name} adapter
    Fetches news from ${data.url}
    """
    
    def __init__(self, source_id="${data.id}", name="${data.name}", url="${data.url}"):
        super().__init__(
            source_id=source_id,
            name=name,
            url=url,
            update_interval=${data.update_interval},
            cache_ttl=${data.cache_ttl},
            category="${data.category}",
            country="${data.country}",
            language="${data.language}"${data.need_proxy ? `,
            # 代理设置
            config={
                "need_proxy": True,
                "proxy_fallback": ${data.proxy_fallback},
                "proxy_group": "${data.proxy_group}"
            }` : ''}
        )
    
    async def parse_response(self, html):
        # Parse HTML using selectors:
        # Item: ${data.selectors.item}
        # Title: ${data.selectors.title}
        # Link: ${data.selectors.link} 
        # Date: ${data.selectors.date}
        # Summary: ${data.selectors.summary}
        # Content: ${data.selectors.content}${data.need_proxy ? `
        # Using proxy: Yes (Group: ${data.proxy_group}, Fallback: ${data.proxy_fallback})` : ''}${data.use_selenium ? `
        # Using Selenium for JavaScript rendering` : ''}
        pass
`;
        }
        
        function createSource() {
            showLoader('创建源中...');
            
            const data = getFormData();
            
            // 自动为源ID添加custom-前缀，如果尚未添加
            if (!data.id.startsWith('custom-')) {
                data.id = 'custom-' + data.id;
                debugLog('已自动为源ID添加custom-前缀:', data.id);
            }
            
            // Call the API to create the source
            fetch('/api/source-test/create-custom-source', {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json'
                },
                body: JSON.stringify(data)
            })
            .then(response => {
                if (!response.ok) {
                    return response.json().then(err => {
                        throw new Error(err.detail || '创建源失败');
                    });
                }
                return response.json();
            })
            .then(result => {
                hideLoader();
                
                // Show success message
                document.getElementById('resultModalTitle').textContent = '源已创建';
                document.getElementById('resultModalBody').innerHTML = `
                    <div class="alert alert-success">
                        <p><strong>源 "${result.source.name}" 创建成功！</strong></p>
                        <p><strong>ID:</strong> <span class="badge bg-primary">${result.source.id}</span></p>
                        <p><strong>状态:</strong> <span class="badge ${result.source.status === 'active' ? 'bg-success' : 'bg-secondary'}">${result.source.status}</span></p>
                    </div>
                    <div class="alert alert-info">
                        <p><i class="bi bi-info-circle"></i> 点击"测试源"来测试这个新建的源适配器。</p>
                        <p><small>源ID: ${result.source.id} 将被用于测试</small></p>
                    </div>
                `;
                
                new bootstrap.Modal(document.getElementById('resultModal')).show();
            })
            .catch(error => {
                hideLoader();
                
                // Show error message
                document.getElementById('resultModalTitle').textContent = '错误';
                document.getElementById('resultModalBody').innerHTML = `
                    <div class="alert alert-danger">
                        <p><strong>创建源失败</strong></p>
                        <p>${error.message}</p>
                    </div>
                `;
                
                new bootstrap.Modal(document.getElementById('resultModal')).show();
            });
        }
        
        // Add new function to test a source
        document.getElementById('testNewSourceBtn').addEventListener('click', function() {
            const sourceId = document.getElementById('sourceId').value;
            
            if (!sourceId) {
                alert('请先输入有效的源ID');
                return;
            }
            
            // 自动为源ID添加custom-前缀，如果尚未添加
            let testId = sourceId;
            if (!testId.startsWith('custom-')) {
                testId = 'custom-' + testId;
            }
            
            debugLog('testNewSourceBtn click, sourceId:', testId);
            
            // 显示提示信息，告知用户测试结果将会显示在哪里
            const toast = new bootstrap.Toast(document.getElementById('notificationToast'));
            document.getElementById('toastMessage').textContent = `正在测试源 ${testId}，结果将显示在"测试结果"标签页中`;
            toast.show();
            
            // 切换到测试结果标签页
            if (document.getElementById('testResultTab')) {
                const tab = new bootstrap.Tab(document.getElementById('testResultTab'));
                tab.show();
            }
            
            // 开始测试
            testSource(testId);
        });
        
        function testSource(sourceId) {
            // 验证sourceId不为空
            if (!sourceId || sourceId.trim() === '') {
                alert('错误：源ID不能为空');
                console.error('测试源失败: 源ID为空');
                return;
            }
            
            // 自动为源ID添加custom-前缀，如果尚未添加
            if (!sourceId.startsWith('custom-')) {
                sourceId = 'custom-' + sourceId;
                debugLog('已自动为测试的源ID添加custom-前缀:', sourceId);
            }
            
            debugLog('开始测试源, sourceId:', sourceId);
            // 移除全局加载器的使用
            // showLoader(`测试源中: ${sourceId}...`);
            
            // 更新测试结果容器状态
            const testResultContainer = document.getElementById('sourceTestResultContainer');
            testResultContainer.innerHTML = `
                <div class="alert alert-info">
                    <div class="d-flex align-items-center">
                        <div class="loading me-3"></div>
                        <p class="mb-0">正在测试源 ${sourceId}...</p>
                    </div>
                </div>
            `;
            
            // 自动切换到测试结果标签页
            const testResultTab = document.getElementById('testResultTab');
            if (testResultTab) {
                const tab = new bootstrap.Tab(testResultTab);
                tab.show();
            }
            
            // 记录当前时间用于计算请求时长
            const startTime = new Date();
            
            // 生成API URL并记录
            const apiUrl = `/api/source-test/test-source/${sourceId}`;
            debugLog('测试源API URL:', apiUrl);
            
            // 检查API是否可用
            fetch('/api/source-test/source-types')
                .then(response => {
                    if (!response.ok) {
                        throw new Error(`API服务检查失败: ${response.status} ${response.statusText}`);
                    }
                    return response.json();
                })
                .then(sourceTypes => {
                    // API可用，记录所有源类型
                    debugLog('可用源类型:', sourceTypes);
                    
                    // 继续测试特定源
                    testSpecificSource(sourceId, apiUrl, startTime);
                })
                .catch(error => {
                    // API不可用
                    debugLog('API服务检查失败:', error);
                    
                    // 不再调用hideLoader
                    // hideLoader();
                    
                    testResultContainer.innerHTML = `
                        <div class="alert alert-danger">
                            <p><strong>API服务可能不可用</strong></p>
                            <p>${error.message}</p>
                            <button class="btn btn-sm btn-outline-primary mt-2" onclick="checkApiHealth()">检查API状态</button>
                        </div>
                    `;
                    
                    // 显示错误模态框
                    document.getElementById('resultModalTitle').textContent = 'API服务错误';
                    document.getElementById('resultModalBody').innerHTML = `
                        <div class="alert alert-danger">
                            <p><strong>API服务可能不可用</strong></p>
                            <p>${error.message}</p>
                        </div>
                        <div class="alert alert-warning">
                            <p><strong>可能的原因:</strong></p>
                            <ul>
                                <li>后端API服务未启动或无法访问</li>
                                <li>网络连接问题</li>
                                <li>服务器内部错误</li>
                            </ul>
                        </div>
                        <div class="mt-3">
                            <button class="btn btn-primary" onclick="checkApiHealth()">运行API健康检查</button>
                        </div>
                    `;
                    
                    new bootstrap.Modal(document.getElementById('resultModal')).show();
                });
        }
        
        function testSpecificSource(sourceId, apiUrl, startTime) {
            // Call the API to test the source
            fetch(apiUrl, {
                headers: {
                    'Accept': 'application/json'
                }
            })
            .then(response => {
                const endTime = new Date();
                const requestTime = ((endTime - startTime) / 1000).toFixed(2);
                
                debugLog(`API请求完成，响应状态: ${response.status} ${response.statusText}, 耗时: ${requestTime}秒`);
                console.log(`API请求响应状态: ${response.status} ${response.statusText}, 耗时: ${requestTime}秒`);
                
                if (!response.ok) {
                    if (response.status === 404) {
                        throw new Error(`找不到源 "${sourceId}". API响应: ${response.status} ${response.statusText}`);
                    } else {
                        return response.text().then(errorText => {
                            try {
                                // 尝试解析为JSON
                                const errorJson = JSON.parse(errorText);
                                throw new Error(errorJson.detail || `测试源失败. API响应: ${response.status} ${response.statusText}`);
                            } catch (e) {
                                // 如果不是JSON，则直接使用文本
                                throw new Error(`测试源失败. API响应: ${response.status} ${response.statusText}. 内容: ${errorText.substring(0, 100)}...`);
                            }
                        });
                    }
                }
                return response.json();
            })
            .then(result => {
                // 不再调用hideLoader
                // hideLoader();
                debugLog('测试源结果:', result);
                
                // 确保关闭所有可能的模态框，防止遮罩层问题
                document.querySelectorAll('.modal').forEach(modal => {
                    const bsModal = bootstrap.Modal.getInstance(modal);
                    if (bsModal) {
                        bsModal.hide();
                    }
                });
                
                // 强制清除所有可能的遮罩层
                document.querySelectorAll('.modal-backdrop').forEach(backdrop => {
                    backdrop.remove();
                });
                document.body.classList.remove('modal-open');
                document.body.style.overflow = '';
                document.body.style.paddingRight = '';
                
                // 更新测试结果容器
                const testResultContainer = document.getElementById('sourceTestResultContainer');
                if (result.success) {
                    testResultContainer.innerHTML = `
                        <div class="alert alert-success">
                            <p><strong>测试成功！</strong></p>
                            <p>源: ${result.source_name || sourceId}</p>
                            <p>找到条目数: ${result.items_count}</p>
                            <p>耗时: ${result.elapsed_time.toFixed(2)} 秒</p>
                        </div>
                        <div class="mb-3">
                            <button class="btn btn-success" id="activateSourceBtn">激活源</button>
                        </div>
                        ${result.items && result.items.length > 0 ? `
                            <div>
                                <h5>示例条目:</h5>
                                <div class="list-group">
                                    ${result.items.slice(0, 3).map(item => `
                                        <div class="list-group-item">
                                            <h6>${item.title}</h6>
                                            ${item.url ? `<p class="mb-1"><small><a href="${item.url}" target="_blank">${item.url}</a></small></p>` : ''}
                                            <p class="mb-0">${item.summary || ''}</p>
                                        </div>
                                    `).join('')}
                                </div>
                            </div>
                        ` : ''}
                        ${(result.items_count === 0 && result.debug_info) ? `
                            <div class="mt-3">
                                <div class="alert alert-warning">
                                    <p><strong>未找到任何条目</strong> - 以下是一些调试信息，可能帮助您调整选择器:</p>
                                </div>
                                <div class="accordion" id="debugAccordion">
                                    <div class="accordion-item">
                                        <h2 class="accordion-header">
                                            <button class="accordion-button collapsed" type="button" data-bs-toggle="collapse" data-bs-target="#logsCollapse">
                                                调试日志
                                            </button>
                                        </h2>
                                        <div id="logsCollapse" class="accordion-collapse collapse" data-bs-parent="#debugAccordion">
                                            <div class="accordion-body">
                                                <pre class="bg-light p-2" style="max-height: 300px; overflow: auto; font-size: 0.8rem;">${result.debug_info.logs ? result.debug_info.logs.join('\n') : '无调试日志'}</pre>
                                            </div>
                                        </div>
                                    </div>
                                    <div class="accordion-item">
                                        <h2 class="accordion-header">
                                            <button class="accordion-button collapsed" type="button" data-bs-toggle="collapse" data-bs-target="#selectorsCollapse">
                                                当前选择器
                                            </button>
                                        </h2>
                                        <div id="selectorsCollapse" class="accordion-collapse collapse" data-bs-parent="#debugAccordion">
                                            <div class="accordion-body">
                                                <div class="table-responsive">
                                                    <table class="table table-sm">
                                                        <thead>
                                                            <tr>
                                                                <th>选择器类型</th>
                                                                <th>当前值</th>
                                                            </tr>
                                                        </thead>
                                                        <tbody>
                                                            <tr>
                                                                <td>项目选择器</td>
                                                                <td><code>${result.debug_info.selectors.item || '未设置'}</code></td>
                                                            </tr>
                                                            <tr>
                                                                <td>标题选择器</td>
                                                                <td><code>${result.debug_info.selectors.title || '未设置'}</code></td>
                                                            </tr>
                                                            <tr>
                                                                <td>链接选择器</td>
                                                                <td><code>${result.debug_info.selectors.link || '未设置'}</code></td>
                                                            </tr>
                                                            <tr>
                                                                <td>日期选择器</td>
                                                                <td><code>${result.debug_info.selectors.date || '未设置'}</code></td>
                                                            </tr>
                                                            <tr>
                                                                <td>摘要选择器</td>
                                                                <td><code>${result.debug_info.selectors.summary || '未设置'}</code></td>
                                                            </tr>
                                                            <tr>
                                                                <td>内容选择器</td>
                                                                <td><code>${result.debug_info.selectors.content || '未设置'}</code></td>
                                                            </tr>
                                                        </tbody>
                                                    </table>
                                                </div>
                                            </div>
                                        </div>
                                    </div>
                                </div>
                            </div>
                        ` : ''}
                        <div class="mt-3">
                            <p><strong>技术信息:</strong></p>
                            <pre class="bg-light p-2 border" style="max-height: 200px; overflow: auto; font-size: 0.8rem;">${JSON.stringify(result, null, 2)}</pre>
                        </div>
                    `;
                    
                    // 自动切换到测试结果标签页
                    const testResultTab = document.getElementById('testResultTab');
                    if (testResultTab) {
                        // 创建一个bootstrap tab实例并显示
                        const tab = new bootstrap.Tab(testResultTab);
                        tab.show();
                        
                        // 向用户显示成功提示
                        const toast = new bootstrap.Toast(document.getElementById('notificationToast'));
                        document.getElementById('toastMessage').textContent = `源 ${sourceId} 测试成功，找到 ${result.items_count} 条内容！`;
                        toast.show();
                    }
                    
                    // Add event listener for activate button
                    document.getElementById('activateSourceBtn').addEventListener('click', function() {
                        activateSource(sourceId);
                    });
                } else {
                    // Display error in test result container
                    testResultContainer.innerHTML = `
                        <div class="alert alert-danger">
                            <p><strong>源测试失败</strong></p>
                            <p>${result.error || '发生未知错误'}</p>
                        </div>
                        <div class="mt-3">
                            <p><strong>错误详情:</strong></p>
                            <pre class="bg-light p-2 border" style="max-height: 200px; overflow: auto; font-size: 0.8rem;">${JSON.stringify(result, null, 2)}</pre>
                        </div>
                        <div class="mt-3">
                            <button class="btn btn-outline-primary" onclick="testSource('${sourceId}')">重试</button>
                        </div>
                    `;
                    
                    // 显示失败提示
                    const toast = new bootstrap.Toast(document.getElementById('notificationToast'));
                    document.getElementById('toastMessage').textContent = `源 ${sourceId} 测试失败! 请查看错误详情`;
                    toast.show();
                }
                
                // 不再显示模态框，结果直接显示在测试结果标签页中
            })
            .catch(error => {
                // 先隐藏加载器，确保所有遮罩层都被移除
                hideLoader();
                debugLog('测试源错误:', error);
                
                // 确保关闭所有可能的模态框，防止遮罩层问题
                document.querySelectorAll('.modal').forEach(modal => {
                    const bsModal = bootstrap.Modal.getInstance(modal);
                    if (bsModal) {
                        bsModal.hide();
                    }
                });
                
                // 强制清除所有可能的遮罩层
                document.querySelectorAll('.modal-backdrop').forEach(backdrop => {
                    backdrop.remove();
                });
                document.body.classList.remove('modal-open');
                document.body.style.overflow = '';
                document.body.style.paddingRight = '';
                
                // 更新测试结果容器
                const testResultContainer = document.getElementById('sourceTestResultContainer');
                testResultContainer.innerHTML = `
                    <div class="alert alert-danger">
                        <p><strong>测试源失败</strong></p>
                        <p>${error.message}</p>
                        <button class="btn btn-sm btn-outline-primary mt-2" onclick="testSource('${sourceId}')">重试</button>
                    </div>
                    <div class="mt-3">
                        <p><strong>调试信息:</strong></p>
                        <p>请求时间: ${new Date().toLocaleString()}</p>
                        <p>浏览器: ${navigator.userAgent}</p>
                        <p>如果问题持续出现，请尝试以下步骤:</p>
                        <ol>
                            <li>检查浏览器控制台是否有更详细的错误信息</li>
                            <li>确认后端服务运行正常</li>
                            <li>尝试直接在浏览器中访问: <a href="/api/source-test/source-types" target="_blank">/api/source-test/source-types</a> 验证API是否可用</li>
                            <li>检查源ID命名是否符合规范（仅使用小写字母、数字和连字符）</li>
                        </ol>
                    </div>
                `;
                
                // 切换到测试结果标签页并显示失败提示
                const testResultTab = document.getElementById('testResultTab');
                if (testResultTab) {
                    const tab = new bootstrap.Tab(testResultTab);
                    tab.show();
                    
                    const toast = new bootstrap.Toast(document.getElementById('notificationToast'));
                    document.getElementById('toastMessage').textContent = `源 ${sourceId} 测试失败! 请查看错误详情`;
                    toast.show();
                }
            });
        }
        
        // 添加API直接测试工具函数
        function showDirectApiTest(sourceId) {
            // 在结果模态框中添加API测试表单
            const testForm = document.createElement('div');
            testForm.className = 'mt-4 p-3 border rounded bg-light';
            testForm.innerHTML = `
                <h5>API直接测试工具</h5>
                <div class="mb-3">
                    <label class="form-label">API端点:</label>
                    <div class="input-group">
                        <input type="text" class="form-control" id="apiTestUrl" value="/api/source-test/test-source/${sourceId}" />
                        <input type="number" class="form-control" id="apiTimeout" placeholder="超时(秒)" value="60" style="max-width: 100px;" />
                        <button class="btn btn-primary" id="testApiDirectBtn">测试</button>
                    </div>
                    <div class="form-text">可以修改端点路径或参数进行测试</div>
                </div>
                <div class="mb-3" id="apiTestResult">
                    <div class="alert alert-info">点击"测试"按钮开始API测试</div>
                </div>
            `;
            
            document.getElementById('resultModalBody').appendChild(testForm);
            
            // 添加测试按钮事件
            document.getElementById('testApiDirectBtn').addEventListener('click', function() {
                const apiUrl = document.getElementById('apiTestUrl').value;
                const timeout = document.getElementById('apiTimeout').value;
                const resultContainer = document.getElementById('apiTestResult');
                
                resultContainer.innerHTML = `
                    <div class="alert alert-info">
                        <div class="d-flex align-items-center">
                            <div class="loading me-3"></div>
                            <p class="mb-0">正在测试API: ${apiUrl}?timeout=${timeout}...</p>
                        </div>
                    </div>
                `;
                
                // 执行API请求
                const startTime = new Date();
                fetch(`${apiUrl}?timeout=${timeout}`)
                    .then(response => {
                        const endTime = new Date();
                        const requestTime = ((endTime - startTime) / 1000).toFixed(2);
                        
                        // 显示响应头信息
                        const headers = Array.from(response.headers.entries())
                            .map(([key, value]) => `<tr><td>${key}</td><td>${value}</td></tr>`)
                            .join('');
                        
                        if (!response.ok) {
                            return response.text().then(text => {
                                let errorDetail = text;
                                try {
                                    const errorJson = JSON.parse(text);
                                    errorDetail = JSON.stringify(errorJson, null, 2);
                                } catch (e) {
                                    // Keep as text if not JSON
                                }
                                
                                resultContainer.innerHTML = `
                                    <div class="alert alert-danger">
                                        <p><strong>API请求失败</strong> (${response.status} ${response.statusText})</p>
                                        <p>请求时间: ${requestTime}秒</p>
                                        <p>错误详情:</p>
                                        <pre class="bg-dark text-light p-2 mt-2" style="max-height: 200px; overflow: auto;">${errorDetail}</pre>
                                        <p class="mt-2">响应头:</p>
                                        <div style="max-height: 150px; overflow: auto;">
                                            <table class="table table-sm table-bordered">
                                                <thead><tr><th>名称</th><th>值</th></tr></thead>
                                                <tbody>${headers}</tbody>
                                            </table>
                                        </div>
                                    </div>
                                `;
                                throw new Error(`API请求失败: ${response.status} ${response.statusText}`);
                            });
                        }
                        
                        return response.json().then(data => {
                            resultContainer.innerHTML = `
                                <div class="alert alert-success">
                                    <p><strong>API请求成功</strong> (${response.status} ${response.statusText})</p>
                                    <p>请求时间: ${requestTime}秒</p>
                                    <p>响应数据:</p>
                                    <pre class="bg-dark text-light p-2 mt-2" style="max-height: 200px; overflow: auto;">${JSON.stringify(data, null, 2)}</pre>
                                    <p class="mt-2">响应头:</p>
                                    <div style="max-height: 150px; overflow: auto;">
                                        <table class="table table-sm table-bordered">
                                            <thead><tr><th>名称</th><th>值</th></tr></thead>
                                            <tbody>${headers}</tbody>
                                        </table>
                                    </div>
                                </div>
                            `;
                            return data;
                        });
                    })
                    .catch(error => {
                        resultContainer.innerHTML = `
                            <div class="alert alert-danger">
                                <p><strong>请求发生错误</strong></p>
                                <p>${error.message}</p>
                            </div>
                        `;
                    });
            });
        }
        
        function activateSource(sourceId) {
            // 不再使用全局加载层
            // showLoader(`激活源中: ${sourceId}...`);
            
            // 在测试结果区域显示加载状态
            const testResultContainer = document.getElementById('sourceTestResultContainer');
            testResultContainer.innerHTML = `
                <div class="alert alert-info">
                    <div class="d-flex align-items-center">
                        <div class="loading me-3"></div>
                        <p class="mb-0">正在激活源 ${sourceId}...</p>
                    </div>
                </div>
            `;
            
            // Call the API to activate the source
            fetch(`/api/sources/${sourceId}`, {
                method: 'PUT',
                headers: {
                    'Content-Type': 'application/json'
                    // Removed auth headers:
                    // 'Authorization': 'Bearer ' + (localStorage.getItem('auth_token') || ''),
                    // 'X-API-Key': localStorage.getItem('api_key') || ''
                },
                body: JSON.stringify({
                    status: 'active'
                }),
                credentials: 'include' // 包含cookies，这对于会话认证很重要
            })
            .then(response => {
                if (!response.ok) {
                    // 详细记录错误
                    console.error('激活源失败，状态码:', response.status, response.statusText);
                    return response.text().then(text => {
                        let errorDetail = '激活源失败';
                        try {
                            const errorJson = JSON.parse(text);
                            errorDetail = errorJson.detail || `API错误: ${response.status} ${response.statusText}`;
                            console.error('API错误详情:', errorJson);
                        } catch (e) {
                            // 如果不是JSON，直接使用文本
                            errorDetail = `API错误: ${response.status} ${response.statusText}. ${text}`;
                            console.error('API响应内容:', text);
                        }
                        throw new Error(errorDetail);
                    });
                }
                return response.json();
            })
            .then(result => {
                // 不再使用hideLoader
                // hideLoader();
                
                // 更新测试结果区域显示成功状态
                testResultContainer.innerHTML = `
                    <div class="alert alert-success">
                        <p><strong>源 "${result.name}" 已成功激活！</strong></p>
                        <p>源现在处于活动状态，将用于新闻聚合。</p>
                    </div>
                `;
                
                // 显示成功提示
                const toast = new bootstrap.Toast(document.getElementById('notificationToast'));
                document.getElementById('toastMessage').textContent = `源 "${result.name}" 已成功激活！`;
                toast.show();
                
                // 更新源列表以反映状态变化
                loadSources();
                
                // 不再显示模态框，直接在测试结果区域显示结果信息
                /*
                // Show success message
                document.getElementById('resultModalTitle').textContent = '源已激活';
                document.getElementById('resultModalBody').innerHTML = `
                    <div class="alert alert-success">
                        <p><strong>源 "${result.name}" 已成功激活！</strong></p>
                        <p>源现在处于活动状态，将用于新闻聚合。</p>
                    </div>
                    <p>您可以在"管理源"部分管理此源。</p>
                `;
                
                // 显示模态框
                new bootstrap.Modal(document.getElementById('resultModal')).show();
                */
            })
            .catch(error => {
                // 不再使用hideLoader
                // hideLoader();
                
                console.error('激活源时出错:', error);
                
                // 在测试结果区域显示错误状态
                testResultContainer.innerHTML = `
                    <div class="alert alert-danger">
                        <p><strong>激活源失败</strong></p>
                        <p>${error.message}</p>
                        <button class="btn btn-sm btn-outline-primary mt-2" onclick="activateSource('${sourceId}')">重试</button>
                    </div>
                `;
                
                // 检查是否是认证错误
                if (error.message.includes('Not authenticated') || 
                    error.message.includes('401') || 
                    error.message.includes('auth') || 
                    error.message.includes('认证')) {
                    
                    // 处理认证错误
                    handleAuthError(error, () => {
                        // 认证成功后重新尝试激活
                        activateSource(sourceId);
                    });
                    return;
                }
                
                // 使用Toast显示错误
                const toast = new bootstrap.Toast(document.getElementById('notificationToast'));
                document.getElementById('toastMessage').textContent = `激活源失败: ${error.message}`;
                document.getElementById('notificationToast').classList.add('bg-danger', 'text-white');
                toast.show();
                
                // 5秒后恢复原来的样式
                setTimeout(() => {
                    document.getElementById('notificationToast').classList.remove('bg-danger', 'text-white');
                }, 5000);
                
                // 不再显示模态框，直接在测试结果区域显示错误信息
                /*
                // Show error message
                document.getElementById('resultModalTitle').textContent = '错误';
                document.getElementById('resultModalBody').innerHTML = `
                    <div class="alert alert-danger">
                        <p><strong>激活源失败</strong></p>
                        <p>${error.message}</p>
                    </div>
                `;
                
                // 显示模态框
                new bootstrap.Modal(document.getElementById('resultModal')).show();
                */
            });
        }
        
        function loadSources() {
            const sourceListContainer = document.getElementById('sourceListContainer');
            
            // Show loading indicator
            sourceListContainer.innerHTML = `
                <div class="text-center py-3">
                    <div class="loading"></div>
                    <p class="mt-2">加载源中...</p>
                </div>
            `;
            
            // Fetch sources from API
            fetch('/api/sources')
            .then(response => {
                if (!response.ok) {
                    return response.json().then(err => {
                        throw new Error(err.detail || '加载源失败');
                    });
                }
                return response.json();
            })
            .then(sources => {
                // Filter to show only custom sources
                const customSources = sources.filter(source => 
                    source.config && 
                    source.config.auto_generated
                );
                
                if (customSources.length === 0) {
                    sourceListContainer.innerHTML = `
                        <div class="alert alert-info">
                            <p>未找到自定义源。请先创建一个新源。</p>
                        </div>
                    `;
                    return;
                }
                
                // Render sources
                sourceListContainer.innerHTML = '';
                
                customSources.forEach(source => {
                    const sourceItem = document.createElement('a');
                    sourceItem.href = '#';
                    sourceItem.className = 'list-group-item list-group-item-action source-list-item';
                    sourceItem.dataset.sourceId = source.id;
                    
                    // Determine status badge class
                    let statusBadgeClass = 'bg-secondary';
                    if (source.status === 'active') statusBadgeClass = 'bg-success';
                    if (source.status === 'error') statusBadgeClass = 'bg-danger';
                    if (source.status === 'warning') statusBadgeClass = 'bg-warning text-dark';
                    
                    sourceItem.innerHTML = `
                        <div class="d-flex justify-content-between align-items-center">
                            <div>
                                <h6 class="mb-0">${source.name}</h6>
                                <small class="text-muted">${source.id}</small>
                            </div>
                            <span class="badge ${statusBadgeClass}">${source.status}</span>
                        </div>
                    `;
                    
                    // Add click event
                    sourceItem.addEventListener('click', (e) => {
                        e.preventDefault();
                        
                        // Remove active class from all sources
                        document.querySelectorAll('.source-list-item').forEach(item => {
                            item.classList.remove('active');
                        });
                        
                        // Add active class to this source
                        sourceItem.classList.add('active');
                        
                        // Load source details
                        loadSourceDetails(source.id);
                        
                        // Enable action buttons
                        document.getElementById('testSelectedSourceBtn').disabled = false;
                        document.getElementById('activateSourceBtn').disabled = source.status === 'active';
                        document.getElementById('deactivateSourceBtn').disabled = source.status !== 'active';
                        document.getElementById('deleteSourceBtn').disabled = false;
                    });
                    
                    sourceListContainer.appendChild(sourceItem);
                });
            })
            .catch(error => {
                console.error('Error loading sources:', error);
                
                sourceListContainer.innerHTML = `
                    <div class="alert alert-danger">
                        <p><strong>加载源失败</strong></p>
                        <p>${error.message}</p>
                        <button class="btn btn-sm btn-outline-primary mt-2" onclick="loadSources()">重试</button>
                    </div>
                `;
            });
        }
        
        function loadSourceDetails(sourceId) {
            // Show loading indicator in all tabs
            document.getElementById('sourceDetailsContainer').innerHTML = `
                <div class="text-center py-3">
                    <div class="loading"></div>
                    <p class="mt-2">加载详情中...</p>
                </div>
            `;
            
            document.getElementById('sourceStatsContainer').innerHTML = `
                <div class="text-center py-3">
                    <div class="loading"></div>
                    <p class="mt-2">加载统计信息中...</p>
                </div>
            `;
            
            document.getElementById('sourceConfigContainer').innerHTML = `
                <div class="text-center py-3">
                    <div class="loading"></div>
                    <p class="mt-2">加载配置中...</p>
                </div>
            `;
            
            document.getElementById('sourceTestResultContainer').innerHTML = `
                <div class="alert alert-info">
                    <p>点击"测试源"来运行测试并查看结果。</p>
                </div>
            `;
            
            // Set selected source
            selectedSource = sourceId;
            
            // Fetch source details from API
            Promise.all([
                fetch(`/api/sources/${sourceId}`).then(response => response.json()),
                fetch(`/api/sources/${sourceId}/stats`).then(response => response.json()).catch(() => ({}))
            ])
            .then(([sourceDetails, sourceStats]) => {
                // Display source details
                displaySourceDetails(sourceDetails);
                
                // Display source stats
                displaySourceStats(sourceStats);
                
                // Display source config
                displaySourceConfig(sourceDetails);
            })
            .catch(error => {
                console.error('Error loading source details:', error);
                
                document.getElementById('sourceDetailsContainer').innerHTML = `
                    <div class="alert alert-danger">
                        <p><strong>加载源详情失败</strong></p>
                        <p>${error.message}</p>
                    </div>
                `;
            });
        }
        
        // 加载所有类别
        let allCategories = [];
        
        function loadCategories() {
            fetch('/api/categories/')
                .then(response => response.json())
                .then(categories => {
                    allCategories = categories;
                    console.log('加载了类别:', categories);
                    
                    // 初始化类别选择器
                    const categorySelect = document.getElementById('editSourceCategory');
                    categorySelect.innerHTML = '';
                    
                    categories.forEach(category => {
                        const option = document.createElement('option');
                        option.value = category.id;
                        option.textContent = category.name;
                        categorySelect.appendChild(option);
                    });
                })
                .catch(error => console.error('加载类别失败:', error));
        }
        
        // 在页面加载时获取类别列表
        loadCategories();

        // 根据category_id获取类别名称
        function getCategoryNameById(categoryId) {
            const category = allCategories.find(c => c.id === categoryId);
            return category ? category.name : '未知';
        }
        
        // 在源详情中显示类别名称
        function displaySourceDetails(source) {
            const container = document.getElementById('sourceDetailsContainer');
            
            if (!source) {
                container.innerHTML = `
                    <div class="alert alert-info">
                        <p>请从列表中选择一个源以查看其详情。</p>
                    </div>
                `;
                return;
            }
            
            // 获取类别名称
            const categoryName = getCategoryNameById(source.category_id);
            
            container.innerHTML = `
                <div class="d-flex justify-content-between align-items-start mb-3">
                    <h5>${source.name}</h5>
                    <span class="badge ${getStatusBadgeClass(source.status)}">${source.status}</span>
                </div>
                
                <p class="text-muted">${source.description || '无描述'}</p>
                
                <div class="row">
                    <div class="col-md-6">
                        <dl>
                            <dt>源ID</dt>
                            <dd>${source.id}</dd>
                            
                            <dt>URL</dt>
                            <dd>
                                <a href="${source.url}" target="_blank" rel="noopener noreferrer">
                                    ${source.url || '无URL'}
                                    <i class="bi bi-box-arrow-up-right"></i>
                                </a>
                            </dd>
                            
                            <dt>类型</dt>
                            <dd>${source.type || '未知'}</dd>
                            
                            <dt>类别</dt>
                            <dd>${categoryName}</dd>
                        </dl>
                    </div>
                    
                    <div class="col-md-6">
                        <dl>
                            <dt>更新间隔</dt>
                            <dd>${formatSeconds(source.update_interval)}</dd>
                            
                            <dt>缓存TTL</dt>
                            <dd>${formatSeconds(source.cache_ttl)}</dd>
                            
                            <dt>国家/地区</dt>
                            <dd>${source.country || '全球'}</dd>
                            
                            <dt>语言</dt>
                            <dd>${source.language || '未知'}</dd>
                        </dl>
                    </div>
                </div>
                
                <div class="d-flex justify-content-end mt-3">
                    <button class="btn btn-outline-primary" id="editDetailsBtn">
                        <i class="bi bi-pencil"></i> 编辑详情
                    </button>
                </div>
            `;
            
            // Add event listener for edit button
            document.getElementById('editDetailsBtn').addEventListener('click', () => {
                openEditModal(source, 'details');
            });
        }

        function displaySourceStats(stats) {
            const container = document.getElementById('sourceStatsContainer');
            
            if (!stats || Object.keys(stats).length === 0) {
                container.innerHTML = `
                    <div class="alert alert-info">
                        <p>暂无可用的统计信息。</p>
                    </div>
                `;
                return;
            }
            
            container.innerHTML = `
                <div class="row">
                    <div class="col-md-6">
                        <div class="card">
                            <div class="card-body">
                                <h6 class="card-title">新闻数量</h6>
                                <p class="card-text display-6">${stats.news_count || 0}</p>
                            </div>
                        </div>
                    </div>
                    
                    <div class="col-md-6">
                        <div class="card">
                            <div class="card-body">
                                <h6 class="card-title">最后更新</h6>
                                <p class="card-text">${formatDate(stats.last_updated) || '从未'}</p>
                            </div>
                        </div>
                    </div>
                </div>
                
                <div class="row mt-3">
                    <div class="col-md-6">
                        <div class="card">
                            <div class="card-body">
                                <h6 class="card-title">错误数量</h6>
                                <p class="card-text display-6">${stats.error_count || 0}</p>
                            </div>
                        </div>
                    </div>
                    
                    <div class="col-md-6">
                        <div class="card">
                            <div class="card-body">
                                <h6 class="card-title">最后错误</h6>
                                <p class="card-text text-danger">${stats.last_error || '无'}</p>
                            </div>
                        </div>
                    </div>
                </div>
            `;
        }
        
        function displaySourceConfig(source) {
            const container = document.getElementById('sourceConfigContainer');
            
            if (!source.config) {
                container.innerHTML = `
                    <div class="alert alert-info">
                        <p>无可用的配置信息。</p>
                    </div>
                `;
                return;
            }
            
            container.innerHTML = `
                <div class="mb-3">
                    <h6>源配置</h6>
                    <div id="configViewEditor"></div>
                </div>
                
                <div class="d-flex justify-content-end mt-3">
                    <button class="btn btn-outline-primary" id="editConfigBtn">
                        <i class="bi bi-pencil"></i> 编辑配置
                    </button>
                </div>
            `;
            
            // Initialize CodeMirror
            const configViewEditor = CodeMirror(document.getElementById('configViewEditor'), {
                value: JSON.stringify(source.config, null, 2),
                mode: { name: 'javascript', json: true },
                theme: 'monokai',
                lineNumbers: true,
                readOnly: true
            });
            
            // Add event listener for edit button
            document.getElementById('editConfigBtn').addEventListener('click', () => {
                openEditModal(source, 'config');
            });
        }
        
        function openEditModal(source, tab = 'details') {
            // Set up modal form
            document.getElementById('editSourceId').value = source.id;
            document.getElementById('editSourceName').value = source.name;
            document.getElementById('editSourceUrl').value = source.url;
            document.getElementById('editSourceDescription').value = source.description || `自动生成的源：${source.url}`;
            
            // 设置正确的类别
            const categorySelect = document.getElementById('editSourceCategory');
            if (source.category_id) {
                categorySelect.value = source.category_id;
            }
            
            document.getElementById('editSourceStatus').value = source.status;
            document.getElementById('editUpdateInterval').value = source.update_interval;
            document.getElementById('editCacheTtl').value = source.cache_ttl;
            
            // Set up config editor
            configEditor.setValue(JSON.stringify(source.config || {}, null, 2));
            
            // Show modal
            new bootstrap.Modal(document.getElementById('editSourceModal')).show();
            
            // Set up save button
            document.getElementById('saveSourceBtn').onclick = () => saveSource(source.id);
        }
        
        function saveSource(sourceId) {
            showLoader('保存更改中...');
            
            // Get form data
            const data = {
                name: document.getElementById('editSourceName').value,
                url: document.getElementById('editSourceUrl').value,
                description: document.getElementById('editSourceDescription').value || `Custom source for ${document.getElementById('editSourceUrl').value}`,
                category_id: parseInt(document.getElementById('editSourceCategory').value),
                status: document.getElementById('editSourceStatus').value,
                update_interval: parseInt(document.getElementById('editUpdateInterval').value),
                cache_ttl: parseInt(document.getElementById('editCacheTtl').value)
            };
            
            // Try to parse JSON config
            try {
                data.config = JSON.parse(configEditor.getValue());
            } catch (error) {
                hideLoader();
                alert('JSON配置无效: ' + error.message);
                return;
            }
            
            // Update source
            fetch(`/api/sources/${sourceId}`, {
                method: 'PUT',
                headers: {
                    'Content-Type': 'application/json'
                    // Removed auth headers:
                    // 'Authorization': 'Bearer ' + (localStorage.getItem('auth_token') || ''),
                    // 'X-API-Key': localStorage.getItem('api_key') || ''
                },
                body: JSON.stringify(data),
                credentials: 'include' // 包含cookies，这对于会话认证很重要
            })
            .then(response => {
                if (!response.ok) {
                    // 详细记录错误
                    console.error('更新源失败，状态码:', response.status, response.statusText);
                    return response.text().then(text => {
                        let errorDetail = '更新源失败';
                        try {
                            const errorJson = JSON.parse(text);
                            errorDetail = errorJson.detail || `API错误: ${response.status} ${response.statusText}`;
                            console.error('API错误详情:', errorJson);
                        } catch (e) {
                            // 如果不是JSON，直接使用文本
                            errorDetail = `API错误: ${response.status} ${response.statusText}. ${text}`;
                            console.error('API响应内容:', text);
                        }
                        throw new Error(errorDetail);
                    });
                }
                return response.json();
            })
            .then(result => {
                hideLoader();
                
                // 显示成功提示
                const toast = new bootstrap.Toast(document.getElementById('notificationToast'));
                document.getElementById('toastMessage').textContent = `源 ${data.name} 更新成功！`;
                toast.show();
                
                // Hide modal
                bootstrap.Modal.getInstance(document.getElementById('editSourceModal')).hide();
                
                // Reload source details
                loadSourceDetails(sourceId);
                
                // Reload source list to update status
                loadSources();
            })
            .catch(error => {
                hideLoader();
                
                console.error('保存源时出错:', error);
                
                // 检查是否是认证错误
                if (error.message.includes('Not authenticated') || 
                    error.message.includes('401') || 
                    error.message.includes('auth') || 
                    error.message.includes('认证')) {
                    
                    // 处理认证错误
                    handleAuthError(error, () => {
                        // 认证成功后重新尝试保存
                        saveSource(sourceId);
                    });
                    return;
                }
                
                // 使用Toast显示错误，而不是alert
                const toast = new bootstrap.Toast(document.getElementById('notificationToast'));
                document.getElementById('toastMessage').textContent = `更新源失败: ${error.message}`;
                document.getElementById('notificationToast').classList.add('bg-danger', 'text-white');
                toast.show();
                
                // 5秒后恢复原来的样式
                setTimeout(() => {
                    document.getElementById('notificationToast').classList.remove('bg-danger', 'text-white');
                }, 5000);
            });
        }
        
        // Helper functions for formatting
        function formatSeconds(seconds) {
            if (!seconds) return '未指定';
            
            const hours = Math.floor(seconds / 3600);
            const minutes = Math.floor((seconds % 3600) / 60);
            const secs = seconds % 60;
            
            let result = '';
            if (hours > 0) result += `${hours}小时 `;
            if (minutes > 0) result += `${minutes}分钟 `;
            if (secs > 0 || result === '') result += `${secs}秒`;
            
            return result;
        }
        
        function formatDate(dateStr) {
            if (!dateStr) return '不可用';
            
            const date = new Date(dateStr);
            return date.toLocaleString();
        }
        
        function getStatusBadgeClass(status) {
            switch (status) {
                case 'active': return 'bg-success';
                case 'error': return 'bg-danger';
                case 'warning': return 'bg-warning text-dark';
                case 'inactive': return 'bg-secondary';
                default: return 'bg-secondary';
            }
        }
        
        function deleteSource(sourceId) {
            showLoader(`删除源中: ${sourceId}...`);
            
            fetch(`/api/sources/${sourceId}`, {
                method: 'DELETE'
            })
            .then(response => {
                if (!response.ok) {
                    return response.json().then(err => {
                        throw new Error(err.detail || '删除源失败');
                    });
                }
                return response.json();
            })
            .then(result => {
                hideLoader();
                
                // Reload sources
                loadSources();
                
                // Clear selected source
                selectedSource = null;
                
                // Clear source details
                document.getElementById('sourceDetailsContainer').innerHTML = `
                    <div class="alert alert-info">
                        <p>从列表中选择一个源以查看其详情。</p>
                    </div>
                `;
                
                document.getElementById('sourceStatsContainer').innerHTML = `
                    <div class="alert alert-info">
                        <p>从列表中选择一个源以查看其统计信息。</p>
                    </div>
                `;
                
                document.getElementById('sourceConfigContainer').innerHTML = `
                    <div class="alert alert-info">
                        <p>从列表中选择一个源以查看和编辑其配置。</p>
                    </div>
                `;
                
                document.getElementById('sourceTestResultContainer').innerHTML = `
                    <div class="alert alert-info">
                        <p>点击"测试源"来运行测试并查看结果。</p>
                    </div>
                `;
                
                // Disable action buttons
                document.getElementById('testSelectedSourceBtn').disabled = true;
                document.getElementById('activateSourceBtn').disabled = true;
                document.getElementById('deactivateSourceBtn').disabled = true;
                document.getElementById('deleteSourceBtn').disabled = true;
                
                // Show notification
                alert(`源 "${sourceId}" 已成功删除`);
            })
            .catch(error => {
                hideLoader();
                
                alert('删除源失败: ' + error.message);
            });
        }
        
        // 添加HTML分析函数
        function analyzeHtml() {
            try {
                // 获取HTML内容
                const htmlContent = htmlEditor.getValue().trim();
                if (!htmlContent) {
                    showToast('提示', '请先输入或粘贴HTML内容', 'warning');
                    return;
                }
                
                console.log('开始分析HTML内容...');
                
                // 在DOM中解析HTML
                const parser = new DOMParser();
                const htmlDoc = parser.parseFromString(htmlContent, 'text/html');
                
                // 初始化一个对象存储找到的选择器
                const foundSelectors = {
                    container: [],
                    item: [],
                    title: [],
                    link: [],
                    date: [],
                    summary: [],
                    content: []
                };
                
                // 分析潜在的新闻容器
                console.log('分析潜在的新闻容器...');
                foundSelectors.container = analyzeContainers(htmlDoc);
                
                // 检测特定网站结构 - 首先检测所有特殊结构
                const specialStructure = detectSpecialStructures(htmlDoc);
                if (specialStructure) {
                    console.log('检测到特殊网站结构，使用特定分析方法');
                    
                    // 已经找到特殊结构，直接设置选择器
                    foundSelectors.item = [{ 
                        selector: specialStructure.itemSelector,
                        count: specialStructure.itemCount,
                        score: 100
                    }];
                    
                    foundSelectors.title = [{ 
                        selector: specialStructure.titleSelector,
                        score: 100,
                        text: specialStructure.titleExample || '',
                        isLink: false
                    }];
                    
                    foundSelectors.link = [{ 
                        selector: specialStructure.linkSelector,
                        score: 100,
                        isTitleLink: false,
                        href: specialStructure.linkExample || ''
                    }];
                    
                    if (specialStructure.dateSelector) {
                        foundSelectors.date = [{ 
                            selector: specialStructure.dateSelector,
                            score: 100,
                            text: specialStructure.dateExample || ''
                        }];
                    }
                } else {
                // 如果找到了容器，分析容器中的列表项
                if (foundSelectors.container.length > 0) {
                    const containerSelector = validateAndFixSelector(foundSelectors.container[0].selector, 'container');
                    try {
                        const container = htmlDoc.querySelector(containerSelector);
                        if (container) {
                            console.log('分析条目...');
                            foundSelectors.item = analyzeListItems(container, containerSelector);
                        }
                    } catch (e) {
                        console.error(`使用容器选择器分析时出错: ${e.message}`);
                    }
                }
                
                // 如果找到了列表项，分析其中的标题、链接等
                if (foundSelectors.item.length > 0) {
                    const itemSelector = validateAndFixSelector(foundSelectors.item[0].selector, 'item');
                    try {
                        const itemElement = htmlDoc.querySelector(itemSelector);
                        if (itemElement) {
                            console.log('分析标题元素...');
                            foundSelectors.title = analyzeTitleElement(itemElement, itemSelector);
                            
                            console.log('分析链接元素...');
                            foundSelectors.link = analyzeLinkElement(itemElement, itemSelector);
                            
                            console.log('分析日期元素...');
                            foundSelectors.date = analyzeDateElement(itemElement, itemSelector);
                            
                            console.log('分析摘要元素...');
                            foundSelectors.summary = analyzeSummaryElement(itemElement, itemSelector);
                            
                            console.log('分析内容元素...');
                            foundSelectors.content = analyzeContentElement(itemElement, itemSelector);
                        }
                    } catch (e) {
                        console.error(`使用条目选择器分析时出错: ${e.message}`);
                        }
                    }
                }
                
                // 创建结果消息
                let resultMessage = createResultMessage(foundSelectors, htmlDoc);
                
                // 添加一个突出的通知，让用户知道选择器已经应用到表单
                if (foundSelectors.item && foundSelectors.item.length > 0) {
                    resultMessage = `
                    <div class="alert alert-success mb-4">
                        <h5><i class="bi bi-check-circle-fill"></i> 选择器已自动应用</h5>
                        <p>已将以下选择器应用到表单字段:</p>
                        <ul>
                            <li><strong>条目选择器:</strong> <code>${foundSelectors.item[0].selector}</code></li>
                            ${foundSelectors.title.length > 0 ? `<li><strong>标题选择器:</strong> <code>${foundSelectors.title[0].selector}</code></li>` : ''}
                            ${foundSelectors.link.length > 0 ? `<li><strong>链接选择器:</strong> <code>${foundSelectors.link[0].selector}</code></li>` : ''}
                            ${foundSelectors.date.length > 0 ? `<li><strong>日期选择器:</strong> <code>${foundSelectors.date[0].selector}</code></li>` : ''}
                        </ul>
                        <p class="mb-0">您可以在下方查看更多分析结果。</p>
                    </div>
                    ` + resultMessage;
                }
                
                // 显示结果
                const resultModalBody = document.getElementById('resultModalBody');
                resultModalBody.innerHTML = resultMessage;
                
                // 显示一个通知，让用户知道选择器已经应用
                if (foundSelectors.item && foundSelectors.item.length > 0) {
                    showToast('已填充选择器', `已将检测到的选择器填充到表单字段中：${foundSelectors.item[0].selector}`, 'success');
                }
                
                // 第五步：尝试填充表单字段
                try {
                    // 根据分析结果填充表单字段
                    if (foundSelectors.container && foundSelectors.container.length > 0) {
                        setSelector('container', foundSelectors.container[0].selector);
                    }
                    
                    if (foundSelectors.item && foundSelectors.item.length > 0) {
                        setSelector('item', foundSelectors.item[0].selector);
                        // 额外确保条目选择器已设置 (NBD专用)
                        document.getElementById('itemSelector').value = foundSelectors.item[0].selector;
                        document.getElementById('itemSelector').classList.add('is-valid');
                        document.getElementById('itemSelector').style.borderColor = '#28a745';
                        document.getElementById('itemSelector').style.boxShadow = '0 0 0 0.2rem rgba(40, 167, 69, 0.25)';
                        console.log(`直接设置条目选择器为: ${foundSelectors.item[0].selector}`);
                        
                        // 添加一个提示标签
                        const feedbackDiv = document.createElement('div');
                        feedbackDiv.className = 'valid-feedback';
                        feedbackDiv.style.display = 'block';
                        feedbackDiv.textContent = `已自动设置为: ${foundSelectors.item[0].selector}`;
                        
                        const parentElement = document.getElementById('itemSelector').parentElement;
                        
                        // 移除任何已存在的反馈元素
                        const existingFeedback = parentElement.querySelector('.valid-feedback');
                        if (existingFeedback) {
                            parentElement.removeChild(existingFeedback);
                        }
                        
                        parentElement.appendChild(feedbackDiv);
                    }
                    
                    if (foundSelectors.title && foundSelectors.title.length > 0) {
                        const titleSelector = foundSelectors.title[0].selector;
                        setSelector('title', titleSelector);
                    }
                    
                    if (foundSelectors.link && foundSelectors.link.length > 0) {
                        const linkSelector = foundSelectors.link[0].selector;
                        setSelector('link', linkSelector);
                    }
                    
                    if (foundSelectors.date && foundSelectors.date.length > 0) {
                        setSelector('date', foundSelectors.date[0].selector);
                    }
                    
                    if (foundSelectors.summary && foundSelectors.summary.length > 0) {
                        setSelector('summary', foundSelectors.summary[0].selector);
                    }
                    
                    if (foundSelectors.content && foundSelectors.content.length > 0) {
                        setSelector('content', foundSelectors.content[0].selector);
                    }
                    
                    console.log('自动填充表单字段完成');
                } catch (e) {
                    console.error('填充表单字段时出错:', e);
                }
                
                // 存储解析后的HTML文档用于后续测试
                window.parsedHtmlDoc = htmlDoc;
                
                // 设置测试按钮事件处理
                setupTestButtons();
                
                // 显示模态框
                const resultModal = new bootstrap.Modal(document.getElementById('resultModal'));
                resultModal.show();
                
                console.log('HTML分析完成');
                
            } catch (error) {
                console.error('分析HTML时出错:', error);
                showToast('错误', `分析HTML时出错: ${error.message}`, 'danger');
            }
        }
        
        // 辅助函数：检测NBD网站结构
        function detectNBDStructure(htmlDoc) {
            try {
                // 检查是否存在特定的结构元素
                const hasKuaiXunBox = !!htmlDoc.querySelector('.kuaiXunBox');
                const hasNormalReal = !!htmlDoc.querySelector('.content.normal-real');
                const hasUContent = !!htmlDoc.querySelector('.u-content');
                const hasUTime = !!htmlDoc.querySelector('.u-time');
                
                // 判断是否为NBD网站结构
                const isNBD = hasKuaiXunBox && hasUContent && hasUTime;
                
                if (!isNBD) {
                    return null;
                }
                
                console.log('检测到NBD网站结构');
                
                // 寻找第一个itemBox元素
                const firstItemBox = htmlDoc.querySelector('.itemBox');
                if (!firstItemBox) {
                    console.warn('找不到.itemBox元素');
                    return null;
                }
                
                // 寻找itemBox的直接父元素 - 通常是.kuaiXunBox或类似元素
                let containerElement = firstItemBox.parentElement;
                let containerClass = '';
                
                if (containerElement) {
                    containerClass = containerElement.className || '';
                    console.log(`找到容器元素: ${containerClass}`);
                } else {
                    console.warn('无法找到.itemBox的父元素');
                    return null;
                }
                
                // 通过追溯父元素结构找到最合适的容器选择器
                let containerSelector = '';
                let itemSelector = '';
                
                // 检查是否有.normal-real的父级元素
                let normalRealParent = null;
                let currentElem = containerElement;
                
                // 向上追溯查找.normal-real类
                while (currentElem && !normalRealParent) {
                    if (currentElem.classList && 
                        currentElem.classList.contains('normal-real') || 
                        (currentElem.classList && 
                         currentElem.classList.contains('content') && 
                         currentElem.classList.contains('normal-real'))) {
                        normalRealParent = currentElem;
                        break;
                    }
                    currentElem = currentElem.parentElement;
                }
                
                // 根据找到的结构设置选择器
                if (normalRealParent) {
                    console.log('找到.normal-real父元素');
                    containerSelector = '.content.normal-real';
                    
                    if (containerElement.classList.contains('kuaiXunBox')) {
                        itemSelector = '.content.normal-real .kuaiXunBox > .itemBox';
                    } else {
                        itemSelector = '.content.normal-real .itemBox';
                    }
                } else if (containerClass.includes('kuaiXunBox')) {
                    console.log('找到.kuaiXunBox容器');
                    containerSelector = '.kuaiXunBox';
                    itemSelector = '.kuaiXunBox > .itemBox';
                } else {
                    // 默认选择器
                    containerSelector = containerElement.tagName.toLowerCase() + 
                        (containerClass ? '.' + containerClass.replace(/\s+/g, '.') : '');
                    itemSelector = containerSelector + ' > .itemBox';
                }
                
                // 计算有多少个匹配的项目
                const items = htmlDoc.querySelectorAll(itemSelector);
                
                // 分析第一个项目，获取标题、链接和日期选择器示例
                let titleExample = '';
                let linkExample = '';
                let dateExample = '';
                
                // 找到第一个项目的标题
                const titleElement = firstItemBox.querySelector('.u-content');
                if (titleElement) {
                    titleExample = titleElement.textContent.trim();
                    console.log('标题示例: ' + titleExample);
                }
                
                // 找到第一个项目的链接
                const linkElement = firstItemBox.querySelector('a');
                if (linkElement) {
                    linkExample = linkElement.getAttribute('href');
                    
                    // 如果标题为空，尝试从链接的title属性获取
                    if (!titleExample && linkElement.hasAttribute('title')) {
                        titleExample = linkElement.getAttribute('title');
                        console.log('从链接title属性获取标题: ' + titleExample);
                    }
                    
                    // 如果标题仍为空，尝试获取链接的文本内容
                    if (!titleExample) {
                        // 排除时间内容
                        const tempContent = linkElement.textContent.trim();
                        const timeElement = linkElement.querySelector('.u-time');
                        if (timeElement) {
                            const timeText = timeElement.textContent.trim();
                            titleExample = tempContent.replace(timeText, '').trim();
                        } else {
                            titleExample = tempContent;
                        }
                        
                        if (titleExample) {
                            console.log('从链接文本获取标题: ' + titleExample);
                        }
                    }
                }
                
                // 找到第一个项目的日期
                const dateElement = firstItemBox.querySelector('.u-time');
                if (dateElement) {
                    dateExample = dateElement.textContent.trim();
                    console.log('日期示例: ' + dateExample);
                }
                
                // 返回结构信息
                return {
                    isNBD: true,
                    containerSelector: containerSelector,
                    itemSelector: itemSelector,
                    titleSelector: '.u-newsText .u-content', // 更精确的标题选择器
                    linkSelector: 'a',
                    dateSelector: '.u-time',
                    itemCount: items.length,
                    titleExample: titleExample,
                    linkExample: linkExample,
                    dateExample: dateExample
                };
            } catch (e) {
                console.error('检测NBD结构时出错:', e);
                return null;
            }
        }
        
        // 设置测试按钮的事件处理
        function setupTestButtons() {
            // 从结果中获取选择器值
            const getCodeValueFromElement = (element) => {
                if (!element) return '';
                const codeEl = safeQuerySelector(element, 'code', false);
                return codeEl ? codeEl.textContent : '';
            };
            
            // 获取各个选择器的值
            let containerSelector = '';
            let itemSelector = '';
            let titleSelector = '';
            let linkSelector = '';
            let dateSelector = '';
            let summarySelector = '';
            let contentSelector = '';
            
            // 从结果中提取选择器
            const selectorItems = safeQuerySelector(document, '#resultModalBody li', true);
            for (let i = 0; i < selectorItems.length; i++) {
                const itemText = selectorItems[i].textContent;
                if (itemText.includes('容器选择器:')) {
                    containerSelector = getCodeValueFromElement(selectorItems[i]);
                    console.log('提取容器选择器:', containerSelector);
                } else if (itemText.includes('条目选择器:')) {
                    itemSelector = getCodeValueFromElement(selectorItems[i]);
                    console.log('提取条目选择器:', itemSelector);
                } else if (itemText.includes('标题选择器:')) {
                    titleSelector = getCodeValueFromElement(selectorItems[i]);
                    console.log('提取标题选择器:', titleSelector);
                } else if (itemText.includes('链接选择器:')) {
                    linkSelector = getCodeValueFromElement(selectorItems[i]);
                    console.log('提取链接选择器:', linkSelector);
                } else if (itemText.includes('日期选择器:')) {
                    dateSelector = getCodeValueFromElement(selectorItems[i]);
                    console.log('提取日期选择器:', dateSelector);
                } else if (itemText.includes('摘要选择器:')) {
                    summarySelector = getCodeValueFromElement(selectorItems[i]);
                    console.log('提取摘要选择器:', summarySelector);
                } else if (itemText.includes('内容选择器:')) {
                    contentSelector = getCodeValueFromElement(selectorItems[i]);
                    console.log('提取内容选择器:', contentSelector);
                }
            }
            
            // 确保选择器值已设置到表单字段
            if (itemSelector) {
                document.getElementById('itemSelector').value = itemSelector;
                document.getElementById('itemSelector').classList.add('is-valid');
                console.log('从测试按钮设置条目选择器:', itemSelector);
            }
            
            if (titleSelector) {
                document.getElementById('titleSelector').value = titleSelector;
                document.getElementById('titleSelector').classList.add('is-valid');
            }
            
            if (linkSelector) {
                document.getElementById('linkSelector').value = linkSelector;
                document.getElementById('linkSelector').classList.add('is-valid');
            }
            
            if (dateSelector) {
                document.getElementById('dateSelector').value = dateSelector;
                document.getElementById('dateSelector').classList.add('is-valid');
            }
            
            // 如果没有从li元素中找到选择器，尝试从表格中获取
            if (!titleSelector || !linkSelector) {
                console.log('尝试从表格中获取标题和链接选择器');
                
                // 尝试从标题表格中获取最高分的选择器
                const titleTable = safeQuerySelector(document, '#resultModalBody table:nth-of-type(1)', false);
                if (titleTable && !titleSelector) {
                    const firstRow = safeQuerySelector(titleTable, 'tbody tr:first-child', false);
                    if (firstRow) {
                        const firstCell = safeQuerySelector(firstRow, 'td:first-child code', false);
                        if (firstCell) {
                            titleSelector = firstCell.textContent;
                            console.log('从表格中提取标题选择器:', titleSelector);
                        }
                    }
                }
                
                // 尝试从链接表格中获取最高分的选择器
                const linkTable = safeQuerySelector(document, '#resultModalBody table:nth-of-type(2)', false);
                if (linkTable && !linkSelector) {
                    const firstRow = safeQuerySelector(linkTable, 'tbody tr:first-child', false);
                    if (firstRow) {
                        const firstCell = safeQuerySelector(firstRow, 'td:first-child code', false);
                        if (firstCell) {
                            linkSelector = firstCell.textContent;
                            console.log('从表格中提取链接选择器:', linkSelector);
                        }
                    }
                }
            }
            
            // 容器选择器测试
            const containerBtn = document.getElementById('test_container_btn');
            if (containerBtn) {
                containerBtn.onclick = function() {
                    testSelectorWithValue('container', containerSelector);
                };
            }
            
            // 条目选择器测试
            const itemBtn = document.getElementById('test_item_btn');
            if (itemBtn) {
                itemBtn.onclick = function() {
                    testSelectorWithValue('item', itemSelector);
                };
            }
            
            // 标题选择器测试
            const titleBtn = document.getElementById('test_title_btn');
            if (titleBtn) {
                titleBtn.onclick = function() {
                    testSelectorWithValue('title', titleSelector);
                };
            }
            
            // 链接选择器测试
            const linkBtn = document.getElementById('test_link_btn');
            if (linkBtn) {
                linkBtn.onclick = function() {
                    testSelectorWithValue('link', linkSelector);
                };
            }
            
            // 日期选择器测试
            const dateBtn = document.getElementById('test_date_btn');
            if (dateBtn) {
                dateBtn.onclick = function() {
                    testSelectorWithValue('date', dateSelector);
                };
            }
            
            // 摘要选择器测试
            const summaryBtn = document.getElementById('test_summary_btn');
            if (summaryBtn) {
                summaryBtn.onclick = function() {
                    testSelectorWithValue('summary', summarySelector);
                };
            }
            
            // 内容选择器测试
            const contentBtn = document.getElementById('test_content_btn');
            if (contentBtn) {
                contentBtn.onclick = function() {
                    testSelectorWithValue('content', contentSelector);
                };
            }
        }
        
        // 在页面加载完成后设置事件处理
        document.addEventListener('DOMContentLoaded', function() {
            // 设置"分析HTML"按钮的点击事件
            document.getElementById('analyzeHtmlBtn').addEventListener('click', analyzeHtml);
            
            // 测试按钮会在analyzeHtml函数完成后动态创建，所以不需要在这里设置
            // setupTestButtons();
        });
        
        // 辅助函数：判断字符串是否可能是日期
        function isLikelyDateString(text) {
            // 检查是否包含日期格式
            return /\d{1,4}[-\/\.年]\d{1,2}[-\/\.月]\d{1,2}/.test(text) || // 年-月-日格式
                  /\d{1,2}[-\/\.]\d{1,2}[-\/\.]\d{2,4}/.test(text) || // 日-月-年格式
                  /\d{1,2}:\d{1,2}/.test(text) || // 时:分格式
                  /\d{4}年\d{1,2}月\d{1,2}日/.test(text) || // 中文日期格式
                  /\d{2}-\d{2}\s\d{2}:\d{2}/.test(text) || // 和讯网格式 MM-DD HH:MM
                  /\d{2}-\d{2}/.test(text); // 简单的MM-DD格式
        }
        
        // 定义选择器按钮的点击处理函数，避免匿名函数重复定义
        function selectorButtonClickHandler() {
            const targetId = this.getAttribute('data-target');
            const value = this.getAttribute('data-value');
            document.getElementById(targetId).value = value;
            // 可选：在使用后高亮显示按钮，提供视觉反馈
            this.classList.remove('btn-outline-primary');
            this.classList.add('btn-primary');
            this.textContent = '已使用';
        }
        
        function formatHtmlContent(html) {
            // 移除多余的空白和空行
            html = html.trim();
            
            // 使用正则表达式进行初步处理
            // 将多个空格替换为单个空格
            html = html.replace(/\s{2,}/g, ' ');
            
            // 处理自闭合标签
            html = html.replace(/<([^\/][^>]*?)\/>/g, '<$1></$1>');
            
            // 防止一些特殊情况下标签之间的文本被错误地缩进
            html = html.replace(/>\s+</g, '> <');
            
            // 特别处理常见的新闻结构
            // 特殊处理liveNews、newsDl等特定类
            const specialClasses = ['liveNews', 'newsDl', 'newsBox', 'newsList', 'clearfix'];
            for (const className of specialClasses) {
                // 添加注释标记重要结构
                html = html.replace(new RegExp(`class=(["\'])[^"\']*${className}[^"\']*\\1`, 'gi'), 
                                  (match) => `${match} data-important="true"`);
            }
            
            let formatted = '';
            let indent = '';
            
            // 处理每个字符
            const len = html.length;
            let inTag = false;
            let inTagName = false;
            let tagName = '';
            let currentTagContent = '';
            let inComment = false;
            let inQuote = false; 
            let quoteChar = '';
            let lastNonSpaceChar = '';
            
            for (let i = 0; i < len; i++) {
                const char = html.charAt(i);
                const nextChar = i < len - 1 ? html.charAt(i + 1) : '';
                const prevChar = i > 0 ? html.charAt(i - 1) : '';
                
                // 更新最后一个非空格字符
                if (char !== ' ' && char !== '\n' && char !== '\t') {
                    lastNonSpaceChar = char;
                }
                
                // 处理注释
                if (char === '<' && nextChar === '!' && i + 3 < len && html.charAt(i + 2) === '-' && html.charAt(i + 3) === '-') {
                    inComment = true;
                    formatted += '\n' + indent + '<!-- ';
                    i += 3; // 跳过 "!--"
                    continue;
                }
                
                if (inComment) {
                    if (char === '-' && nextChar === '-' && i + 2 < len && html.charAt(i + 2) === '>') {
                        inComment = false;
                        formatted += ' -->';
                        i += 2; // 跳过 "->"
                        continue;
                    }
                    formatted += char;
                    continue;
                }
                
                // 处理引号
                if (inTag && (char === '"' || char === "'") && prevChar !== '\\') {
                    if (!inQuote) {
                        inQuote = true;
                        quoteChar = char;
                    } else if (char === quoteChar) {
                        inQuote = false;
                    }
                    formatted += char;
                    continue;
                }
                
                // 在引号内保持原样
                if (inQuote) {
                    formatted += char;
                    continue;
                }
                
                // 处理标签开始
                if (char === '<' && !inTag) {
                    inTag = true;
                    inTagName = true;
                    tagName = '';
                    currentTagContent = '<';
                    
                    // 处理结束标签缩进
                    if (nextChar === '/') {
                        if (indent.length > 0) {
                            indent = indent.substring(2);
                        }
                        formatted += '\n' + indent;
                    } else {
                        // 为非内联元素添加换行和缩进
                        // 特殊处理dl/dd/dt标签，使其对齐更美观
                        const nextTag = getTagName(html.substring(i));
                        const isSpecial = nextTag === 'dl' || nextTag === 'dt' || nextTag === 'dd';
                        
                        if ((isSpecial || !isInlineElement(nextTag)) && lastNonSpaceChar !== '>') {
                            formatted += '\n' + indent;
                        }
                    }
                    
                    continue;
                }
                
                // 收集标签名称
                if (inTag && inTagName && char !== ' ' && char !== '>' && char !== '/') {
                    tagName += char.toLowerCase();
                    currentTagContent += char;
                } else if (inTagName && inTag) {
                    inTagName = false;
                    currentTagContent += char;
                } else if (inTag) {
                    currentTagContent += char;
                }
                
                // 处理标签结束
                if (inTag && char === '>') {
                    inTag = false;
                    formatted += currentTagContent;
                    
                    // 特殊处理data-important属性
                    if (currentTagContent.includes('data-important="true"')) {
                        // 在重要结构前后添加空行
                        if (!currentTagContent.startsWith('</')) {
                            formatted += '\n' + indent + '<!-- 重要结构: ' + tagName + ' -->';
                        }
                    }
                    
                    // 为非内联元素和非自闭合标签添加缩进
                    if (!currentTagContent.includes('</') && !currentTagContent.includes('/>') && 
                        !isInlineElement(tagName) && nextChar !== '<') {
                        indent += '  ';
                    }
                    
                    continue;
                }
                
                // 只有在不在标签内时才添加字符，因为我们已经在处理标签结束时添加了完整的标签内容
                if (!inTag) {
                    formatted += char;
                }
            }
            
            // 最终清理
            // 删除首行的空行
            formatted = formatted.replace(/^\s*\n/, '');
            // 合并多个空行
            formatted = formatted.replace(/\n\s*\n/g, '\n');
            // 移除辅助属性
            formatted = formatted.replace(/data-important="true"/g, '');
            
            return formatted;
        }
        
        // 辅助函数：检查是否为内联元素
        function isInlineElement(tagName) {
            const inlineElements = ['a', 'abbr', 'acronym', 'b', 'bdo', 'big', 'br', 'button', 'cite', 'code', 
                                   'dfn', 'em', 'i', 'img', 'input', 'kbd', 'label', 'map', 'object', 'output', 
                                   'q', 'samp', 'script', 'select', 'small', 'span', 'strong', 'sub', 'sup', 
                                   'textarea', 'time', 'tt', 'var'];
            
            return inlineElements.includes(tagName);
        }
        
        // 辅助函数：从标签字符串中提取标签名
        function getTagName(tagString) {
            const match = tagString.match(/<\/?([a-z][a-z0-9]*)/i);
            return match ? match[1].toLowerCase() : '';
        }
        
        // 格式化HTML内容的函数
        function formatHtml() {
            try {
                const htmlContent = htmlEditor.getValue();
        
                if (!htmlContent || htmlContent.trim().length === 0) {
                    showToast('警告', '请先粘贴HTML内容', 'warning');
                    hideLoader();
                    return;
                }
                
                // 创建一个格式化后的HTML字符串
                let formattedHtml = '';
                
                try {
                    // 尝试使用更高级的格式化方法
                    formattedHtml = formatHtmlContent(htmlContent);
                } catch (err) {
                    console.error('高级格式化失败，回退到基础格式化', err);
                    
                    // 如果高级格式化失败，回退到基础格式化
                    try {
                        // 使用DOMParser解析HTML
                        const parser = new DOMParser();
                        const doc = parser.parseFromString(htmlContent, 'text/html');
                        
                        // 使用XMLSerializer重新序列化
                        const serializer = new XMLSerializer();
                        formattedHtml = serializer.serializeToString(doc);
                        
                        // 简单清理
                        formattedHtml = formattedHtml.replace(/><(?!\/)/g, '>\n<');
                    } catch (basicErr) {
                        // 如果两种方法都失败，保持原始内容
                        console.error('基础格式化失败', basicErr);
                        formattedHtml = htmlContent;
                        
                        showToast('错误', '格式化失败，HTML结构可能有问题', 'danger');
                        hideLoader();
                        return;
                    }
                }
                
                // 更新编辑器内容
                htmlEditor.setValue(formattedHtml);
                
                // 通知用户格式化完成
                hideLoader();
                showToast('成功', 'HTML已成功格式化！', 'success');
            } catch (error) {
                hideLoader();
                console.error('HTML格式化出错:', error);
                showToast('错误', '格式化HTML时出错: ' + error.message, 'danger');
            }
        }
        
        // 显示Toast消息
        function showToast(title, message, type = 'info') {
            // 创建toast容器，如果不存在
            let toastContainer = document.getElementById('toastContainer');
            if (!toastContainer) {
                toastContainer = document.createElement('div');
                toastContainer.id = 'toastContainer';
                toastContainer.className = 'toast-container position-fixed bottom-0 end-0 p-3';
                document.body.appendChild(toastContainer);
            }
            
            // 创建随机ID
            const toastId = 'toast-' + Math.random().toString(36).substr(2, 9);
            
            // 创建toast元素
            const toastHtml = `
                <div class="toast" id="${toastId}" role="alert" aria-live="assertive" aria-atomic="true">
                    <div class="toast-header bg-${type} text-white">
                        <strong class="me-auto">${title}</strong>
                        <button type="button" class="btn-close btn-close-white" data-bs-dismiss="toast" aria-label="Close"></button>
                    </div>
                    <div class="toast-body">
                        ${message}
                    </div>
                </div>
            `;
            
            // 添加toast到容器
            toastContainer.insertAdjacentHTML('beforeend', toastHtml);
            
            // 初始化并显示toast
            const toastElement = document.getElementById(toastId);
            const toast = new bootstrap.Toast(toastElement, {
                delay: 3000,
                autohide: true
            });
            
            toast.show();
            
            // 自动移除toast元素
            toastElement.addEventListener('hidden.bs.toast', function() {
                toastElement.remove();
            });
        }
        
        // 添加API健康检查函数
        function checkApiHealth() {
            // 先关闭可能已经存在的模态窗口实例，确保清理所有背景遮罩
            const existingModal = bootstrap.Modal.getInstance(document.getElementById('apiHealthModal'));
            if (existingModal) {
                existingModal.hide();
                
                // 强制清除所有可能的遮罩层
                document.querySelectorAll('.modal-backdrop').forEach(backdrop => {
                    backdrop.remove();
                });
                document.body.classList.remove('modal-open');
                document.body.style.overflow = '';
                document.body.style.paddingRight = '';
            }
            
            // 延迟一点再显示新的模态窗口，确保上一个完全关闭
            setTimeout(() => {
                const modal = new bootstrap.Modal(document.getElementById('apiHealthModal'));
                modal.show();
                
                // 定义API端点
            const endpoints = [
                { name: 'API信息', url: '/api-info', method: 'GET' },
                { name: '源类型列表', url: '/api/source-test/source-types', method: 'GET' },
                    // 标记为可选的有问题的端点
                    { name: '测试源示例', url: '/api/source-test/test-source/test', method: 'GET', optional: true },
                    { name: '创建源端点', url: '/api/source-test/create-custom-source', method: 'POST', optional: true }
                ];
                
                // 清空结果表格
                document.getElementById('apiHealthTable').innerHTML = `
                        <tr>
                            <th>端点名称</th>
                            <th>URL</th>
                            <th>状态</th>
                            <th>响应时间</th>
                            <th>操作</th>
                        </tr>
                `;
                
                // 创建一个函数来检查单个端点
                async function checkEndpoint(endpoint) {
            const startTime = performance.now();
                    try {
                        // 根据请求方法发送不同的请求
            const options = {
                            method: endpoint.method,
                            headers: {
                                'Accept': 'application/json'
                            }
            };
            
                        // 如果是POST请求，添加一个空的请求体
            if (endpoint.method === 'POST') {
                            options.body = JSON.stringify({});
                            options.headers['Content-Type'] = 'application/json';
                        }
                        
                        const response = await fetch(endpoint.url, options);
                    const endTime = performance.now();
                    const responseTime = (endTime - startTime).toFixed(2);
                        
                        // 更新表格
                        const statusClass = response.ok ? 'bg-success' : 'bg-danger';
                        const statusText = response.ok ? '可用' : (endpoint.optional ? '可选' : '错误 ' + response.status);
                        const rowClass = response.ok ? '' : (endpoint.optional ? 'table-warning' : 'table-danger');
                        
                        const row = document.createElement('tr');
                        row.className = rowClass;
                        row.innerHTML = `
                            <td>${endpoint.name}</td>
                            <td>${endpoint.url}</td>
                            <td><span class="badge ${response.ok ? 'bg-success' : (endpoint.optional ? 'bg-warning' : 'bg-danger')}">${statusText}</span></td>
                            <td>${responseTime} ms</td>
                            <td><button class="btn btn-sm btn-primary" onclick="showEndpointDetails(${JSON.stringify(endpoint).replace(/"/g, '&quot;')}, ${response.ok ? 'null' : 'new Error(\''+response.status+' '+response.statusText+'\')'}, ${responseTime})">详情</button></td>
                        `;
                        document.getElementById('apiHealthTable').appendChild(row);
                        
                        // 如果请求成功，获取响应内容并显示详情
                        if (response.ok) {
                            showEndpointDetails(endpoint, response, responseTime);
                        }
                        
                        return { success: response.ok, status: response.status, statusText: response.statusText };
                    } catch (error) {
                        console.error(`检查端点 ${endpoint.url} 时出错:`, error);
                    const endTime = performance.now();
                    const responseTime = (endTime - startTime).toFixed(2);
                        
                        // 更新表格
                        const row = document.createElement('tr');
                        row.className = endpoint.optional ? 'table-warning' : 'table-danger';
                        row.innerHTML = `
                            <td>${endpoint.name}</td>
                            <td>${endpoint.url}</td>
                            <td><span class="badge ${endpoint.optional ? 'bg-warning' : 'bg-danger'}">${endpoint.optional ? '可选' : '错误'}</span></td>
                            <td>${responseTime} ms</td>
                            <td><button class="btn btn-sm btn-primary" onclick="showEndpointDetails(${JSON.stringify(endpoint).replace(/"/g, '&quot;')}, new Error('${error.message}'), ${responseTime})">详情</button></td>
                        `;
                        document.getElementById('apiHealthTable').appendChild(row);
                        
                        return { success: false, error: error.message };
                    }
                }
                
                // 检查所有端点
                Promise.all(endpoints.map(checkEndpoint))
                    .then(results => {
                        // 计算API健康状态
                        const successCount = results.filter(r => r.success).length;
                        const requiredEndpoints = endpoints.filter(e => !e.optional).length;
                        const requiredSuccessCount = results.filter((r, i) => r.success && !endpoints[i].optional).length;
                    
                    // 更新状态
                        const healthPercentage = requiredEndpoints > 0 ? 
                            Math.round((requiredSuccessCount / requiredEndpoints) * 100) : 100;
                        
                        document.getElementById('apiHealthStatus').innerHTML = `
                            <div class="d-flex align-items-center">
                                <div class="progress flex-grow-1 me-3" style="height: 20px;">
                                    <div class="progress-bar ${healthPercentage >= 70 ? 'bg-success' : healthPercentage >= 40 ? 'bg-warning' : 'bg-danger'}" 
                                        role="progressbar" style="width: ${healthPercentage}%;" 
                                        aria-valuenow="${healthPercentage}" aria-valuemin="0" aria-valuemax="100">
                                        ${healthPercentage}%
                                    </div>
                                </div>
                                <span class="badge ${healthPercentage >= 70 ? 'bg-success' : healthPercentage >= 40 ? 'bg-warning' : 'bg-danger'}">
                                    ${healthPercentage >= 70 ? '健康' : healthPercentage >= 40 ? '不稳定' : '不健康'}
                                </span>
                            </div>
                        `;
                    });
            }, 100); // 短暂延迟以确保先前的模态窗口完全关闭
        }
        
        function showEndpointDetails(endpoint, response, responseTime) {
            const detailsContainer = document.getElementById('apiCheckDetails');
            
            // 将响应克隆一份，因为response.text()只能消费一次
            response.text().then(text => {
                let formattedContent = '<pre>无内容</pre>';
                
                try {
                    // 尝试解析为JSON
                    if (text.trim() && !endpoint.skipContent) {
                        const json = JSON.parse(text);
                        formattedContent = `<pre class="bg-dark text-light p-2">${JSON.stringify(json, null, 2)}</pre>`;
                    } else if (text.trim() && !endpoint.skipContent) {
                        formattedContent = `<pre class="bg-dark text-light p-2">${text}</pre>`;
                    }
                } catch (e) {
                    // 如果不是JSON，则显示原始文本
                    if (text.trim() && !endpoint.skipContent) {
                        formattedContent = `<pre class="bg-dark text-light p-2">${text}</pre>`;
                    }
                }
                
                // 获取响应头
                const headers = Array.from(response.headers.entries())
                    .map(([key, value]) => `<tr><td><strong>${key}</strong></td><td>${value}</td></tr>`)
                    .join('');
                
                detailsContainer.innerHTML = `
                    <div class="card">
                        <div class="card-header d-flex justify-content-between align-items-center">
                            <h5 class="mb-0">端点详情: ${endpoint.url}</h5>
                            <span class="badge ${response.ok ? 'bg-success' : 'bg-danger'}">
                                ${response.status} ${response.statusText}
                            </span>
                        </div>
                        <div class="card-body">
                            <p><strong>请求方法:</strong> ${endpoint.method}</p>
                            <p><strong>响应时间:</strong> ${responseTime} ms</p>
                            
                            <h6>响应头:</h6>
                            <div class="table-responsive" style="max-height: 200px; overflow-y: auto;">
                                <table class="table table-sm table-striped">
                                    <tbody>
                                        ${headers}
                                    </tbody>
                                </table>
                            </div>
                            
                            ${!endpoint.skipContent ? `
                                <h6 class="mt-3">响应内容:</h6>
                                <div style="max-height: 300px; overflow-y: auto;">
                                    ${formattedContent}
                                </div>
                            ` : '<p>响应内容已跳过</p>'}
                        </div>
                    </div>
                `;
            });
        }
        
        function handleAuthError(error, callback) {
            console.error('认证错误:', error);
            
            // 显示通知
            const toast = new bootstrap.Toast(document.getElementById('notificationToast'));
            document.getElementById('toastMessage').textContent = `需要认证: ${error.message}`;
            document.getElementById('notificationToast').classList.add('bg-warning', 'text-dark');
            toast.show();
            
            // 5秒后恢复原来的样式
            setTimeout(() => {
                document.getElementById('notificationToast').classList.remove('bg-warning', 'text-dark');
            }, 5000);
            
            // 保存回调，以便成功后调用
            window.authCallback = callback;
            
            // 显示认证模态框
            new bootstrap.Modal(document.getElementById('authModal')).show();
            
            return false; // 阻止事件冒泡
        }
        
        // 辅助函数：分析容器元素
        function analyzeContainers(htmlDoc) {
            const containerCandidates = [];
            
            // 尝试查找可能的新闻容器
            const possibleContainerSelectors = [
                // ID选择器 - 优先级高
                '#immeList', '#newslist', '#news', '#content', '#main', 
                '#newsList', '#articleList', '#article-list', '#news-container',
                
                // 具有特定ID模式的元素
                '[id*="news"]', '[id*="article"]', '[id*="list"]', '[id*="content"]',
                
                // 常见类选择器
                '.liveNews', '.newsBox', '.newsList', '.newsContainer', '.news-list',
                '.news-container', '.article-list', '.article-container', '.content-list',
                '.m_news', '.ntb', '.jd', '.jar', '.clearfix',
                
                // 具有特定类名模式的元素
                '[class*="news"]', '[class*="article"]', '[class*="list"]', 
                '[class*="content"]', '[class*="container"]'
            ];
            
            // 对每个选择器计算一个权重分数
            possibleContainerSelectors.forEach(selector => {
                try {
                    const elements = htmlDoc.querySelectorAll(selector);
                    
                    elements.forEach(element => {
                        if (element) {
                            // 初始权重
                            let weight = 0;
                            
                            // 容器直接子元素数量
                            const childCount = element.children.length;
                            if (childCount >= 3) weight += 10;  // 有多个子元素的容器可能性更大
                            if (childCount >= 10) weight += 15; // 有大量子元素的容器更可能是新闻列表
                            
                            // 检查容器是否包含列表项或类似结构
                            const liItems = element.querySelectorAll('li');
                            if (liItems.length >= 3) weight += 20;
                            
                            const dlItems = element.querySelectorAll('dl');
                            if (dlItems.length >= 3) weight += 20;
                            
                            const articles = element.querySelectorAll('article');
                            if (articles.length >= 3) weight += 25;
                            
                            // 检查子元素是否包含链接
                            const linkItems = element.querySelectorAll('a[href]');
                            if (linkItems.length >= 5) weight += 15;
                            
                            // 检查是否有重复模式子元素（同类标签的一级子元素）
                            const childTags = {};
                            Array.from(element.children).forEach(child => {
                                const tag = child.tagName.toLowerCase();
                                childTags[tag] = (childTags[tag] || 0) + 1;
                            });
                            
                            // 如果有3个以上相同标签的子元素，额外加分
                            Object.values(childTags).forEach(count => {
                                if (count >= 3) weight += 15;
                                if (count >= 10) weight += 10;
                            });
                            
                            // 优先考虑ID选择器
                            if (selector.startsWith('#')) weight += 30;
                            
                            // 如果是已知的新闻网站特殊容器，提高权重
                            if (['#immeList', '.ntb', '.m_news', '#toutiao'].includes(selector)) {
                                weight += 50;
                            }
                            
                            // 创建精确的选择器
                            let refinedSelector = selector;
                            // 如果初始选择器是类型选择器，尝试构建更精确的选择器
                            if (!selector.startsWith('#') && !selector.startsWith('.') && element.id) {
                                refinedSelector = `#${element.id}`;
                                weight += 20; // 优先考虑ID
                            } else if (!selector.startsWith('#') && element.className && element.className.trim()) {
                                refinedSelector = `.${element.className.trim().replace(/\s+/g, '.')}`;
                            }
                            
                            // 将候选项添加到结果中
                            containerCandidates.push({
                                selector: refinedSelector,
                                weight: weight,
                                childCount: childCount,
                                element: element
                            });
                        }
                    });
                } catch (e) {
                    console.error(`检查容器选择器 ${selector} 时出错:`, e);
                }
            });
            
            // 去重
            const uniqueCandidates = [];
            const seenSelectors = new Set();
            
            containerCandidates.forEach(candidate => {
                if (!seenSelectors.has(candidate.selector)) {
                    seenSelectors.add(candidate.selector);
                    uniqueCandidates.push(candidate);
                }
            });
            
            // 按权重排序
            return uniqueCandidates.sort((a, b) => b.weight - a.weight);
        }
        
        // 辅助函数：分析列表项
        function analyzeListItems(containerElement, containerSelector) {
            const itemCandidates = [];
            
            // 1. 检查常见的列表项模式
            const possibleItemSelectors = [
                // 标准HTML列表
                'ul > li', 'ol > li',  // 移除单独的'li'选择器，改用更具体的选择器
                
                // 通用的新闻列表项
                '.item', '.news-item', '.article', '.post', '.entry', '.itemBox',
                
                // 定义列表
                'dl', 'dt', 'dd',
                
                // 常见的文章/新闻容器
                'article', '.article', '.news', '.post', 
                
                // 通用的网格/卡片布局
                '.card', '.cell', '.grid-item', '.box', '.block',
                
                // 含有特殊类名的元素
                '[class*="item"]', '[class*="article"]', '[class*="news"]',
                
                // 特定网站类
                '.jd > li', '.jar > li', '.ntb > li', '.kuaiXunBox > li'
            ];
            
            // 添加容器子元素的直接选择器
            const directChildSelectors = [];
            const childTypes = new Map();
            
            // 遍历直接子元素并计数
            Array.from(containerElement.children).forEach(child => {
                const tagName = child.tagName.toLowerCase();
                if (!childTypes.has(tagName)) {
                    childTypes.set(tagName, 1);
                } else {
                    childTypes.set(tagName, childTypes.get(tagName) + 1);
                }
            });
            
            // 查找重复出现的子元素，这很可能是列表项
            childTypes.forEach((count, tagName) => {
                if (count >= 3) {
                    // 创建子元素的简单选择器 - 移除开头的 '>'
                    const simpleSelector = `${tagName}`;  // 改为仅使用标签名
                    
                    // 添加到候选列表
                    directChildSelectors.push(simpleSelector);
                    
                    // 检查是否有特定类名
                    const elementsWithClass = Array.from(containerElement.children)
                        .filter(el => el.tagName.toLowerCase() === tagName && el.className);
                    
                    // 如果多个元素有相同的类名，这可能是一个更精确的选择器
                    if (elementsWithClass.length >= 3) {
                        const classes = new Map();
                        
                        elementsWithClass.forEach(el => {
                            el.classList.forEach(className => {
                                if (!classes.has(className)) {
                                    classes.set(className, 1);
                                } else {
                                    classes.set(className, classes.get(className) + 1);
                                }
                            });
                        });
                        
                        // 查找出现在多个元素上的类名
                        classes.forEach((count, className) => {
                            if (count >= 3) {
                                directChildSelectors.push(`${tagName}.${className}`);  // 使用标签名.类名格式
                            }
                        });
                    }
                }
            });
            
            // 合并通用选择器和直接子元素选择器
            const allSelectors = [...possibleItemSelectors, ...directChildSelectors];
            
            // 对每个选择器评估分数
            allSelectors.forEach(selector => {
                try {
                    // 验证和修复选择器语法
                    let validSelector = selector;
                    try {
                        // 简单验证选择器语法
                        document.createElement('div').querySelector(validSelector);
                    } catch (syntaxError) {
                        console.error(`无效的选择器语法: ${selector}，尝试修复...`);
                        
                        // 修复常见的选择器问题
                        if (selector === 'li') {
                            validSelector = 'ul > li, ol > li, dl > li';
                            console.log(`将'li'选择器修正为: ${validSelector}`);
                        } else if (selector.includes('>') && !selector.includes(' > ')) {
                            validSelector = selector.replace(/>/g, ' > ');
                            console.log(`修正选择器空格: ${selector} -> ${validSelector}`);
                        }
                        
                        // 再次验证修复后的选择器
                        try {
                            document.createElement('div').querySelector(validSelector);
                        } catch (e) {
                            console.error(`无法修复选择器 ${selector}, 跳过此选择器`);
                            return; // 跳过此选择器
                        }
                    }
                    
                    // 构建完整选择器
                    const fullSelector = containerSelector ? 
                        `${containerSelector} ${validSelector}` : validSelector;
                    
                    // 查找匹配的元素
                    let items;
                    try {
                        items = containerElement.querySelectorAll(validSelector);
                    } catch (queryError) {
                        console.error(`执行querySelectorAll失败，选择器: ${validSelector}，错误: ${queryError.message}`);
                        return; // 跳过此选择器
                    }
                    
                    if (items.length >= 3) {
                        // 初始分数
                        let score = 0;
                        
                        // 项目数量得分
                        score += Math.min(items.length, 30) * 2;
                        
                        // 检查项目是否包含链接 - 新闻列表通常包含链接
                        let linkCount = 0;
                        items.forEach(item => {
                            if (item.querySelector('a')) linkCount++;
                        });
                        
                        // 如果大多数项目包含链接，增加分数
                        if (linkCount / items.length > 0.7) score += 30;
                        
                        // 检查相似性 - 新闻列表项通常有类似的结构
                        const structuralSimilarity = checkItemSimilarity(items);
                        score += structuralSimilarity * 20;
                        
                        // 优先考虑直接子元素
                        if (directChildSelectors.includes(selector)) score += 20;
                        
                        // 优先考虑带有类名的选择器
                        if (selector.includes('.')) score += 15;
                        
                        // 如果是特定网站专用选择器，给予高分
                        if (['.jd > li', '.jar > li', '.ntb > li'].includes(selector)) score += 50;
                        
                        // 添加到候选项
                        itemCandidates.push({
                            selector: fullSelector,
                            count: items.length,
                            score: score,
                            similarity: structuralSimilarity
                        });
                    }
                } catch (e) {
                    console.error(`分析列表项选择器 ${selector} 时出错:`, e);
                }
            });
            
            // 按分数排序
            return itemCandidates.sort((a, b) => b.score - a.score);
        }
        
        // 辅助函数：检查项目的结构相似性
        function checkItemSimilarity(items) {
            if (items.length < 3) return 0;
            
            // 只取前10个项目做相似性分析
            const sampleItems = Array.from(items).slice(0, Math.min(10, items.length));
            
            // 检查HTML结构相似性（简化版）
            const structures = sampleItems.map(item => {
                return {
                    hasLink: !!item.querySelector('a'),
                    hasImg: !!item.querySelector('img'),
                    hasParagraph: !!item.querySelector('p'),
                    hasHeading: !!item.querySelector('h1, h2, h3, h4, h5, h6'),
                    hasSpan: !!item.querySelector('span'),
                    hasTime: !!item.querySelector('time'),
                    childrenCount: item.children.length,
                    textLength: item.textContent.trim().length
                };
            });
            
            // 计算属性的一致性
            const consistencies = {};
            ['hasLink', 'hasImg', 'hasParagraph', 'hasHeading', 'hasSpan', 'hasTime'].forEach(prop => {
                const trueCount = structures.filter(s => s[prop]).length;
                consistencies[prop] = Math.max(trueCount, structures.length - trueCount) / structures.length;
            });
            
            // 计算子元素数量一致性（简化）
            const childrenCounts = structures.map(s => s.childrenCount);
            const avgChildren = childrenCounts.reduce((a, b) => a + b, 0) / childrenCounts.length;
            const childrenDeviation = childrenCounts.map(c => Math.abs(c - avgChildren)).reduce((a, b) => a + b, 0) / childrenCounts.length;
            const childrenConsistency = 1 - (childrenDeviation / (avgChildren || 1));
            
            // 计算文本长度一致性（简化）
            const textLengths = structures.map(s => s.textLength);
            const avgTextLength = textLengths.reduce((a, b) => a + b, 0) / textLengths.length;
            const textLengthDeviation = textLengths.map(l => Math.abs(l - avgTextLength)).reduce((a, b) => a + b, 0) / textLengths.length;
            const textLengthConsistency = 1 - (textLengthDeviation / (avgTextLength || 1));
            
            // 计算总体一致性分数（0-1范围）
            const weights = {
                hasLink: 0.3,
                hasImg: 0.1,
                hasParagraph: 0.1,
                hasHeading: 0.1,
                hasSpan: 0.1,
                hasTime: 0.1,
                childrenConsistency: 0.1,
                textLengthConsistency: 0.1
            };
            
            let totalScore = 0;
            Object.keys(consistencies).forEach(prop => {
                totalScore += consistencies[prop] * weights[prop];
            });
            
            totalScore += childrenConsistency * weights.childrenConsistency;
            totalScore += textLengthConsistency * weights.textLengthConsistency;
            
            return Math.min(1, Math.max(0, totalScore));
        }
        
        // 辅助函数：安全的querySelector，带有选择器验证
        function safeQuerySelector(element, selector, isAll = false) {
            if (!element || !selector) return isAll ? [] : null;
            
            // 预处理以 '>' 开头的选择器
            let processedSelector = selector;
            if (selector.trim().startsWith('>')) {
                // 去掉开头的 '>'，因为它需要前面有元素才有效
                processedSelector = selector.trim().substring(1).trim();
                console.log(`修正以'>'开头的选择器: ${selector} -> ${processedSelector}`);
                
                // 如果处理后的选择器为空，返回空结果
                if (!processedSelector.trim()) {
                    return isAll ? [] : null;
                }
            }
            
            try {
                // 验证选择器
                document.createElement('div').querySelector(processedSelector);
                
                // 执行查询
                return isAll ? element.querySelectorAll(processedSelector) : element.querySelector(processedSelector);
            } catch (e) {
                console.error(`选择器语法错误: ${processedSelector}，尝试修复...`);
                
                // 尝试修复常见的选择器错误
                let fixedSelector = processedSelector;
                
                if (processedSelector === 'li') {
                    fixedSelector = 'ul > li, ol > li, dl > li';
                    console.log(`修复选择器: ${processedSelector} -> ${fixedSelector}`);
                } else if (processedSelector.includes('>') && !processedSelector.includes(' > ')) {
                    fixedSelector = processedSelector.replace(/>/g, ' > ');
                    console.log(`修复选择器: ${processedSelector} -> ${fixedSelector}`);
                }
                
                // 再次测试修复后的选择器
                try {
                    document.createElement('div').querySelector(fixedSelector);
                    console.log(`选择器修复成功: ${fixedSelector}`);
                    return isAll ? element.querySelectorAll(fixedSelector) : element.querySelector(fixedSelector);
                } catch (fixError) {
                    console.error(`无法修复选择器: ${selector}，错误: ${fixError.message}`);
                    return isAll ? [] : null;
                }
            }
        }
        
        // 辅助函数：分析标题元素
        function analyzeTitleElement(itemElement, itemSelector) {
            const titleCandidates = [];
            console.log('======= 开始分析标题元素 =======');
            
            try {
                // 第一步：收集条目中所有的链接和标题元素
                const allLinks = safeQuerySelector(itemElement, 'a[href]', true);
                const allHeadings = safeQuerySelector(itemElement, 'h1, h2, h3, h4, h5, h6', true);
                console.log(`在条目中找到 ${allLinks.length} 个链接和 ${allHeadings.length} 个标题标签`);
                
                // 先检查特定的NBD结构 - 这是单独针对每日经济新闻网站做的处理
                try {
                    // 检查是否有.u-newsText .u-content结构
                    const uContentElements = safeQuerySelector(itemElement, '.u-newsText .u-content, .u-content', true);
                    if (uContentElements.length > 0) {
                        console.log(`找到NBD特定结构.u-content元素: ${uContentElements.length}个`);
                        
                        for (let i = 0; i < uContentElements.length; i++) {
                            const element = uContentElements[i];
                            const text = element.textContent.trim();
                            
                            if (text) {  // 确保文本不为空
                                const selector = buildElementSelector(element, itemElement);
                                titleCandidates.push({
                                    element: element,
                                    text: text,
                                    selector: selector,
                                    textLength: text.length,
                                    isLink: false,  // u-content通常不是链接本身
                                    score: 100,  // 给予最高分数，因为这是非常特定的结构
                                    href: ''
                                });
                                console.log(`添加NBD特定结构候选标题: "${text}", 选择器: ${selector}, 分数: 100`);
                            }
                        }
                    }
                    
                    // 如果没找到，尝试从父级链接获取标题
                    if (uContentElements.length === 0 && itemElement.tagName.toLowerCase() === 'li' && itemElement.classList.contains('itemBox')) {
                        // 查找链接的文本内容或内部div
                        const parentLink = safeQuerySelector(itemElement, 'a', false);
                        if (parentLink) {
                            // 尝试找链接中的文本，排除时间标记
                            let linkText = parentLink.textContent.trim();
                            const timeElement = safeQuerySelector(parentLink, '.u-time', false);
                            
                            if (timeElement) {
                                // 移除时间元素的文本
                                const timeText = timeElement.textContent.trim();
                                linkText = linkText.replace(timeText, '').trim();
                            }
                            
                            if (linkText) {
                                const selector = 'a';
                                titleCandidates.push({
                                    element: parentLink,
                                    text: linkText,
                                    selector: selector,
                                    textLength: linkText.length,
                                    isLink: true,
                                    score: 95,  // 次高分数
                                    href: parentLink.getAttribute('href') || ''
                                });
                                console.log(`从itemBox的链接中提取标题文本: "${linkText}", 选择器: ${selector}, 分数: 95`);
                            }
                        }
                    }
                } catch (e) {
                    console.error('尝试NBD特定结构时出错:', e);
                }

                // 检查特定的新闻网站结构
                try {
                    // 特定网站结构选择器
                    const specificSelectors = [
                    // 和讯网特定选择器
                        '.ntb > li > a',
                        '.ntb li > a',
                        'li > span > a',
                        '.title > a',
                        '.list li > a',
                        '.immeList li > a',
                        // 新增对 u-newsText 结构的支持
                        '.u-newsText .u-content',
                        '.u-newsText > div',
                        '.u-content',
                        'div.u-content'
                    ];
                    
                    for (const selector of specificSelectors) {
                        try {
                            const elements = safeQuerySelector(itemElement, selector, true);
                            if (elements.length > 0) {
                                console.log(`找到特定结构选择器 "${selector}" 匹配的元素: ${elements.length} 个`);
                                
                                // 检查这些元素是否包含较长的文本（可能是标题）
                                for (let i = 0; i < elements.length; i++) {
                                    const element = elements[i];
                                    const text = element.textContent.trim();
                                    const textLength = text.length;
                                    
                                    if (textLength > 5) {  // 修改为5个字符，以捕获更短的标题
                                        const selector = buildElementSelector(element, itemElement);
                                        titleCandidates.push({
                                            element: element,
                                            text: text,
                                            selector: selector,
                                            textLength: textLength,
                                            isLink: element.tagName.toLowerCase() === 'a',
                                            score: 85 + Math.min(textLength, 30),  // 较长的文本得分更高
                                            href: element.getAttribute('href') || ''
                                        });
                                        
                                        console.log(`添加特定结构候选标题: "${text}", 长度: ${textLength}, 分数: ${85 + Math.min(textLength, 30)}`);
                                    }
                                }
                            }
                        } catch (e) {
                            console.error(`检查特定网站选择器 ${selector} 时出错:`, e);
                        }
                    }
                } catch (e) {
                    console.error('尝试特定网站选择器时出错:', e);
                }
                
                // 第二步：查找每个列表项中最长文本的链接
                if (itemElement.tagName.toLowerCase() === 'li' || itemElement.closest('li')) {
                    const li = itemElement.tagName.toLowerCase() === 'li' ? itemElement : itemElement.closest('li');
                    const linksInLi = safeQuerySelector(li, 'a[href]', true);
                    
                    if (linksInLi.length > 0) {
                        // 找出最长文本的链接
                        let maxLength = 0;
                        let longestLink = null;
                        
                        for (let i = 0; i < linksInLi.length; i++) {
                            const link = linksInLi[i];
                            const text = link.textContent.trim();
                            const textLength = text.length;
                            
                            // 排除明显不是标题的链接
                            if (
                                text.includes('更多') || 
                                text.includes('详情') ||
                                text.match(/^\d{1,2}[-:]\d{1,2}/)  // 日期/时间格式
                            ) {
                                continue;
                            }
                            
                            if (textLength > maxLength) {
                                maxLength = textLength;
                                longestLink = link;
                            }
                        }
                        
                        // 如果找到最长的链接，添加为候选项
                        if (longestLink && maxLength > 5) {
                            const selector = buildElementSelector(longestLink, itemElement);
                            titleCandidates.push({
                                element: longestLink,
                                text: longestLink.textContent.trim(),
                                selector: selector,
                                textLength: maxLength,
                                isLink: true,
                                score: 90 + Math.min(maxLength, 30),  // 列表项中最长的链接得分更高
                                href: longestLink.getAttribute('href') || ''
                            });
                            
                            console.log(`添加列表项中最长文本链接候选: "${longestLink.textContent.trim()}", 长度: ${maxLength}, 分数: ${90 + Math.min(maxLength, 30)}`);
                        }
                    }
                }
                
                // 第三步：分析所有链接，特别关注文本长度
                for (let i = 0; i < allLinks.length; i++) {
                    const link = allLinks[i];
                    const text = link.textContent.trim();
                    const textLength = text.length;
                    
                    // 排除明显不是标题的链接
                    if (
                        text.includes('更多') || 
                        text.includes('详情') ||
                        text.length < 5 ||
                        text.match(/^\d{1,2}[-:]\d{1,2}/)  // 日期/时间格式
                    ) {
                        continue;
                    }
                    
                    // 基础分数
                    let score = 50;
                    
                    // 根据文本长度评分 - 通常标题在10-60字符之间
                    if (textLength >= 10 && textLength <= 60) {
                        score += Math.min(textLength, 30);  // 最多加30分
                    } else if (textLength > 60) {
                        score += 30 - Math.min((textLength - 60) / 10, 15);  // 过长的文本适当减分
                    } else {
                        score -= (10 - textLength) * 2;  // 太短的文本减分
                    }
                    
                    // 检查父元素 - 标题标签内的链接得分高
                    const parent = link.parentElement;
                    if (parent) {
                        const parentTag = parent.tagName.toLowerCase();
                        
                        // 标题标签内的链接
                        if (['h1', 'h2', 'h3', 'h4', 'h5', 'h6'].includes(parentTag)) {
                            score += 25;
                            console.log(`链接在标题标签(${parentTag})内 +25分`);
                        }
                        
                        // 特殊标签内的链接
                        if (['strong', 'b', 'em'].includes(parentTag)) {
                            score += 10;
                            console.log(`链接在强调标签(${parentTag})内 +10分`);
                        }
                        
                        // 特定类名的父元素
                        if (parent.className) {
                            const className = parent.className.toLowerCase();
                            if (className.includes('title') || className.includes('headline')) {
                                score += 20;
                                console.log(`链接父元素类名包含title/headline +20分`);
                            }
                        }
                    }
                    
                    // 检查链接是否在列表项内
                    const parentLi = link.closest('li');
                    if (parentLi) {
                        const linksInLi = safeQuerySelector(parentLi, 'a[href]', true);
                        
                        // 如果是列表项中唯一的链接，可能性更高
                        if (linksInLi.length === 1) {
                            score += 15;
                            console.log(`是列表项中唯一的链接 +15分`);
                        }
                        // 如果列表项中有多个链接，检查是否是第一个
                        else if (linksInLi.length > 1 && linksInLi[0] === link) {
                            score += 10;
                            console.log(`是列表项中的第一个链接 +10分`);
                        }
                    }
                    
                    // 构建选择器
                    const selector = buildElementSelector(link, itemElement);
                    
                    // 添加到候选项
                    titleCandidates.push({
                        element: link,
                        text: text,
                        selector: selector,
                        textLength: textLength,
                        isLink: true,
                        score: score,
                        href: link.getAttribute('href') || ''
                    });
                    
                    console.log(`添加链接候选: "${text.substring(0, 30)}${text.length > 30 ? '...' : ''}", 长度: ${textLength}, 分数: ${score}`);
                }
                
                // 第四步：分析标题标签
                for (let i = 0; i < allHeadings.length; i++) {
                    const heading = allHeadings[i];
                    const text = heading.textContent.trim();
                    const textLength = text.length;
                    
                    if (textLength < 5) continue;  // 跳过太短的标题
                    
                    // 标题标签自动获得高分
                    let score = 80;
                    
                    // 根据标题级别调整分数
                    const level = parseInt(heading.tagName.substring(1));
                    score += (7 - level) * 5;  // h1得分最高，h6得分最低
                    
                    // 根据文本长度调整
                    if (textLength > 10 && textLength < 100) {
                        score += Math.min(textLength / 2, 15);  // 最多加15分
                    }
                    
                    // 检查是否包含链接
                    const links = safeQuerySelector(heading, 'a', true);
                    const isLink = links.length > 0;
                    let href = '';
                    
                    if (isLink && links.length === 1) {
                        href = links[0].getAttribute('href') || '';
                    }
                    
                    // 构建选择器
                    const selector = buildElementSelector(heading, itemElement);
                    
                    // 添加到候选项
                    titleCandidates.push({
                        element: heading,
                        text: text,
                        selector: selector,
                        textLength: textLength,
                        isLink: isLink,
                        score: score,
                        href: href
                    });
                    
                    console.log(`添加标题标签候选: "${text.substring(0, 30)}${text.length > 30 ? '...' : ''}", 长度: ${textLength}, 分数: ${score}`);
                }
                
                // 按分数排序
                const sortedCandidates = titleCandidates.sort((a, b) => b.score - a.score);
                
                console.log(`找到 ${sortedCandidates.length} 个标题候选项，排序后最高分: ${sortedCandidates.length > 0 ? sortedCandidates[0].score : 0}`);
                if (sortedCandidates.length > 0) {
                    const topCandidate = sortedCandidates[0];
                    console.log(`最终选择的标题: "${topCandidate.text.substring(0, 50)}${topCandidate.text.length > 50 ? '...' : ''}", 选择器: ${topCandidate.selector}`);
                }
                console.log('======= 标题分析完成 =======');
                
                return sortedCandidates;
                
            } catch (e) {
                console.error('分析标题元素时出错:', e);
                return titleCandidates;  // 返回已收集的候选项
            }
            
            return titleCandidates.sort((a, b) => b.score - a.score);
        }
        
        // 辅助函数：分析链接元素
        function analyzeLinkElement(itemElement, itemSelector) {
            const linkCandidates = [];
            console.log('======= 开始分析链接元素 =======');
            
            try {
                // 第一步：获取标题分析结果，如果标题是链接，直接使用它作为主链接
                const titleCandidates = analyzeTitleElement(itemElement, itemSelector);
                let titleLink = null;
                
                if (titleCandidates.length > 0 && titleCandidates[0].isLink) {
                    const topTitle = titleCandidates[0];
                    console.log(`使用标题链接作为主链接: "${topTitle.text.substring(0, 30)}..."`);
                    
                    // 将标题链接添加为第一候选项，给予最高分数
                    linkCandidates.push({
                        selector: topTitle.selector,
                        href: topTitle.href || topTitle.element.getAttribute('href'),
                        text: topTitle.text,
                        score: 100, // 最高分
                        element: topTitle.element,
                        isTitleLink: true,
                        textLength: topTitle.textLength
                    });
                    
                    titleLink = topTitle.element;
                }
                
                // 第二步：收集条目中所有的链接
                const allLinks = safeQuerySelector(itemElement, 'a[href]', true);
                console.log(`在条目中找到 ${allLinks.length} 个链接`);
                
                if (allLinks.length === 0) {
                    console.log('未找到链接，无法提取链接选择器');
                    return linkCandidates; // 可能已经有标题链接
                }
                
                // 第三步：评估每个链接
                for (let i = 0; i < allLinks.length; i++) {
                    const link = allLinks[i];
                    
                    // 跳过已处理的标题链接
                    if (link === titleLink) {
                        console.log('跳过已处理的标题链接');
                        continue;
                    }
                    
                    const href = link.getAttribute('href');
                    if (!href || href === '#' || href.toLowerCase().startsWith('javascript:')) {
                        console.log(`跳过无效链接: ${href}`);
                        continue;
                    }
                    
                    const text = link.textContent.trim();
                    const textLength = text ? text.length : 0;
                    
                    // 基础分数
                    let score = 40;
                    
                    // 根据链接类型评分
                    if (href.match(/\.html?$/)) score += 15; // 链接到HTML页面
                    if (href.match(/\d{6,}/)) score += 10;   // 包含数字ID的链接
                    
                    // 和讯网特殊处理 - 同一个列表项中多个链接时
                    const parentLi = link.closest('li');
                    if (parentLi) {
                        const linksInLi = safeQuerySelector(parentLi, 'a', true);
                        
                        if (linksInLi.length > 1) {
                            // 如果标题已经是链接，并且是当前列表项中的一个，
                            // 那么其他链接可能是详情链接
                            if (titleLink && Array.from(linksInLi).includes(titleLink)) {
                                score += 5;
                                console.log(`同一列表项中与标题链接同时存在，可能是详情链接 +5分`);
                            }
                            
                            // 找出最长文本的链接
                            let maxLength = 0;
                            let longestLink = null;
                            for (let j = 0; j < linksInLi.length; j++) {
                                const l = linksInLi[j];
                                const lText = l.textContent.trim();
                                if (lText && lText.length > maxLength) {
                                    maxLength = lText.length;
                                    longestLink = l;
                                }
                            }
                            
                            // 如果当前链接是最长文本的链接，加分
                            if (link === longestLink) {
                                score += 15;
                                console.log(`列表项中最长文本的链接 +15分`);
                            }
                        }
                    }
                    
                    // 分析链接文本
                    if (text) {
                        if (text.length < 5) {
                            score -= 5; // 太短的文本，可能不是主要链接
                        } else if (text.length > 15) {
                            score += 5; // 较长的文本，可能是标题链接
                        }
                        
                        // 排除导航类链接
                        if (
                            text.includes('查看更多') || 
                            text.includes('更多') || 
                            text.includes('详情') ||
                            text.match(/^\d{1,2}[-:]\d{1,2}/) // 日期/时间格式
                        ) {
                            score -= 15;
                            console.log(`导航类链接扣分: "${text}" -15分`);
                        }
                    }
                    
                    // 检查父元素
                    const parent = link.parentElement;
                    if (parent) {
                        const parentTag = parent.tagName.toLowerCase();
                        
                        // 标题标签内的链接
                        if (['h1', 'h2', 'h3', 'h4', 'h5', 'h6'].includes(parentTag)) {
                            score += 10;
                            console.log(`链接在标题标签内 +10分`);
                        }
                        
                        // 特殊标签内的链接
                        if (['strong', 'b', 'em'].includes(parentTag)) {
                            score += 5;
                            console.log(`链接在强调标签内 +5分`);
                        }
                        
                        // 特定类名的父元素
                        if (parent.className) {
                            const className = parent.className.toLowerCase();
                            if (className.includes('title') || className.includes('headline')) {
                                score += 10;
                                console.log(`链接父元素类名包含title/headline +10分`);
                            }
                        }
                    }
                    
                    // 构建选择器
                    const selector = buildElementSelector(link, itemElement);
                    
                    // 添加到候选项
                    linkCandidates.push({
                        selector: selector,
                        href: href,
                        text: text,
                        score: score,
                        element: link,
                        isTitleLink: false,
                        textLength: textLength
                    });
                    
                    console.log(`添加链接候选: "${text ? text.substring(0, 30) + '...' : href.substring(0, 30) + '...'}", 评分: ${score}`);
                }
                
                // 按分数排序
                const sortedCandidates = linkCandidates.sort((a, b) => b.score - a.score);
                console.log(`最终选择的链接: ${sortedCandidates.length > 0 ? 
                    (sortedCandidates[0].href.substring(0, 30) + (sortedCandidates[0].href.length > 30 ? '...' : '')) : '无'}`);
                console.log('======= 链接分析完成 =======');
                return sortedCandidates;
                
            } catch (e) {
                console.error('分析链接元素时出错:', e);
                return linkCandidates; // 返回已收集的候选项
            }
        }
        
        // 辅助函数：构建元素选择器
        function buildElementSelector(element, contextElement) {
            if (!element) return '';
            
            // 尝试构建一个尽可能简洁但唯一的选择器
            let selector = '';
            let current = element;
            
            // ID选择器是最精确的
            if (element.id) {
                return `#${element.id}`;
            }
            
            // 尝试使用元素类型和类名
            if (element.className && element.className.trim()) {
                const classNames = element.className.trim().split(/\s+/);
                if (classNames.length > 0) {
                    // 使用第一个类名作为选择器
                    selector = `${element.tagName.toLowerCase()}.${classNames[0]}`;
                    
                    // 检查在上下文中是否唯一
                    if (contextElement.querySelectorAll(selector).length === 1) {
                        return selector;
                    }
                    
                    // 如果有多个类名，尝试组合以获得唯一性
                    if (classNames.length > 1) {
                        selector = `${element.tagName.toLowerCase()}.${classNames.join('.')}`;
                        if (contextElement.querySelectorAll(selector).length === 1) {
                            return selector;
                        }
                    }
                }
            }
            
            // 如果无法通过类名构建唯一选择器，尝试使用位置
            selector = element.tagName.toLowerCase();
            
            // 检查在上下文中是否唯一
            if (contextElement.querySelectorAll(selector).length === 1) {
                return selector;
            }
            
            // 如果不是唯一的，尝试使用简单路径
            let path = [];
            current = element;
            
            while (current !== contextElement && current.parentElement) {
                let tag = current.tagName.toLowerCase();
                
                // 如果有ID，使用ID并结束
                if (current.id) {
                    path.unshift(`#${current.id}`);
                    break;
                }
                
                // 如果有类名，添加第一个类
                if (current.className && current.className.trim()) {
                    const firstClass = current.className.trim().split(/\s+/)[0];
                    tag += `.${firstClass}`;
                }
                
                path.unshift(tag);
                current = current.parentElement;
                
                // 如果路径已经很长了，为避免过于复杂，提前结束
                if (path.length >= 3) break;
            }
            
            return path.join(' > ');
        }
        
        // 辅助函数：分析日期元素
        function analyzeDateElement(itemElement, titleCandidates) {
            const dateCandidates = [];
            
            // 通用日期选择器
            const commonDateSelectors = [
                '.date', '.time', '.publish-date', '.publish-time', '.post-date', '.post-time',
                '[class*="date"]', '[class*="time"]', '.timestamp', '.meta-date',
                'time', 'span.time', 'p.time', 'small', 'span small'
            ];
            
            // 遍历选择器并评估
            commonDateSelectors.forEach(selector => {
                try {
                    const elements = safeQuerySelector(itemElement, selector, true);
                    
                    elements.forEach(element => {
                        if (!element) return;
                        
                        const text = element.textContent.trim();
                        if (!text) return;
                        
                        // 排除可能是标题的元素
                        if (titleCandidates.some(title => title.element === element)) return;
                        
                        // 初始分数
                        let score = 0;
                        
                        // 检查是否有日期格式
                        if (isDateLike(text)) {
                            score += (isLikelyDateString(text) ? 50 : 20);
                            
                            // 如果包含"分钟前"、"小时前"等相对时间，增加分数
                            if (text.match(/(\d+)\s*(分钟|小时|天|周|月|年)前/)) {
                                score += 30;
                            }
                        } else {
                            // 非日期文本，减分
                            score -= 20;
                        }
                        
                        // 检查标签
                        const tagName = element.tagName.toLowerCase();
                        if (tagName === 'time') score += 30;
                        if (tagName === 'span' || tagName === 'small') score += 10;
                        
                        // 检查类名
                        if (element.className) {
                            const classLower = element.className.toLowerCase();
                            if (classLower.includes('date')) score += 25;
                            if (classLower.includes('time')) score += 25;
                            if (classLower.includes('pubdate')) score += 30;
                            if (classLower.includes('timestamp')) score += 20;
                        }
                        
                        // 构建选择器
                        let elementSelector = buildElementSelector(element, itemElement);
                        
                        // 添加到候选列表
                        dateCandidates.push({
                            selector: elementSelector,
                            text: text,
                            score: score,
                            element: element
                        });
                    });
                } catch (e) {
                    console.error(`分析日期选择器 ${selector} 时出错:`, e);
                }
            });
            
            // 特殊处理：如果没有找到日期元素，尝试分析文本节点
            if (dateCandidates.length === 0) {
                // 尝试从文本节点中找日期
                walkTextNodesForDate(itemElement, dateCandidates);
            }
            
            // 按分数排序
            return dateCandidates.sort((a, b) => b.score - a.score);
        }
        
        // 辅助函数：检查文本是否类似日期
        function isDateLike(text) {
            // 检查是否包含日期格式
            return /\d{1,4}[-\/\.年]\d{1,2}[-\/\.月]\d{1,2}/.test(text) || // 年-月-日格式
                  /\d{1,2}[-\/\.]\d{1,2}[-\/\.]\d{2,4}/.test(text) || // 日-月-年格式
                  /\d{1,2}:\d{1,2}/.test(text) || // 时:分格式
                  /\d{4}年\d{1,2}月\d{1,2}日/.test(text) || // 中文日期格式
                  /\d{2}-\d{2}\s\d{2}:\d{2}/.test(text) || // 和讯网格式 MM-DD HH:MM
                  /\d{2}-\d{2}/.test(text) || // 简单的MM-DD格式
                  /(\d+)\s*(分钟|小时|天|周|月|年)前/.test(text); // 相对时间格式，如"30分钟前"
        }
        
        // 新增：处理相对时间，将"x分钟前"、"x小时前"等格式转换为JavaScript Date对象
        function parseRelativeTime(text) {
            if (!text) return null;
            
            // 获取当前时间
            const now = new Date();
            let result = null;
            
            // 匹配"x分钟前"、"x小时前"等格式
            const minutesMatch = text.match(/(\d+)\s*分钟前/);
            if (minutesMatch) {
                const minutes = parseInt(minutesMatch[1], 10);
                result = new Date(now.getTime() - minutes * 60 * 1000);
                console.log(`解析相对时间 "${text}" 为 ${result.toISOString()}`);
                return result;
            }
            
            const hoursMatch = text.match(/(\d+)\s*小时前/);
            if (hoursMatch) {
                const hours = parseInt(hoursMatch[1], 10);
                result = new Date(now.getTime() - hours * 60 * 60 * 1000);
                console.log(`解析相对时间 "${text}" 为 ${result.toISOString()}`);
                return result;
            }
            
            const daysMatch = text.match(/(\d+)\s*天前/);
            if (daysMatch) {
                const days = parseInt(daysMatch[1], 10);
                result = new Date(now.getTime() - days * 24 * 60 * 60 * 1000);
                console.log(`解析相对时间 "${text}" 为 ${result.toISOString()}`);
                return result;
            }
            
            const weeksMatch = text.match(/(\d+)\s*周前/);
            if (weeksMatch) {
                const weeks = parseInt(weeksMatch[1], 10);
                result = new Date(now.getTime() - weeks * 7 * 24 * 60 * 60 * 1000);
                console.log(`解析相对时间 "${text}" 为 ${result.toISOString()}`);
                return result;
            }
            
            const monthsMatch = text.match(/(\d+)\s*月前/);
            if (monthsMatch) {
                const months = parseInt(monthsMatch[1], 10);
                result = new Date(now);
                result.setMonth(result.getMonth() - months);
                console.log(`解析相对时间 "${text}" 为 ${result.toISOString()}`);
                return result;
            }
            
            const yearsMatch = text.match(/(\d+)\s*年前/);
            if (yearsMatch) {
                const years = parseInt(yearsMatch[1], 10);
                result = new Date(now);
                result.setFullYear(result.getFullYear() - years);
                console.log(`解析相对时间 "${text}" 为 ${result.toISOString()}`);
                return result;
            }
            
            // 如果没有匹配到相对时间格式，返回null
            return null;
        }
        
        // 辅助函数：从文本节点中查找日期
        function walkTextNodesForDate(element, dateCandidates) {
            try {
                const textWalker = document.createTreeWalker(
                    element,
                    NodeFilter.SHOW_TEXT,
                    {
                        acceptNode: function(node) {
                            return node.textContent.trim() ? NodeFilter.FILTER_ACCEPT : NodeFilter.FILTER_REJECT;
                        }
                    },
                    false
                );
                
                let textNode;
                while (textNode = textWalker.nextNode()) {
                    const text = textNode.textContent.trim();
                    if (isDateLike(text)) {
                        // 找到包含日期的文本节点
                        const parentElement = textNode.parentElement;
                        if (!parentElement) continue;
                        
                        // 构建选择器
                        let elementSelector = buildElementSelector(parentElement, element);
                        
                        // 评分
                        let score = 20; // 基础分
                        
                        // 如果是相对时间格式，增加分数
                        if (text.match(/(\d+)\s*(分钟|小时|天|周|月|年)前/)) {
                            score += 30;
                        }
                        
                        // 添加到候选列表
                        dateCandidates.push({
                            selector: elementSelector,
                            text: text,
                            score: score,
                            element: parentElement,
                            isTextNode: true
                        });
                    }
                }
            } catch (e) {
                console.error('分析文本节点日期时出错:', e);
            }
        }
        
        // 辅助函数：分析摘要元素
        function analyzeSummaryElement(itemElement, titleCandidates, dateCandidates) {
            const summaryCandidates = [];
            
            // 通用摘要选择器
            const commonSummarySelectors = [
                'p:not(:first-child)', '.summary', '.excerpt', '.description', '.desc',
                '[class*="summary"]', '[class*="excerpt"]', '[class*="desc"]',
                '.content p:first-child', 'p.intro', '.introduction'
            ];
            
            // 遍历选择器并评估
            commonSummarySelectors.forEach(selector => {
                try {
                    const elements = safeQuerySelector(itemElement, selector, true);
                    
                    elements.forEach(element => {
                        if (!element) return;
                        
                        const text = element.textContent.trim();
                        if (!text || text.length < 10) return; // 摘要通常至少有10个字符
                        
                        // 跳过可能是标题或日期的元素
                        if (titleCandidates.some(title => title.element === element)) return;
                        if (dateCandidates.some(date => date.element === element)) return;
                        
                        // 初始分数
                        let score = 0;
                        
                        // 基于文本长度给分 - 摘要通常在30-300字符范围内
                        const textLength = text.length;
                        if (textLength >= 30 && textLength <= 300) {
                            score += 20;
                            // 理想长度范围给更高分
                            if (textLength >= 50 && textLength <= 200) score += 10;
                        } else if (textLength > 300) {
                            // 太长可能是内容而不是摘要
                            score -= (textLength - 300) / 20;
                        }
                        
                        // 检查标签
                        const tagName = element.tagName.toLowerCase();
                        if (tagName === 'p') score += 15;
                        
                        // 检查类名
                        if (element.className) {
                            const classLower = element.className.toLowerCase();
                            if (classLower.includes('summary')) score += 30;
                            if (classLower.includes('excerpt')) score += 30;
                            if (classLower.includes('desc')) score += 25;
                            if (classLower.includes('intro')) score += 20;
                        }
                        
                        // 构建选择器
                        let elementSelector = buildElementSelector(element, itemElement);
                        
                        // 添加到候选列表
                        summaryCandidates.push({
                            selector: elementSelector,
                            text: text,
                            score: score,
                            element: element
                        });
                    });
                } catch (e) {
                    console.error(`分析摘要选择器 ${selector} 时出错:`, e);
                }
            });
            
            // 按分数排序
            return summaryCandidates.sort((a, b) => b.score - a.score);
        }
        
        // 辅助函数：分析内容元素
        function analyzeContentElement(itemElement, titleCandidates, summaryCandidates, dateCandidates) {
            const contentCandidates = [];
            
            // 通用内容选择器
            const commonContentSelectors = [
                '.content', '.article-body', '.article-content', '.text', '.body',
                '[class*="content"]', '[class*="body"]', '.main-text',
                'article p', '.article p', '.post-content'
            ];
            
            // 遍历选择器并评估
            commonContentSelectors.forEach(selector => {
                try {
                    const elements = safeQuerySelector(itemElement, selector, true);
                    
                    elements.forEach(element => {
                        if (!element) return;
                        
                        const text = element.textContent.trim();
                        if (!text || text.length < 20) return; // 内容通常至少有20个字符
                        
                        // 跳过可能是标题、摘要或日期的元素
                        if (titleCandidates.some(title => title.element === element)) return;
                        if (summaryCandidates.some(summary => summary.element === element)) return;
                        if (dateCandidates.some(date => date.element === element)) return;
                        
                        // 初始分数
                        let score = 0;
                        
                        // 基于文本长度给分 - 内容通常比较长
                        const textLength = text.length;
                        if (textLength >= 100) {
                            score += 20;
                            if (textLength >= 200) score += 10;
                        }
                        
                        // 检查元素
                        const tagName = element.tagName.toLowerCase();
                        if (tagName === 'div' || tagName === 'article') score += 10;
                        
                        // 检查类名
                        if (element.className) {
                            const classLower = element.className.toLowerCase();
                            if (classLower.includes('content')) score += 25;
                            if (classLower.includes('article')) score += 20;
                            if (classLower.includes('body')) score += 20;
                            if (classLower.includes('text')) score += 15;
                        }
                        
                        // 构建选择器
                        let elementSelector = buildElementSelector(element, itemElement);
                        
                        // 添加到候选列表
                        contentCandidates.push({
                            selector: elementSelector,
                            text: text.substring(0, 100) + (text.length > 100 ? '...' : ''),
                            fullText: text,
                            score: score,
                            element: element
                        });
                    });
                } catch (e) {
                    console.error(`分析内容选择器 ${selector} 时出错:`, e);
                }
            });
            
            // 按分数排序
            return contentCandidates.sort((a, b) => b.score - a.score);
        }
        
        // 辅助函数：创建分析结果消息
        function createResultMessage(foundSelectors, htmlDoc) {
            let resultMessage = '';
            
            // 添加成功消息
            resultMessage += `<div class="alert alert-success mb-4">
                <h5>HTML分析完成！</h5>
                ${hasFoundAny(foundSelectors) ? 
                    `<p>找到 ${countFoundItems(foundSelectors)} 个可能的新闻条目。</p>` : 
                    `<p>找到 0 个可能的新闻条目。</p>`}
            </div>`;
            
            // 添加选择器列表
            resultMessage += `<h5>自动选择的选择器:</h5>
            <ul>`;
            
            // 添加条目选择器
            resultMessage += `<li>条目选择器: ${foundSelectors.item.length > 0 ? 
                `<code>${foundSelectors.item[0].selector}</code> <button class="btn btn-sm btn-primary" id="test_item_btn">测试</button>` : 
                "<span class='text-warning'>未找到</span>"}</li>`;
            
            // 添加标题选择器
            resultMessage += `<li>标题选择器: ${foundSelectors.title.length > 0 ? 
                `<code>${foundSelectors.title[0].selector}</code> <button class="btn btn-sm btn-primary" id="test_title_btn">测试</button>` : 
                "<span class='text-warning'>未找到</span>"}</li>`;
            
            // 添加链接选择器
            resultMessage += `<li>链接选择器: ${foundSelectors.link.length > 0 ? 
                `<code>${foundSelectors.link[0].selector}</code> <button class="btn btn-sm btn-primary" id="test_link_btn">测试</button>` : 
                "<span class='text-warning'>未找到</span>"}</li>`;
            
            // 添加日期选择器
            resultMessage += `<li>日期选择器: ${foundSelectors.date.length > 0 ? 
                `<code>${foundSelectors.date[0].selector}</code> <button class="btn btn-sm btn-primary" id="test_date_btn">测试</button>` : 
                "<span class='text-warning'>未找到</span>"}</li>`;
            
            // 添加附加提示
            resultMessage += `<li>可能还有单独的摘要内容。</li>
            <li>内容可能在详情页面中，此处无法获取。</li>
            </ul>`;
            
            // 检查是否找到任何选择器，如果没有提供建议
            if (!hasFoundAny(foundSelectors)) {
                resultMessage += `<div class="alert alert-warning mt-3">
                    <h6>未找到合适的选择器</h6>
                    <p>可能的原因：</p>
                    <ul>
                        <li>HTML结构过于复杂或非标准</li>
                        <li>内容可能需要JavaScript渲染</li>
                        <li>可能需要手动配置选择器</li>
                    </ul>
                </div>`;
            }
            
            // 尝试检测新的复杂结构
            const complexStructure = detectComplexStructure(htmlDoc);
            if (complexStructure) {
                resultMessage += `<div class="alert alert-info mt-3">
                    <h6>检测到复杂结构</h6>
                    <p>检测到以下复杂结构模式:</p>
                    <ul>
                        ${complexStructure.map(pattern => `<li>${pattern.name}: <code>${pattern.selector}</code></li>`).join('')}
                    </ul>
                    <p>建议尝试使用这些选择器组合获取内容。</p>
                </div>`;
            }
            
            return resultMessage;
        }
        
        // 检测复杂结构模式
        function detectComplexStructure(htmlDoc) {
            const patterns = [];
            
            // 检测嵌套列表结构
            try {
                // 检查 .kuaiXunBox > .itemBox 结构
                const kuaixunItemBoxes = htmlDoc.querySelectorAll('.kuaiXunBox > .itemBox, .content.normal-real .itemBox');
                if (kuaixunItemBoxes.length >= 3) {
                    patterns.push({
                        name: '快讯盒子结构',
                        selector: kuaixunItemBoxes[0].parentElement.className.includes('kuaiXunBox') ? 
                            '.kuaiXunBox > .itemBox' : '.content.normal-real .itemBox',
                        count: kuaixunItemBoxes.length
                    });
                    
                    // 检查 u-newsText 结构
                    const uNewsTexts = htmlDoc.querySelectorAll('.itemBox .u-newsText');
                    if (uNewsTexts.length >= 3) {
                        patterns.push({
                            name: '新闻内容结构',
                            selector: '.itemBox .u-newsText .u-content',
                            count: uNewsTexts.length
                        });
                    }
                    
                    // 特别处理NBD网站的标题结构
                    const uContents = htmlDoc.querySelectorAll('.itemBox .u-content, .u-newsText .u-content');
                    if (uContents.length >= 3) {
                        patterns.push({
                            name: 'NBD新闻内容结构',
                            selector: '.itemBox a .u-newsText .u-content, .itemBox .u-content',
                            count: uContents.length
                        });
                    }
                }
                
                // 检查其他常见复杂结构
                // 检查带有时间标记的结构
                const timeMarkers = htmlDoc.querySelectorAll('.u-time, .time, [class*="time"]');
                if (timeMarkers.length >= 3) {
                    patterns.push({
                        name: '带时间标记的新闻项',
                        selector: timeMarkers[0].closest('li, .item, [class*="item"]')?.tagName.toLowerCase() + 
                                  ' > ' + timeMarkers[0].tagName.toLowerCase() + 
                                  (timeMarkers[0].className ? '.' + timeMarkers[0].className.split(' ')[0] : ''),
                        count: timeMarkers.length
                    });
                }
                
                // 检查多层深度嵌套结构
                const deepNested = findDeepNestedStructures(htmlDoc);
                if (deepNested) {
                    patterns.push(deepNested);
                }
                
            } catch (e) {
                console.error('检测复杂结构时出错:', e);
            }
            
            return patterns.length > 0 ? patterns : null;
        }
        
        // 查找深层嵌套结构
        function findDeepNestedStructures(htmlDoc) {
            try {
                // 查找至少有3层嵌套的结构
                const potentialNestedSelectors = [
                    'li a div', 
                    'div > div > div > a',
                    '.item > a > div',
                    '[class*="item"] > a > div',
                    '.itemBox > a > div',
                    '.itemBox > a > .u-newsText',
                    '.itemBox > a > span + div',
                    // 添加NBD特定结构
                    '.content.normal-real .itemBox',
                    '.content.normal-real .itemBox a .u-newsText',
                    '.content.normal-real .itemBox a .u-newsText .u-content',
                ];
                
                for (const selector of potentialNestedSelectors) {
                    const elements = htmlDoc.querySelectorAll(selector);
                    if (elements.length >= 3) {
                        return {
                            name: '深层嵌套结构',
                            selector: selector,
                            count: elements.length
                        };
                    }
                }
                
                // 特殊检查NBD网站的结构
                const nbdStructure = htmlDoc.querySelectorAll('.content.normal-real .itemBox a .u-newsText .u-content');
                if (nbdStructure.length >= 3) {
                    return {
                        name: 'NBD新闻内容嵌套结构',
                        selector: '.content.normal-real .itemBox a .u-newsText .u-content',
                        count: nbdStructure.length
                    };
                }
                
                        } catch (e) {
                console.error('查找深层嵌套结构时出错:', e);
            }
            
            return null;
        }

        // 辅助函数：测试选择器并展示结果
        function testSelectorWithValue(type, selectorValue) {
            if (!window.parsedHtmlDoc || !selectorValue) {
                showToast('错误', '无法测试选择器，HTML文档未解析或选择器为空', 'danger');
                return;
            }
            
            try {
                // 验证并修复选择器语法
                const validSelector = validateAndFixSelector(selectorValue, type);
                
                // 在解析后的HTML文档中测试选择器
                const elements = window.parsedHtmlDoc.querySelectorAll(validSelector);
                
                // 确保无论如何都设置选择器到对应的输入框
                const targetInput = document.getElementById(`${type}Selector`);
                if (targetInput) {
                    targetInput.value = validSelector;
                    targetInput.classList.add('is-valid');
                    console.log(`测试后设置 ${type} 选择器为: ${validSelector}`);
                } else {
                    console.error(`无法找到 ${type}Selector 输入框`);
                }
                
                // 显示结果消息
                if (elements.length > 0) {
                    let resultHTML = `
                        <div class="alert alert-success">
                            <p>选择器 <code>${validSelector}</code> 匹配了 ${elements.length} 个元素。</p>
                        </div>
                        <div class="mt-3">
                            <h6>匹配元素内容示例:</h6>
                            <div class="list-group">
                    `;
                    
                    // 最多显示5个匹配元素的内容
                    const maxToShow = Math.min(elements.length, 5);
                    for (let i = 0; i < maxToShow; i++) {
                        const element = elements[i];
                        const elementHTML = element.outerHTML;
                        const elementText = element.textContent.trim();
                        
                        resultHTML += `
                            <div class="list-group-item">
                                <small class="text-muted">元素 #${i+1}:</small>
                                <div class="text-break">${elementText.substring(0, 100)}${elementText.length > 100 ? '...' : ''}</div>
                                <div class="accordion mt-2" id="element${i}Accordion">
                                    <div class="accordion-item">
                                        <h2 class="accordion-header">
                                            <button class="accordion-button collapsed p-1" type="button" data-bs-toggle="collapse" data-bs-target="#element${i}Html">
                                                查看HTML
                                            </button>
                                        </h2>
                                        <div id="element${i}Html" class="accordion-collapse collapse" data-bs-parent="#element${i}Accordion">
                                            <div class="accordion-body p-2">
                                                <pre class="bg-light p-2" style="max-height: 200px; overflow: auto; font-size: 0.8rem;">${escapeHTML(elementHTML)}</pre>
                                            </div>
                                        </div>
                                    </div>
                                </div>
                            </div>
                        `;
                    }
                    
                    resultHTML += `
                            </div>
                        </div>
                    `;
                    
                    // 添加选择器使用建议
                    resultHTML += `
                        <div class="alert alert-info mt-3">
                            <p><strong>建议:</strong> 已将此选择器值填入表单的 ${getTypeName(type)} 字段。</p>
                        </div>
                    `;
                    
                    // 显示在模态框中
                    const resultModalBody = document.getElementById('resultModalBody');
                    resultModalBody.innerHTML = resultHTML;
                    
                    // 显示Toast通知
                    showToast('成功', `成功找到 ${elements.length} 个匹配 ${getTypeName(type)} 的元素！`, 'success');
                        } else {
                    // 未找到匹配元素
                    const resultModalBody = document.getElementById('resultModalBody');
                    resultModalBody.innerHTML = `
                        <div class="alert alert-warning">
                            <p>选择器 <code>${validSelector}</code> 未匹配到任何元素。</p>
                            <p>请检查选择器语法或尝试其他选择器。</p>
                        </div>
                        <div class="mt-3">
                            <h6>解决方案建议:</h6>
                            <ul>
                                <li>确保选择器语法正确</li>
                                <li>尝试使用更简单的选择器，如 <code>.class-name</code> 或 <code>tag-name</code></li>
                                <li>使用浏览器开发者工具检查元素的实际类名和结构</li>
                                <li>对于复杂的嵌套结构，尝试分步选择每一层</li>
                            </ul>
                        </div>
                    `;
                    
                    // 显示Toast通知
                    showToast('警告', `选择器 ${validSelector} 未匹配到任何元素`, 'warning');
                }
                
            } catch (e) {
                console.error('测试选择器时出错:', e);
                showToast('错误', `测试选择器时出错: ${e.message}`, 'danger');
                
                // 显示错误消息
                const resultModalBody = document.getElementById('resultModalBody');
                resultModalBody.innerHTML = `
                    <div class="alert alert-danger">
                        <p><strong>测试选择器时出错</strong></p>
                        <p>${e.message}</p>
                    </div>
                `;
            }
        }

        // 辅助函数：验证并修复选择器语法
        function validateAndFixSelector(selector, type) {
            if (!selector) return '';
            
            let validSelector = selector.trim();
            
            try {
                // 简单测试选择器语法
                document.createElement('div').querySelector(validSelector);
                return validSelector;
            } catch (e) {
                console.error(`选择器 "${selector}" 语法无效，尝试修复...`);
                
                // 常见错误修复
                if (validSelector.startsWith('>')) {
                    validSelector = validSelector.substring(1).trim();
                }
                
                if (validSelector.includes('>>')) {
                    validSelector = validSelector.replace(/>>/g, '>');
                }
                
                // 确保类名前有"."
                if (validSelector.includes('class=')) {
                    validSelector = validSelector.replace(/\[class=(['"])([^'"]+)\1\]/g, '.$2');
                }
                
                // 修复常见错误组合
                validSelector = validSelector.replace(/\s{2,}/g, ' ').trim();
                
                // 特殊处理NBD网站
                if (validSelector.includes('normal-real') && !validSelector.includes('.normal-real')) {
                    validSelector = validSelector.replace(/normal-real/g, '.normal-real');
                }
                
                // 针对特定类型的选择器进行优化
                if (type === 'title' && validSelector === '.u-content') {
                    // 对于标题优化u-content选择器
                    validSelector = '.itemBox .u-newsText .u-content, .itemBox .u-content, .u-content';
                } else if (type === 'link' && !validSelector.toLowerCase().includes('a')) {
                    // 链接选择器应该包含a标签
                    if (validSelector.includes('.')) {
                        // 类选择器，添加a标签
                        validSelector = `a${validSelector}`;
                            } else {
                        // 可能是标签选择器
                        validSelector = `a, ${validSelector}`;
                    }
                }
                
                // 再次测试修复后的选择器
                try {
                    document.createElement('div').querySelector(validSelector);
                    console.log(`选择器已修复: "${selector}" -> "${validSelector}"`);
                    return validSelector;
            } catch (e) {
                    // 如果仍然无效，返回原始选择器并记录错误
                    console.error(`无法修复选择器 "${selector}": ${e.message}`);
                return selector;
                }
            }
        }
        
        // 辅助函数：检查是否有任何选择器被找到
        function hasFoundAny(foundSelectors) {
            return (
                (foundSelectors.container && foundSelectors.container.length > 0) ||
                (foundSelectors.item && foundSelectors.item.length > 0) ||
                (foundSelectors.title && foundSelectors.title.length > 0) ||
                (foundSelectors.link && foundSelectors.link.length > 0) ||
                (foundSelectors.date && foundSelectors.date.length > 0) ||
                (foundSelectors.summary && foundSelectors.summary.length > 0) ||
                (foundSelectors.content && foundSelectors.content.length > 0)
            );
        }
        
        // 辅助函数：计算找到的条目数量
        function countFoundItems(foundSelectors) {
            let count = 0;
            
            // 优先使用item选择器
            if (foundSelectors.item && foundSelectors.item.length > 0) {
                count = foundSelectors.item[0].count || 0;
            }
            // 如果没有item选择器但有容器选择器
            else if (foundSelectors.container && foundSelectors.container.length > 0) {
                const containerSelector = foundSelectors.container[0].selector;
                try {
                    const container = window.parsedHtmlDoc.querySelector(containerSelector);
                    if (container) {
                        // 尝试计数可能的子元素
                        const childElements = container.children;
                        if (childElements.length > 0) {
                            count = childElements.length;
                        }
                }
            } catch (e) {
                    console.error('计算条目数量时出错:', e);
                }
            }
            // 如果找到标题选择器但没有item选择器
            else if (foundSelectors.title && foundSelectors.title.length > 0) {
                try {
                    const titleSelector = foundSelectors.title[0].selector;
                    const elements = window.parsedHtmlDoc.querySelectorAll(titleSelector);
                    count = elements.length;
                } catch (e) {
                    console.error('使用标题选择器计算条目数量时出错:', e);
                }
            }
            
            return count;
        }
        
        // 辅助函数：获取选择器类型的名称
        function getTypeName(type) {
            const typeNames = {
                'container': '容器',
                'item': '条目',
                'title': '标题',
                'link': '链接',
                'date': '日期',
                'summary': '摘要',
                'content': '内容'
            };
            
            return typeNames[type] || type;
        }
        
        // 辅助函数：设置选择器
        function setSelector(type, value) {
            try {
                let element = null;
                
                if (type === 'container') {
                    element = document.getElementById('containerSelector');
                } else if (type === 'item') {
                    element = document.getElementById('itemSelector');
                } else if (type === 'title') {
                    element = document.getElementById('titleSelector');
                } else if (type === 'link') {
                    element = document.getElementById('linkSelector');
                } else if (type === 'date') {
                    element = document.getElementById('dateSelector');
                } else if (type === 'summary') {
                    element = document.getElementById('summarySelector');
                } else if (type === 'content') {
                    element = document.getElementById('contentSelector');
                }
                
                // 如果元素存在，设置其值
                if (element) {
                    element.value = value;
                    console.log(`已设置 ${type} 选择器为: ${value}`);
                    
                    // 添加视觉反馈，让用户知道字段已经被填充
                    element.classList.add('is-valid');
                    
                    // 添加调试输出，以帮助排查问题
                    console.log(`设置选择器: ${type}, 值: ${value}, 元素ID: ${element.id}, 当前值: ${element.value}`);
                } else {
                    console.warn(`无法找到选择器输入框: ${type}`);
                    // 尝试直接通过ID查找
                    const directElement = document.getElementById(`${type}Selector`);
                    if (directElement) {
                        directElement.value = value;
                        directElement.classList.add('is-valid');
                        console.log(`通过直接ID找到并设置 ${type} 选择器为: ${value}`);
                    } else {
                        console.error(`完全无法找到 ${type} 选择器元素，所有尝试均失败`);
                    }
                }
            } catch (e) {
                console.error(`设置选择器 ${type} 时出错:`, e);
                
                // 出错时的备用方法 - 直接设置
                try {
                    document.getElementById(`${type}Selector`).value = value;
                    console.log(`使用备用方法设置 ${type} 选择器为: ${value}`);
                } catch (backupError) {
                    console.error(`备用方法也失败:`, backupError);
                }
            }
        }
        
        // 辅助函数：HTML转义
        function escapeHTML(html) {
            if (!html) return '';
            return html
                .replace(/&/g, '&amp;')
                .replace(/</g, '&lt;')
                .replace(/>/g, '&gt;')
                .replace(/"/g, '&quot;')
                .replace(/'/g, '&#039;');
        }
        
        // 智能选择器生成：处理现代CSS框架生成的复杂类名
        function buildSmartElementSelector(element, contextElement) {
            if (!element) return '';
            
            // 1. 首先尝试ID - 这是最精确的
            if (element.id) {
                return `#${element.id}`;
            }
            
            const tagName = element.tagName.toLowerCase();
            let selector = '';
            
            // 2. 处理类名
            if (element.className && element.className.trim()) {
                // 分析类名
                const classesAnalysis = analyzeClassNames(element.className);
                
                // 如果有框架特定类名，优先使用
                if (classesAnalysis.frameworkClasses.length > 0) {
                    const frameworkClass = classesAnalysis.frameworkClasses[0];
                    // 使用属性选择器处理包含特殊字符的类名
                    if (frameworkClass.includes('__') || frameworkClass.includes('--') || frameworkClass.includes('_')) {
                        // 提取前缀部分作为选择器
                        const prefix = extractClassPrefix(frameworkClass);
                        selector = `${tagName}[class*="${prefix}"]`;
                        
                        // 检查是否唯一
                        try {
                            if (contextElement.querySelectorAll(selector).length === 1) {
                                return selector;
                            }
                        } catch (e) {
                            console.warn('选择器检查失败:', e);
                        }
                    }
                }
                
                // 尝试使用标准类名
                if (classesAnalysis.standardClasses.length > 0) {
                    // 使用第一个标准类名
                    selector = `${tagName}.${classesAnalysis.standardClasses[0]}`;
                    
                    // 检查唯一性
                    try {
                        if (contextElement.querySelectorAll(selector).length === 1) {
                            return selector;
                        }
                    } catch (e) {
                        console.warn('选择器检查失败:', e);
                    }
                    
                    // 如果不唯一，尝试组合多个类名
                    if (classesAnalysis.standardClasses.length > 1) {
                        // 最多使用3个类名，避免过于复杂
                        const limitedClasses = classesAnalysis.standardClasses.slice(0, 3);
                        selector = `${tagName}.${limitedClasses.join('.')}`;
                        
                        try {
                            if (contextElement.querySelectorAll(selector).length === 1) {
                                return selector;
                            }
                    } catch (e) {
                            console.warn('选择器检查失败:', e);
                        }
                    }
                }
                
                // 特殊处理Ant Design组件
                if (element.className.includes('ant-')) {
                    // 查找所有ant-开头的类名
                    const antClasses = element.className.split(/\s+/).filter(c => c.startsWith('ant-'));
                    if (antClasses.length > 0) {
                        // 找出最具体的类名（通常是最长的）
                        const mostSpecificClass = antClasses.sort((a, b) => b.length - a.length)[0];
                        selector = `${tagName}.${mostSpecificClass}`;
                        
                        try {
                            if (contextElement.querySelectorAll(selector).length === 1) {
                                return selector;
                            }
                        } catch (e) {
                            console.warn('选择器检查失败:', e);
                        }
                        
                        // 如果单个类名不唯一，尝试组合
                        if (antClasses.length > 1) {
                            selector = `${tagName}.${antClasses.slice(0, 2).join('.')}`;
                            try {
                                if (contextElement.querySelectorAll(selector).length === 1) {
                                    return selector;
                            }
                        } catch (e) {
                                console.warn('选择器检查失败:', e);
                            }
                        }
                    }
                }
                
                // 3. 特殊处理CSS Modules (类名中包含哈希值)
                if (classesAnalysis.cssModulesClasses.length > 0) {
                    // 获取第一个CSS Module类名的前缀部分
                    const moduleClass = classesAnalysis.cssModulesClasses[0];
                    const prefix = moduleClass.split('_')[0] || moduleClass.split('__')[0];
                    
                    if (prefix) {
                        // 使用属性选择器匹配前缀，避免使用完整哈希
                        selector = `${tagName}[class*="${prefix}"]`;
                        
                        try {
                            if (contextElement.querySelectorAll(selector).length === 1) {
                                return selector;
                            }
                        } catch (e) {
                            console.warn('选择器检查失败:', e);
                        }
                    }
                }
                
                // 如果所有类名方法都失败，尝试通用属性选择器
                if (classesAnalysis.allClasses.length > 0) {
                    // 使用第一个类名的起始部分作为属性选择器
                    const firstClass = classesAnalysis.allClasses[0];
                    // 提取前3-4个字符作为属性选择器的值
                    const attrValue = firstClass.slice(0, Math.min(4, firstClass.length));
                    
                    if (attrValue && attrValue.length >= 2) {
                        selector = `${tagName}[class*="${attrValue}"]`;
                        
                        try {
                            const matches = contextElement.querySelectorAll(selector);
                            // 如果匹配太多，尝试更精确的选择器
                            if (matches.length === 1) {
                                return selector;
                            } else if (matches.length <= 5) {
                                // 尝试获取更多上下文
                                const parent = element.parentElement;
                                if (parent && parent !== contextElement) {
                                    const parentTag = parent.tagName.toLowerCase();
                                    return `${parentTag} ${selector}`;
                                }
                            }
                        } catch (e) {
                            console.warn('选择器检查失败:', e);
                        }
                    }
                }
            }
            
            // 4. 属性选择器 - 针对特定元素类型使用其他属性
            // 对于链接，尝试使用href属性的一部分
            if (tagName === 'a' && element.hasAttribute('href')) {
                const href = element.getAttribute('href');
                if (href && !href.startsWith('javascript:') && href !== '#') {
                    // 从URL中提取特征部分
                    const urlParts = href.split('/').filter(Boolean);
                    if (urlParts.length > 0) {
                        const lastPart = urlParts[urlParts.length - 1];
                        // 检查是否包含特定标识符
                        if (lastPart && lastPart.includes('detail')) {
                            selector = `a[href*="detail"]`;
                            try {
                                if (contextElement.querySelectorAll(selector).length === 1) {
                                    return selector;
                                }
                            } catch (e) {
                                console.warn('选择器检查失败:', e);
                            }
                        }
                    }
                }
            }
            
            // 对于图片，尝试使用src或alt属性
            if (tagName === 'img') {
                if (element.hasAttribute('alt') && element.getAttribute('alt')) {
                    selector = `img[alt="${element.getAttribute('alt')}"]`;
                    try {
                        if (contextElement.querySelectorAll(selector).length === 1) {
                            return selector;
                        }
                    } catch (e) {
                        console.warn('选择器检查失败:', e);
                    }
                }
            }
            
            // 5. 基于位置的选择器
            // 如果所有方法都失败，尝试使用位置和路径
            let path = [];
            let current = element;
            
            while (current !== contextElement && current.parentElement) {
                let curTag = current.tagName.toLowerCase();
                
                // 如果有ID，使用ID并结束
                if (current.id) {
                    path.unshift(`#${current.id}`);
                    break;
                }
                
                // 如果有类名，尝试使用简单的类名
                if (current.className && current.className.trim()) {
                    const classes = current.className.trim().split(/\s+/);
                    // 优先选择标准类名
                    const standardClass = classes.find(c => !c.includes('__') && !c.includes('--') && !c.includes('_'));
                    if (standardClass) {
                        curTag += `.${standardClass}`;
                    } else if (classes.length > 0) {
                        // 对于复杂类名，使用属性选择器
                        const prefix = extractClassPrefix(classes[0]);
                        if (prefix && prefix.length >= 2) {
                            curTag += `[class*="${prefix}"]`;
                        }
                    }
                }
                
                // 8. 如果有特定角色，添加角色属性
                if (current.hasAttribute('role')) {
                    curTag += `[role="${current.getAttribute('role')}"]`;
                }
                
                path.unshift(curTag);
                current = current.parentElement;
                
                // 限制路径长度，避免过于复杂
                if (path.length >= 3) {
                    break;
                }
            }
            
            // 构建最终选择器
            return path.join(' > ');
        }
        
        // 辅助函数：分析类名
        function analyzeClassNames(classNameStr) {
            if (!classNameStr || !classNameStr.trim()) {
                return {
                    allClasses: [],
                    standardClasses: [],
                    frameworkClasses: [],
                    cssModulesClasses: []
                };
            }
            
            const classes = classNameStr.trim().split(/\s+/);
            const result = {
                allClasses: classes,
                standardClasses: [],
                frameworkClasses: [],
                cssModulesClasses: []
            };
            
            classes.forEach(cls => {
                // 检测CSS模块类名 (包含哈希值，如：header_a1b2c3)
                if (/^[a-zA-Z0-9_-]+_[a-zA-Z0-9]+$/.test(cls) || cls.includes('__') && /[0-9]/.test(cls)) {
                    result.cssModulesClasses.push(cls);
                }
                // 检测框架类名 (如BEM: block__element--modifier 或 Tailwind: bg-blue-500)
                else if (cls.includes('__') || cls.includes('--') || 
                         /^[a-z]+-[a-z]+-\d+$/.test(cls) || // Tailwind类型
                         cls.startsWith('ant-') || // Ant Design
                         cls.startsWith('el-') || // Element UI
                         cls.startsWith('mui-') || // Material UI
                         cls.startsWith('van-')) { // Vant
                    result.frameworkClasses.push(cls);
                }
                // 标准类名
                else {
                    result.standardClasses.push(cls);
                }
            });
            
            return result;
        }
        
        // 辅助函数：从复杂类名中提取前缀
        function extractClassPrefix(className) {
            if (!className) return '';
            
            // 1. BEM命名风格: block__element--modifier
            if (className.includes('__')) {
                return className.split('__')[0];
            }
            if (className.includes('--')) {
                return className.split('--')[0];
            }
            
            // 2. CSS Modules: componentName_hash
            if (/^[a-zA-Z0-9_-]+_[a-zA-Z0-9]+$/.test(className)) {
                return className.split('_')[0];
            }
            
            // 3. 通用框架前缀
            const frameworkPrefixes = ['ant-', 'el-', 'mui-', 'van-', 'n-'];
            for (const prefix of frameworkPrefixes) {
                if (className.startsWith(prefix)) {
                    // 返回包括第一个破折号后的部分
                    const parts = className.split('-');
                    if (parts.length > 2) {
                        return `${parts[0]}-${parts[1]}`;
                    }
                    return prefix;
                }
            }
            
            // 4. 针对带数字哈希后缀的类名
            const match = className.match(/^([a-zA-Z0-9_-]+)[a-zA-Z0-9]{5,}$/);
            if (match) {
                return match[1];
            }
            
            // 5. 通用情况：返回前3-5个字符
            return className.slice(0, Math.min(5, className.length));
        }
        
        // 更新：支持特殊结构检测
        function detectSpecialStructures(htmlDoc) {
            // 首先检测Timeline结构
            const timelineStructure = detectTimelineStructure(htmlDoc);
            if (timelineStructure) {
                return timelineStructure;
            }
            
            // 检测NBD结构
            const nbdStructure = detectNBDStructure(htmlDoc);
            if (nbdStructure) {
                return nbdStructure;
            }
            
            // 检测新浪新闻卡片结构
            const sinaStructure = detectSinaNewsStructure(htmlDoc);
            if (sinaStructure) {
                return sinaStructure;
            }
            
            // 如果没有检测到特殊结构，返回null
            return null;
        }
        
        // 新增：检测Timeline结构
        function detectTimelineStructure(htmlDoc) {
            try {
                // 检查是否为Timeline结构
                const hasTimelineClass = !!htmlDoc.querySelector('.ant-timeline') || 
                                         !!htmlDoc.querySelector('[class*="timeline"]');
                const hasTimelineItems = !!htmlDoc.querySelector('.ant-timeline-item') || 
                                         !!htmlDoc.querySelector('li[class*="timeline"]');
                
                if (!hasTimelineClass || !hasTimelineItems) {
                    return null;
                }
                
                console.log('检测到Timeline时间轴结构');
                
                // 找到Timeline容器
                const timelineContainer = htmlDoc.querySelector('.ant-timeline') || 
                                          htmlDoc.querySelector('[class*="timeline"]');
                
                // 找到第一个Timeline项目
                const timelineItem = htmlDoc.querySelector('.ant-timeline-item') || 
                                     htmlDoc.querySelector('li[class*="timeline"]');
                
                if (!timelineContainer || !timelineItem) return null;
                
                // 分析容器类名
                const containerClass = timelineContainer.className;
                const containerPrefix = extractClassPrefix(containerClass.split(/\s+/)[0]);
                
                // 分析项目类名
                const itemClass = timelineItem.className;
                const itemPrefix = extractClassPrefix(itemClass.split(/\s+/)[0]);
                
                // 构建选择器
                const containerSelector = timelineContainer.classList.contains('ant-timeline') 
                    ? '.ant-timeline' 
                    : `[class*="${containerPrefix}"]`;
                    
                const itemSelector = timelineItem.classList.contains('ant-timeline-item')
                    ? `${containerSelector} .ant-timeline-item`
                    : `${containerSelector} li[class*="${itemPrefix}"]`;
                
                // 在Timeline项目中查找标题和链接元素
                const titleElement = timelineItem.querySelector('p[class*="title"]') || 
                                     timelineItem.querySelector('a p') ||
                                     timelineItem.querySelector('p') ||
                                     timelineItem.querySelector('a');
                
                const linkElement = timelineItem.querySelector('a[href]');
                
                // 构建标题选择器
                let titleSelector = '';
                if (titleElement) {
                    const titleClass = titleElement.className;
                    if (titleClass && titleClass.trim()) {
                        const titlePrefix = extractClassPrefix(titleClass.split(/\s+/)[0]);
                        titleSelector = titleElement.tagName.toLowerCase() === 'p'
                            ? `${itemSelector} p[class*="${titlePrefix}"]`
                            : titleElement.tagName.toLowerCase() === 'a'
                              ? `${itemSelector} a`
                              : `${itemSelector} ${titleElement.tagName.toLowerCase()}[class*="${titlePrefix}"]`;
                    } else {
                        titleSelector = `${itemSelector} ${titleElement.tagName.toLowerCase()}`;
                    }
                } else {
                    // 默认使用a标签作为标题
                    titleSelector = `${itemSelector} a`;
                }
                
                // 构建链接选择器
                const linkSelector = linkElement ? `${itemSelector} a[href]` : titleSelector;
                
                // 查找日期/时间元素
                const timeElement = timelineItem.querySelector('[class*="time"]') ||
                                   timelineItem.querySelector('div[class*="time"]') ||
                                   timelineItem.querySelector('span[class*="time"]');
                
                let dateSelector = '';
                if (timeElement) {
                    const timeClass = timeElement.className;
                    if (timeClass && timeClass.trim()) {
                        const timePrefix = extractClassPrefix(timeClass.split(/\s+/)[0]);
                        dateSelector = `${itemSelector} [class*="${timePrefix}"]`;
                    } else {
                        dateSelector = `${itemSelector} ${timeElement.tagName.toLowerCase()}`;
                    }
                }
                
                // 尝试获取一些示例文本
                let titleExample = '';
                let linkExample = '';
                let dateExample = '';
                
                if (titleElement) {
                    titleExample = titleElement.textContent.trim();
                }
                
                if (linkElement) {
                    linkExample = linkElement.getAttribute('href');
                }
                
                if (timeElement) {
                    dateExample = timeElement.textContent.trim();
                }
                
                console.log('Timeline结构分析完成');
                console.log(`- 容器选择器: ${containerSelector}`);
                console.log(`- 项目选择器: ${itemSelector}`);
                console.log(`- 标题选择器: ${titleSelector}`);
                console.log(`- 链接选择器: ${linkSelector}`);
                console.log(`- 日期选择器: ${dateSelector}`);
                
                // 计算匹配的项目数量
                const items = htmlDoc.querySelectorAll(itemSelector);
                
                return {
                    isTimeline: true,
                    containerSelector: containerSelector,
                    itemSelector: itemSelector,
                    titleSelector: titleSelector,
                    linkSelector: linkSelector,
                    dateSelector: dateSelector,
                    itemCount: items.length,
                    titleExample: titleExample,
                    linkExample: linkExample,
                    dateExample: dateExample
                };
                
            } catch (e) {
                console.error('检测Timeline结构时出错:', e);
                return null;
            }
        }

        // 使用原有的位置重写选择器生成逻辑，调用我们的新函数
        const originalBuildElementSelector = buildElementSelector;
        buildElementSelector = function(element, contextElement) {
            try {
                // 先尝试使用智能选择器生成器
                const smartSelector = buildSmartElementSelector(element, contextElement);
                
                // 检查生成的选择器是否有效
                try {
                    if (smartSelector && contextElement.querySelector(smartSelector) === element) {
                        console.log(`使用智能选择器: ${smartSelector}`);
                        return smartSelector;
                    }
            } catch (e) {
                    console.warn('智能选择器验证失败，回退到原始方法:', e);
                }
                
                // 如果智能选择器失败，回退到原始方法
                return originalBuildElementSelector(element, contextElement);
            } catch (e) {
                console.error('构建选择器时出错，回退到原始方法:', e);
                return originalBuildElementSelector(element, contextElement);
            }
        };

        // 新增：检测新浪新闻卡片结构
        function detectSinaNewsStructure(htmlDoc) {
            try {
                // 检查是否为新浪新闻结构
                const hasSinaNewsClass = !!htmlDoc.querySelector('.feed-card-item') || 
                                         !!htmlDoc.querySelector('.news-item');
                
                if (!hasSinaNewsClass) {
                    return null;
                }
                
                console.log('检测到新浪新闻卡片结构');
                
                // 查找新闻容器
                let containerSelector = '';
                let newsContainer = null;
                
                // 尝试多种可能的容器选择器
                const possibleContainers = [
                    '.feed-card-list',
                    '.feed-list',
                    '.news-list',
                    '.card-list'
                ];
                
                for (const selector of possibleContainers) {
                    const container = htmlDoc.querySelector(selector);
                    if (container) {
                        containerSelector = selector;
                        newsContainer = container;
                        break;
                    }
                }
                
                // 如果没有找到容器，回退到通用方法
                if (!newsContainer) {
                    return null;
                }
                
                // 查找新闻项
                let itemSelector = '';
                let newsItem = null;
                
                const possibleItems = [
                    '.feed-card-item',
                    '.news-item',
                    '.card-item'
                ];
                
                for (const selector of possibleItems) {
                    const item = newsContainer.querySelector(selector);
                    if (item) {
                        itemSelector = `${containerSelector} ${selector}`;
                        newsItem = item;
                        break;
                    }
                }
                
                // 如果没有找到项目，回退到通用方法
                if (!newsItem) {
                    return null;
                }
                
                // 分析标题和链接元素
                let titleSelector = '';
                let linkSelector = '';
                let dateSelector = '';
                
                // 查找标题元素
                const titleElement = newsItem.querySelector('.feed-card-title') || 
                                     newsItem.querySelector('.news-title') ||
                                     newsItem.querySelector('h2') ||
                                     newsItem.querySelector('a');
                
                if (titleElement) {
                    // 构建选择器
                    if (titleElement.className && titleElement.className.trim()) {
                        const titleClass = titleElement.className.trim().split(/\s+/)[0];
                        titleSelector = `${itemSelector} .${titleClass}`;
                    } else {
                        titleSelector = `${itemSelector} ${titleElement.tagName.toLowerCase()}`;
                    }
                }
                
                // 查找链接元素
                const linkElement = titleElement && titleElement.tagName.toLowerCase() === 'a' ? 
                                    titleElement : 
                                    newsItem.querySelector('a');
                
                if (linkElement) {
                    // 如果链接元素就是标题，使用相同的选择器
                    if (linkElement === titleElement) {
                        linkSelector = titleSelector;
                    } else {
                        linkSelector = `${itemSelector} a`;
                    }
                }
                
                // 查找日期元素
                const dateElement = newsItem.querySelector('.feed-card-time') || 
                                    newsItem.querySelector('.news-time') ||
                                    newsItem.querySelector('[class*="time"]') ||
                                    newsItem.querySelector('[class*="date"]');
                
                if (dateElement) {
                    if (dateElement.className && dateElement.className.trim()) {
                        const dateClass = dateElement.className.trim().split(/\s+/)[0];
                        dateSelector = `${itemSelector} .${dateClass}`;
                    } else {
                        dateSelector = `${itemSelector} ${dateElement.tagName.toLowerCase()}`;
                    }
                }
                
                // 获取示例
                let titleExample = titleElement ? titleElement.textContent.trim() : '';
                let linkExample = linkElement ? linkElement.getAttribute('href') : '';
                let dateExample = dateElement ? dateElement.textContent.trim() : '';
                
                // 计算匹配的项目数量
                const items = htmlDoc.querySelectorAll(itemSelector);
                
                // 返回结构信息
                return {
                    isSinaNews: true,
                    containerSelector: containerSelector,
                    itemSelector: itemSelector,
                    titleSelector: titleSelector,
                    linkSelector: linkSelector,
                    dateSelector: dateSelector,
                    itemCount: items.length,
                    titleExample: titleExample,
                    linkExample: linkExample,
                    dateExample: dateExample
                };
                
            } catch (e) {
                console.error('检测新浪新闻结构时出错:', e);
                return null;
            }
        }
    </script>

    <!-- 添加页面函数 -->
    <script>
        /**
         * 设置选择器值
         * @param {string} selectorType - 选择器类型（item, title, link等）
         * @param {string} selectorValue - 选择器值
         */
        function setSelector(selectorType, selectorValue) {
            if (!selectorType || !selectorValue) return;
            
            // 查找对应的选择器输入框
            const inputId = `selector${selectorType.charAt(0).toUpperCase() + selectorType.slice(1)}`;
            const inputElement = document.getElementById(inputId);
            
            if (inputElement) {
                inputElement.value = selectorValue;
                inputElement.classList.add('is-valid');
                
                // 提示用户已设置选择器
            const toast = new bootstrap.Toast(document.getElementById('notificationToast'));
                document.getElementById('toastMessage').textContent = `已设置${selectorType}选择器: ${selectorValue}`;
            toast.show();
            
                // 关闭模态框
                if (bootstrap.Modal.getInstance(document.getElementById('resultModal'))) {
                    bootstrap.Modal.getInstance(document.getElementById('resultModal')).hide();
                }
            }
        }
    </script>
    
    <!-- 认证模态框 -->
    <div class="modal fade" id="authModal" tabindex="-1" aria-hidden="true">
        <div class="modal-dialog">
            <div class="modal-content">
                <div class="modal-header">
                    <h5 class="modal-title">认证</h5>
                    <button type="button" class="btn-close" data-bs-dismiss="modal" aria-label="Close"></button>
                </div>
                <div class="modal-body">
                    <div class="alert alert-info">
                        <p>您需要登录或提供API密钥才能执行此操作。</p>
                    </div>
                    
                    <ul class="nav nav-tabs" id="authTabs">
                        <li class="nav-item">
                            <a class="nav-link active" data-bs-toggle="tab" href="#loginTab">登录</a>
                        </li>
                        <li class="nav-item">
                            <a class="nav-link" data-bs-toggle="tab" href="#apiKeyTab">API密钥</a>
                        </li>
                    </ul>
                    
                    <div class="tab-content mt-3">
                        <div class="tab-pane fade show active" id="loginTab">
                            <form id="loginForm">
                                <div class="mb-3">
                                    <label for="username" class="form-label">用户名</label>
                                    <input type="text" class="form-control" id="username" required>
                                </div>
                                <div class="mb-3">
                                    <label for="password" class="form-label">密码</label>
                                    <input type="password" class="form-control" id="password" required>
                                </div>
                                <div class="d-grid">
                                    <button type="submit" class="btn btn-primary">登录</button>
                                </div>
                            </form>
                        </div>
                        <div class="tab-pane fade" id="apiKeyTab">
                            <form id="apiKeyForm">
                                <div class="mb-3">
                                    <label for="apiKey" class="form-label">API密钥</label>
                                    <input type="text" class="form-control" id="apiKey" required>
                                </div>
                                <div class="d-grid">
                                    <button type="submit" class="btn btn-primary">保存</button>
                                </div>
                            </form>
                        </div>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <!-- 添加通知Toast -->
    <div id="notificationToast" class="toast" role="alert" aria-live="assertive" aria-atomic="true">
        <div class="toast-header">
            <strong class="me-auto">通知</strong>
            <button type="button" class="btn-close" data-bs-dismiss="toast" aria-label="Close"></button>
        </div>
        <div class="toast-body" id="toastMessage">
            
        </div>
    </div>
    
    <!-- API健康检查模态框 -->
    <div class="modal fade" id="apiHealthModal" tabindex="-1" aria-hidden="true">
        <div class="modal-dialog modal-lg">
            <div class="modal-content">
                <div class="modal-header">
                    <h5 class="modal-title">API健康检查</h5>
                    <button type="button" class="btn-close" data-bs-dismiss="modal" aria-label="Close" onclick="clearModalBackdrops()"></button>
                </div>
                <div class="modal-body">
                    <div id="apiHealthStatus" class="mb-3"></div>
                    <div class="table-responsive">
                        <table class="table table-bordered">
                            <thead>
                                <tbody id="apiHealthTable">
                                    <tr>
                                        <th>端点名称</th>
                                        <th>URL</th>
                                        <th>状态</th>
                                        <th>响应时间</th>
                                        <th>操作</th>
                                    </tr>
                                </tbody>
                            </thead>
                        </table>
                    </div>
                    <div id="apiCheckDetails" class="mt-3"></div>
                </div>
                <div class="modal-footer">
                    <button type="button" class="btn btn-secondary" data-bs-dismiss="modal" onclick="clearModalBackdrops()">关闭</button>
                    <button type="button" class="btn btn-primary" onclick="checkApiHealth()">重新检查</button>
                </div>
            </div>
        </div>
    </div>

    <!-- 测试结果模态框 -->
    <div class="modal fade" id="testResultModal" tabindex="-1" aria-hidden="true">
        <div class="modal-dialog modal-lg">
            <div class="modal-content">
                <div class="modal-header">
                    <h5 class="modal-title">选择器测试结果</h5>
                    <button type="button" class="btn-close" data-bs-dismiss="modal" aria-label="Close"></button>
                </div>
                <div class="modal-body" id="testResultModalBody">
                    <!-- 测试结果将动态插入此处 -->
                </div>
                <div class="modal-footer">
                    <button type="button" class="btn btn-secondary" data-bs-dismiss="modal">关闭</button>
                </div>
            </div>
        </div>
    </div>
</body>
</html> 