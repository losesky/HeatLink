<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>HeatLink 新闻源管理器</title>
    <!-- Bootstrap CSS -->
    <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.1.3/dist/css/bootstrap.min.css" rel="stylesheet">
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap-icons@1.8.1/font/bootstrap-icons.css">
    <!-- CodeMirror CSS -->
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/codemirror/5.65.2/codemirror.min.css">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/codemirror/5.65.2/theme/monokai.min.css">
    <style>
        body {
            font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, "Helvetica Neue", Arial, sans-serif;
            background-color: #f8f9fa;
            padding-bottom: 50px;
        }
        .navbar {
            margin-bottom: 20px;
        }
        .card {
            margin-bottom: 20px;
            box-shadow: 0 0.125rem 0.25rem rgba(0, 0, 0, 0.075);
        }
        .loading {
            display: inline-block;
            width: 25px;
            height: 25px;
            border: 3px solid rgba(0, 0, 0, 0.1);
            border-radius: 50%;
            border-top-color: #0d6efd;
            animation: spin 1s ease-in-out infinite;
        }
        @keyframes spin {
            to { transform: rotate(360deg); }
        }
        .CodeMirror {
            height: 350px !important;
            border: 1px solid #ced4da;
            border-radius: 0.25rem;
            font-size: 14px;
            line-height: 1.5;
            min-height: 200px;
            z-index: 0; /* 防止与其他UI元素发生冲突 */
        }
        .cm-s-monokai .CodeMirror-gutters {
            background-color: #272822;
        }
        #htmlEditor {
            margin-bottom: 10px;
        }
        #globalLoader {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(255, 255, 255, 0.8);
            display: none;
            justify-content: center;
            align-items: center;
            flex-direction: column;
            z-index: 1051;
        }
        .source-list-item {
            cursor: pointer;
            transition: background-color 0.2s;
        }
        .source-list-item:hover {
            background-color: #f8f9fa;
        }
        .source-list-item.active {
            background-color: #e9ecef;
        }
        .nav-tabs {
            margin-bottom: 15px;
        }
        .alert {
            margin-bottom: 10px;
        }
        /* HTML Visualization Styles */
        .html-visualization-container {
            font-family: monospace;
            overflow-x: auto;
            background-color: #f8f9fa;
            border-radius: 0;
            padding: 0;
        }
        #htmlVisualization {
            white-space: pre-wrap;
            font-size: 14px;
            line-height: 1.5;
        }
        .tag-name {
            color: #0000ff;
            font-weight: bold;
        }
        .attribute-name {
            color: #008000;
        }
        .attribute-value {
            color: #dd0000;
        }
        .html-comment {
            color: #808080;
            font-style: italic;
        }
        .text-content {
            color: #000000;
        }
        .nested-level {
            border-left: 1px dotted #ccc;
            margin-left: 20px;
            padding-left: 5px;
        }
        .hover-highlight:hover {
            background-color: rgba(0, 123, 255, 0.1);
        }
        /* 调整HTML边距 */
        .CodeMirror-lines {
            padding: 10px 0;
        }
        /* 使HTML编辑器在小屏幕上也能正确显示 */
        @media (max-width: 768px) {
            .CodeMirror {
                height: 250px !important;
            }
        }
    </style>
</head>
<body>
    <!-- Global Loader -->
    <div id="globalLoader">
        <div class="loading"></div>
        <p class="mt-3" id="loaderMessage">加载中...</p>
    </div>

    <!-- Navigation -->
    <nav class="navbar navbar-expand-lg navbar-dark bg-primary">
        <div class="container">
            <a class="navbar-brand" href="#">HeatLink 新闻源管理器</a>
            <button class="navbar-toggler" type="button" data-bs-toggle="collapse" data-bs-target="#navbarNav">
                <span class="navbar-toggler-icon"></span>
            </button>
            <div class="collapse navbar-collapse" id="navbarNav">
                <ul class="navbar-nav ms-auto">
                    <li class="nav-item">
                        <a class="nav-link active" id="navCreate" href="#">创建源</a>
                    </li>
                    <li class="nav-item">
                        <a class="nav-link" id="navManage" href="#">管理源</a>
                    </li>
                </ul>
            </div>
        </div>
    </nav>

    <div class="container mt-4">
        <!-- Main content area -->
        <div id="createSourceSection">
            <h2 class="mb-3">创建新闻源适配器</h2>
            <div class="alert alert-info">
                <p><strong>提示：</strong>这个工具将基于提供的URL和代码样本生成自定义新闻源适配器。</p>
            </div>
            
            <!-- Create Source Form -->
            <div class="card">
                <div class="card-body">
                    <form id="createSourceForm">
                        <div class="row mb-3">
                            <div class="col-md-6">
                                <label for="sourceId" class="form-label">源ID <span class="text-danger">*</span></label>
                                <input type="text" class="form-control" id="sourceId" required 
                                       placeholder="例如：news-website">
                                <div class="form-text">此源的唯一标识符，使用小写字母和连字符。会自动添加"custom-"前缀</div>
                            </div>
                            <div class="col-md-6">
                                <label for="sourceName" class="form-label">源名称 <span class="text-danger">*</span></label>
                                <input type="text" class="form-control" id="sourceName" required 
                                       placeholder="例如：自定义新闻门户">
                                <div class="form-text">此源的显示名称</div>
                            </div>
                        </div>
                        
                        <div class="row mb-3">
                            <div class="col-md-6">
                                <label for="sourceUrl" class="form-label">源URL <span class="text-danger">*</span></label>
                                <input type="url" class="form-control" id="sourceUrl" required 
                                       placeholder="https://example.com/news">
                                <div class="form-text">要抓取的新闻页面URL</div>
                            </div>
                            <div class="col-md-6">
                                <label for="sourceCategory" class="form-label">类别</label>
                                <select class="form-select" id="sourceCategory">
                                    <option value="news">新闻</option>
                                    <option value="technology">科技</option>
                                    <option value="finance">财经</option>
                                    <option value="sports">体育</option>
                                    <option value="entertainment">娱乐</option>
                                    <option value="science">科学</option>
                                    <option value="health">健康</option>
                                    <option value="politics">政治</option>
                                    <option value="business">商业</option>
                                    <option value="other">其他</option>
                                </select>
                                <div class="form-text">新闻源的类别</div>
                            </div>
                        </div>
                        
                        <div class="row mb-3">
                            <div class="col-md-6">
                                <label for="sourceCountry" class="form-label">国家</label>
                                <input type="text" class="form-control" id="sourceCountry" 
                                       placeholder="例如：US, CN, JP" value="CN">
                                <div class="form-text">国家代码 (ISO 3166-1 alpha-2)</div>
                            </div>
                            <div class="col-md-6">
                                <label for="sourceLanguage" class="form-label">语言</label>
                                <input type="text" class="form-control" id="sourceLanguage" 
                                       placeholder="例如：en, zh-CN, ja" value="zh-CN">
                                <div class="form-text">语言代码 (ISO 639-1)</div>
                            </div>
                        </div>
                        
                        <div class="row mb-3">
                            <div class="col-md-6">
                                <label for="updateInterval" class="form-label">更新间隔 (秒)</label>
                                <input type="number" class="form-control" id="updateInterval" 
                                       value="1800" min="300" max="86400">
                                <div class="form-text">多久获取一次新数据 (最小: 5分钟)</div>
                            </div>
                            <div class="col-md-6">
                                <label for="cacheTtl" class="form-label">缓存TTL (秒)</label>
                                <input type="number" class="form-control" id="cacheTtl" 
                                       value="900" min="60" max="43200">
                                <div class="form-text">数据缓存多长时间 (最小: 1分钟)</div>
                            </div>
                        </div>
                        
                        <div class="mb-3">
                            <label for="htmlExample" class="form-label">HTML示例 <span class="text-danger">*</span></label>
                            <div id="htmlEditor" class="html-editor-container"></div>
                            <div class="form-text">粘贴包含新闻条目的新闻页面HTML示例</div>
                            <div class="mt-2">
                                <button type="button" id="analyzeHtmlBtn" class="btn btn-info">
                                    <i class="bi bi-magic"></i> 分析HTML结构并推荐选择器
                                </button>
                            </div>
                        </div>
                        
                        <div class="row mb-3">
                            <div class="col-md-6">
                                <label for="itemSelector" class="form-label">条目选择器 <span class="text-danger">*</span></label>
                                <input type="text" class="form-control" id="itemSelector" required 
                                       placeholder="例如：div.news-item, article.post">
                                <div class="form-text">用于在HTML中找到新闻条目的CSS选择器</div>
                            </div>
                            <div class="col-md-6">
                                <label for="titleSelector" class="form-label">标题选择器 <span class="text-danger">*</span></label>
                                <input type="text" class="form-control" id="titleSelector" required 
                                       placeholder="例如：h3.title, .headline">
                                <div class="form-text">用于在每个条目中找到标题的CSS选择器</div>
                            </div>
                        </div>
                        
                        <div class="row mb-3">
                            <div class="col-md-6">
                                <label for="linkSelector" class="form-label">链接选择器</label>
                                <input type="text" class="form-control" id="linkSelector" 
                                       placeholder="例如：a, .link">
                                <div class="form-text">用于在每个条目中找到链接的CSS选择器</div>
                            </div>
                            <div class="col-md-6">
                                <label for="dateSelector" class="form-label">日期选择器</label>
                                <input type="text" class="form-control" id="dateSelector" 
                                       placeholder="例如：.date, time">
                                <div class="form-text">用于在每个条目中找到日期的CSS选择器</div>
                            </div>
                        </div>
                        
                        <div class="row mb-3">
                            <div class="col-md-6">
                                <label for="summarySelector" class="form-label">摘要选择器</label>
                                <input type="text" class="form-control" id="summarySelector" 
                                       placeholder="例如：.summary, p.excerpt">
                                <div class="form-text">用于在每个条目中找到摘要的CSS选择器</div>
                            </div>
                            <div class="col-md-6">
                                <label for="contentSelector" class="form-label">内容选择器</label>
                                <input type="text" class="form-control" id="contentSelector" 
                                       placeholder="例如：.content, .article-body">
                                <div class="form-text">用于在每个条目中找到完整内容的CSS选择器（如果有）</div>
                            </div>
                        </div>
                        
                        <div class="mb-3 form-check">
                            <input type="checkbox" class="form-check-input" id="useSelenium">
                            <label class="form-check-label" for="useSelenium">使用Selenium处理JavaScript页面</label>
                            <div class="form-text">如果页面需要JavaScript才能加载内容，请启用此选项</div>
                        </div>
                        
                        <!-- 代理设置选项 -->
                        <div class="mb-3 form-check">
                            <input type="checkbox" class="form-check-input" id="needProxy">
                            <label class="form-check-label" for="needProxy">使用代理访问</label>
                            <div class="form-text">如果目标网站需要通过代理访问，请启用此选项</div>
                        </div>
                        
                        <!-- 隐藏字段 - 不显示但会保存默认值 -->
                        <input type="hidden" id="containerSelector">
                        <input type="hidden" id="proxyFallback" value="true">
                        <input type="hidden" id="proxyGroup" value="default">
                        
                        <div class="mb-3 form-check">
                            <input type="checkbox" class="form-check-input" id="autoRegister" checked>
                            <label class="form-check-label" for="autoRegister">自动注册源</label>
                            <div class="form-text">在数据库中注册此源并使其可用</div>
                        </div>
                        
                        <div class="row">
                            <div class="col-md-6">
                                <button type="button" id="previewSourceBtn" class="btn btn-secondary w-100">预览源代码</button>
                            </div>
                            <div class="col-md-6">
                                <button type="submit" id="createSourceBtn" class="btn btn-primary w-100">创建源适配器</button>
                            </div>
                        </div>
                    </form>
                </div>
            </div>
            
            <!-- Preview Modal -->
            <div class="modal fade" id="previewModal" tabindex="-1" aria-hidden="true">
                <div class="modal-dialog modal-xl">
                    <div class="modal-content">
                        <div class="modal-header">
                            <h5 class="modal-title">源适配器预览</h5>
                            <button type="button" class="btn-close" data-bs-dismiss="modal" aria-label="Close" onclick="clearModalBackdrops()"></button>
                        </div>
                        <div class="modal-body">
                            <div id="previewEditor"></div>
                        </div>
                        <div class="modal-footer">
                            <button type="button" class="btn btn-secondary" data-bs-dismiss="modal" onclick="clearModalBackdrops()">关闭</button>
                            <button type="button" class="btn btn-primary" id="copyPreviewBtn">复制代码</button>
                        </div>
                    </div>
                </div>
            </div>
            
            <!-- Result Modal -->
            <div class="modal fade" id="resultModal" tabindex="-1" aria-hidden="true">
                <div class="modal-dialog">
                    <div class="modal-content">
                        <div class="modal-header">
                            <h5 class="modal-title" id="resultModalTitle">源已创建</h5>
                            <button type="button" class="btn-close" data-bs-dismiss="modal" aria-label="Close" onclick="clearModalBackdrops()"></button>
                        </div>
                        <div class="modal-body" id="resultModalBody">
                        </div>
                        <div class="modal-footer">
                            <button type="button" class="btn btn-secondary" data-bs-dismiss="modal" onclick="clearModalBackdrops()">关闭</button>
                            <button type="button" class="btn btn-primary" id="testNewSourceBtn">测试源</button>
                        </div>
                    </div>
                </div>
            </div>
        </div>

        <div id="manageSourcesSection" style="display: none;">
            <h2 class="mb-3">管理新闻源</h2>
            
            <!-- Source Management Content -->
            <div class="row">
                <div class="col-md-4">
                    <div class="card mb-4">
                        <div class="card-header d-flex justify-content-between align-items-center">
                            <h5 class="mb-0">源列表</h5>
                            <button class="btn btn-sm btn-outline-primary" id="refreshSourcesBtn">
                                <i class="bi bi-arrow-clockwise"></i>
                            </button>
                        </div>
                        <div class="card-body">
                            <div class="mb-3">
                                <input type="text" class="form-control" id="sourceSearchInput" placeholder="搜索源...">
                            </div>
                            <div class="list-group" id="sourceListContainer">
                                <div class="text-center py-3">
                                    <div class="loading"></div>
                                    <p class="mt-2">加载源中...</p>
                                </div>
                            </div>
                        </div>
                    </div>
                    
                    <div class="card">
                        <div class="card-header">
                            <h5 class="mb-0">操作</h5>
                        </div>
                        <div class="card-body">
                            <div class="d-grid gap-2">
                                <button class="btn btn-outline-primary" id="testSelectedSourceBtn" disabled>
                                    <i class="bi bi-play-fill"></i> 测试源
                                </button>
                                <button class="btn btn-outline-success" id="activateSourceBtn" disabled>
                                    <i class="bi bi-check-circle"></i> 激活
                                </button>
                                <button class="btn btn-outline-warning" id="deactivateSourceBtn" disabled>
                                    <i class="bi bi-pause-circle"></i> 停用
                                </button>
                                <button class="btn btn-outline-danger" id="deleteSourceBtn" disabled>
                                    <i class="bi bi-trash"></i> 删除
                                </button>
                            </div>
                        </div>
                    </div>
                </div>
                
                <div class="col-md-8">
                    <div class="card">
                        <div class="card-header">
                            <ul class="nav nav-tabs card-header-tabs" id="sourceDetailTabs">
                                <li class="nav-item">
                                    <a class="nav-link active" id="detailsTab" data-bs-toggle="tab" href="#details">详情</a>
                                </li>
                                <li class="nav-item">
                                    <a class="nav-link" id="configTab" data-bs-toggle="tab" href="#config">配置</a>
                                </li>
                                <li class="nav-item">
                                    <a class="nav-link" id="testResultTab" data-bs-toggle="tab" href="#testResult">测试结果</a>
                                </li>
                            </ul>
                        </div>
                        <div class="card-body">
                            <div class="tab-content">
                                <div class="tab-pane fade show active" id="details">
                                    <div id="sourceDetailsContainer">
                                        <div class="alert alert-info">
                                            <p>从列表中选择一个源以查看其详情。</p>
                                        </div>
                                    </div>
                                </div>
                                <div class="tab-pane fade" id="stats">
                                    <div id="sourceStatsContainer">
                                        <div class="alert alert-info">
                                            <p>从列表中选择一个源以查看其统计信息。</p>
                                        </div>
                                    </div>
                                </div>
                                <div class="tab-pane fade" id="config">
                                    <div id="sourceConfigContainer">
                                        <div class="alert alert-info">
                                            <p>从列表中选择一个源以查看和编辑其配置。</p>
                                        </div>
                                    </div>
                                </div>
                                <div class="tab-pane fade" id="testResult">
                                    <div id="sourceTestResultContainer">
                                        <div class="alert alert-info">
                                            <p>点击"测试源"来运行测试并查看结果。</p>
                                        </div>
                                    </div>
                                </div>
                            </div>
                        </div>
                    </div>
                </div>
            </div>
            
            <!-- Edit Source Modal -->
            <div class="modal fade" id="editSourceModal" tabindex="-1" aria-hidden="true">
                <div class="modal-dialog modal-lg">
                    <div class="modal-content">
                        <div class="modal-header">
                            <h5 class="modal-title">编辑源</h5>
                            <button type="button" class="btn-close" data-bs-dismiss="modal" aria-label="Close" onclick="clearModalBackdrops()"></button>
                        </div>
                        <div class="modal-body">
                            <form id="editSourceForm">
                                <input type="hidden" id="editSourceId">
                                
                                <div class="mb-3">
                                    <label for="editSourceName" class="form-label">源名称</label>
                                    <input type="text" class="form-control" id="editSourceName" required>
                                </div>
                                
                                <div class="mb-3">
                                    <label for="editSourceDescription" class="form-label">描述</label>
                                    <textarea class="form-control" id="editSourceDescription" rows="2"></textarea>
                                </div>
                                
                                <div class="mb-3">
                                    <label for="editSourceUrl" class="form-label">源URL</label>
                                    <input type="url" class="form-control" id="editSourceUrl">
                                </div>
                                
                                <div class="row mb-3">
                                    <div class="col-md-6">
                                        <label for="editSourceCategory" class="form-label">类别</label>
                                        <select class="form-select" id="editSourceCategory">
                                            <option value="">-- 加载类别中 --</option>
                                        </select>
                                    </div>
                                    <div class="col-md-6">
                                        <label for="editSourceStatus" class="form-label">状态</label>
                                        <select class="form-select" id="editSourceStatus">
                                            <option value="active">激活</option>
                                            <option value="inactive">未激活</option>
                                            <option value="error">错误</option>
                                            <option value="warning">警告</option>
                                        </select>
                                    </div>
                                </div>
                                
                                <div class="row mb-3">
                                    <div class="col-md-6">
                                        <label for="editUpdateInterval" class="form-label">更新间隔 (秒)</label>
                                        <input type="number" class="form-control" id="editUpdateInterval" min="300" max="86400">
                                    </div>
                                    <div class="col-md-6">
                                        <label for="editCacheTtl" class="form-label">缓存TTL (秒)</label>
                                        <input type="number" class="form-control" id="editCacheTtl" min="60" max="43200">
                                    </div>
                                </div>
                                
                                <div class="mb-3">
                                    <label for="editSourceConfig" class="form-label">源配置 (JSON)</label>
                                    <div id="configEditor"></div>
                                </div>
                            </form>
                        </div>
                        <div class="modal-footer">
                            <button type="button" class="btn btn-secondary" data-bs-dismiss="modal" onclick="clearModalBackdrops()">取消</button>
                            <button type="button" class="btn btn-primary" id="saveSourceBtn">保存更改</button>
                        </div>
                    </div>
                </div>
            </div>
            
            <!-- Delete Confirmation Modal -->
            <div class="modal fade" id="deleteConfirmModal" tabindex="-1" aria-hidden="true">
                <div class="modal-dialog">
                    <div class="modal-content">
                        <div class="modal-header">
                            <h5 class="modal-title">确认删除</h5>
                            <button type="button" class="btn-close" data-bs-dismiss="modal" aria-label="Close" onclick="clearModalBackdrops()"></button>
                        </div>
                        <div class="modal-body">
                            <p>您确定要删除源 <strong id="deleteSourceName"></strong> 吗？</p>
                            <p class="text-danger">此操作无法撤消。</p>
                        </div>
                        <div class="modal-footer">
                            <button type="button" class="btn btn-secondary" data-bs-dismiss="modal" onclick="clearModalBackdrops()">取消</button>
                            <button type="button" class="btn btn-danger" id="confirmDeleteBtn">删除</button>
                        </div>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <!-- HTML Display Modal -->
    <div class="modal fade" id="htmlDisplayModal" tabindex="-1" aria-hidden="true">
        <div class="modal-dialog modal-xl modal-dialog-scrollable">
            <div class="modal-content">
                <div class="modal-header">
                    <h5 class="modal-title">HTML结构可视化</h5>
                    <button type="button" class="btn-close" data-bs-dismiss="modal" aria-label="Close" onclick="clearModalBackdrops()"></button>
                </div>
                <div class="modal-body p-0">
                    <div class="html-visualization-container">
                        <div id="htmlVisualization" class="p-3"></div>
                    </div>
                </div>
                <div class="modal-footer">
                    <button type="button" class="btn btn-secondary" data-bs-dismiss="modal" onclick="clearModalBackdrops()">关闭</button>
                    <button type="button" class="btn btn-primary" id="copyVisualizedHtmlBtn">复制格式化HTML</button>
                </div>
            </div>
        </div>
    </div>

    <!-- Bootstrap JS Bundle with Popper -->
    <script src="https://cdn.jsdelivr.net/npm/bootstrap@5.1.3/dist/js/bootstrap.bundle.min.js"></script>
    
    <!-- 添加clearModalBackdrops函数 -->
    <script>
        /**
         * 清除所有模态框背景并重置body样式
         * 在模态框关闭按钮点击后执行以解决Bootstrap模态框可能遗留的背景层问题
         */
        function clearModalBackdrops() {
            // 使用setTimeout确保在模态框开始关闭后执行清理
            setTimeout(function() {
                // 移除所有模态背景
                document.querySelectorAll('.modal-backdrop').forEach(function(backdrop) {
                    backdrop.remove();
                });
                
                // 重置body样式和类
                document.body.style.overflow = '';
                document.body.style.paddingRight = '';
                document.body.classList.remove('modal-open');
                console.log('已清除模态框背景和重置body样式');
            }, 150); // 延迟150毫秒执行，确保在模态关闭动画开始后
        }
    </script>
    
    <!-- CodeMirror JS -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/codemirror/5.65.2/codemirror.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/codemirror/5.65.2/mode/htmlmixed/htmlmixed.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/codemirror/5.65.2/mode/javascript/javascript.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/codemirror/5.65.2/mode/python/python.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/codemirror/5.65.2/mode/xml/xml.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/codemirror/5.65.2/mode/css/css.min.js"></script>
    <!-- 添加CodeMirror额外插件 -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/codemirror/5.65.2/addon/edit/closetag.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/codemirror/5.65.2/addon/edit/closebrackets.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/codemirror/5.65.2/addon/hint/show-hint.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/codemirror/5.65.2/addon/hint/html-hint.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/codemirror/5.65.2/addon/fold/xml-fold.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/codemirror/5.65.2/addon/selection/active-line.min.js"></script>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/codemirror/5.65.2/addon/hint/show-hint.min.css">

    <!-- Main Script -->
    <script>
        // Global variables
        const API_BASE_URL = '/api';
        let htmlEditor;
        let previewEditor;
        let configEditor;
        let selectedSource = null;
        // 调试模式开关，设置为true时会显示更多的调试信息
        const DEBUG_MODE = true;
        
        // 全局错误处理
        window.onerror = function(message, source, lineno, colno, error) {
            console.error(`JavaScript错误: ${message} (${source}:${lineno}:${colno})`, error);
            if (DEBUG_MODE) {
                showToast('JavaScript错误', `${message} (行${lineno})`, 'danger');
            }
            return false; // 允许默认错误处理继续
        };
        
        // 添加未捕获的Promise拒绝处理
        window.addEventListener('unhandledrejection', function(event) {
            console.error('未处理的Promise拒绝:', event.reason);
            if (DEBUG_MODE) {
                showToast('Promise错误', `${event.reason}`, 'danger');
            }
        });
        
        // 调试日志函数
        function debugLog(...args) {
            if (DEBUG_MODE) {
                console.log('[DEBUG]', ...args);
            }
        }
        
        // Basic navigation functionality
        document.addEventListener('DOMContentLoaded', function() {
            const navCreate = document.getElementById('navCreate');
            const navManage = document.getElementById('navManage');
            const createSection = document.getElementById('createSourceSection');
            const manageSection = document.getElementById('manageSourcesSection');
            
            // Initialize editors
            htmlEditor = CodeMirror(document.getElementById('htmlEditor'), {
                mode: 'htmlmixed',
                theme: 'monokai',
                lineNumbers: true,
                lineWrapping: true,
                autoCloseTags: true,
                autoCloseBrackets: true,
                matchBrackets: true,
                styleActiveLine: true,
                viewportMargin: Infinity,
                tabSize: 2,
                indentWithTabs: false,
                inputStyle: 'contenteditable', // 使用contenteditable模式以提高粘贴性能
                value: ''  // 初始值为空字符串
            });
            
            // 添加HTML编辑器变化监听
            htmlEditor.on('change', function() {
                // 如果HTML内容变化且长度超过一定阈值，启用分析按钮
                const htmlContent = htmlEditor.getValue();
                const contentLength = htmlContent.length;
                document.getElementById('analyzeHtmlBtn').disabled = contentLength < 100;
            });
            
            // 添加一个API健康检查按钮
            const headerNav = document.querySelector('.navbar-nav');
            if (headerNav) {
                const apiCheckLi = document.createElement('li');
                apiCheckLi.className = 'nav-item';
                apiCheckLi.innerHTML = `
                    <a class="nav-link" href="#" id="apiHealthCheck">
                        <i class="bi bi-activity"></i> API检查
                    </a>
                `;
                headerNav.appendChild(apiCheckLi);
                
                document.getElementById('apiHealthCheck').addEventListener('click', function(e) {
                    e.preventDefault();
                    checkApiHealth();
                });
            }
            
            // 添加分析HTML按钮事件
            document.getElementById('analyzeHtmlBtn').addEventListener('click', analyzeHtml);
            
            // 添加复制可视化HTML按钮事件
            document.getElementById('copyVisualizedHtmlBtn').addEventListener('click', function() {
                const htmlContent = htmlEditor.getValue();
                
                // 复制到剪贴板
                navigator.clipboard.writeText(htmlContent).then(function() {
                    showToast('成功', '已复制格式化后的HTML到剪贴板', 'success');
                }).catch(function(err) {
                    console.error('无法复制文本: ', err);
                    showToast('错误', '复制到剪贴板失败，请手动复制', 'danger');
                });
            });
            
            previewEditor = CodeMirror(document.getElementById('previewEditor'), {
                mode: 'python',
                theme: 'monokai',
                lineNumbers: true,
                readOnly: true
            });
            
            configEditor = CodeMirror(document.getElementById('configEditor'), {
                mode: { name: 'javascript', json: true },
                theme: 'monokai',
                lineNumbers: true
            });
            
            // Navigation
            navCreate.addEventListener('click', (e) => {
                e.preventDefault();
                createSection.style.display = 'block';
                manageSection.style.display = 'none';
                navCreate.classList.add('active');
                navManage.classList.remove('active');
            });
            
            navManage.addEventListener('click', (e) => {
                e.preventDefault();
                createSection.style.display = 'none';
                manageSection.style.display = 'block';
                navCreate.classList.remove('active');
                navManage.classList.add('active');
                
                // Load sources
                loadSources();
            });
            
            // Set up form handlers
            document.getElementById('previewSourceBtn').addEventListener('click', function() {
                const sourceCode = generateSourceCode();
                previewEditor.setValue(sourceCode);
                new bootstrap.Modal(document.getElementById('previewModal')).show();
            });
            
            document.getElementById('createSourceForm').addEventListener('submit', function(e) {
                e.preventDefault();
                createSource();
            });
            
            // Set up action buttons in management section
            document.getElementById('refreshSourcesBtn').addEventListener('click', loadSources);
            
            document.getElementById('testSelectedSourceBtn').addEventListener('click', function() {
                if (selectedSource) {
                    testSource(selectedSource);
                    
                    // 切换到测试结果选项卡
                    const testResultTab = document.querySelector('#sourceDetailTabs a[href="#testResult"]');
                    const tabInstance = new bootstrap.Tab(testResultTab);
                    tabInstance.show();
                }
            });
            
            document.getElementById('activateSourceBtn').addEventListener('click', function() {
                if (selectedSource) {
                    showLoader(`激活源中: ${selectedSource}...`);
                    
                    fetch(`/api/sources/${selectedSource}`, {
                        method: 'PUT',
                        headers: {
                            'Content-Type': 'application/json'
                            // Removed auth headers:
                            // 'Authorization': 'Bearer ' + (localStorage.getItem('auth_token') || ''),
                            // 'X-API-Key': localStorage.getItem('api_key') || ''
                        },
                        body: JSON.stringify({
                            status: 'active'
                        }),
                        credentials: 'include' // 包含cookies，这对于会话认证很重要
                    })
                    .then(response => {
                        if (!response.ok) {
                            // 详细记录错误
                            console.error('激活源失败，状态码:', response.status, response.statusText);
                            return response.text().then(text => {
                                let errorDetail = '激活源失败';
                                try {
                                    const errorJson = JSON.parse(text);
                                    errorDetail = errorJson.detail || `API错误: ${response.status} ${response.statusText}`;
                                    console.error('API错误详情:', errorJson);
                                } catch (e) {
                                    // 如果不是JSON，直接使用文本
                                    errorDetail = `API错误: ${response.status} ${response.statusText}. ${text}`;
                                    console.error('API响应内容:', text);
                                }
                                throw new Error(errorDetail);
                            });
                        }
                        return response.json();
                    })
                    .then(result => {
                        hideLoader();
                        
                        // 显示成功提示
                        const toast = new bootstrap.Toast(document.getElementById('notificationToast'));
                        document.getElementById('toastMessage').textContent = `源 "${result.name}" 已成功激活！`;
                        toast.show();
                        
                        // 更新源列表以反映状态变化
                        loadSources();
                        
                        // Show success message
                        document.getElementById('resultModalTitle').textContent = '源已激活';
                        document.getElementById('resultModalBody').innerHTML = `
                            <div class="alert alert-success">
                                <p><strong>源 "${result.name}" 已成功激活！</strong></p>
                                <p>源现在处于活动状态，将用于新闻聚合。</p>
                            </div>
                            <p>您可以在"管理源"部分管理此源。</p>
                        `;
                        
                        // 显示模态框
                        new bootstrap.Modal(document.getElementById('resultModal')).show();
                    })
                    .catch(error => {
                        hideLoader();
                        
                        console.error('激活源时出错:', error);
                        
                        // 检查是否是认证错误
                        if (error.message.includes('Not authenticated') || 
                            error.message.includes('401') || 
                            error.message.includes('auth') || 
                            error.message.includes('认证')) {
                            
                            // 处理认证错误
                            handleAuthError(error, () => {
                                // 认证成功后重新尝试激活
                                activateSource(selectedSource);
                            });
                            return;
                        }
                        
                        // 使用Toast显示错误
                        const toast = new bootstrap.Toast(document.getElementById('notificationToast'));
                        document.getElementById('toastMessage').textContent = `激活源失败: ${error.message}`;
                        document.getElementById('notificationToast').classList.add('bg-danger', 'text-white');
                        toast.show();
                        
                        // 5秒后恢复原来的样式
                        setTimeout(() => {
                            document.getElementById('notificationToast').classList.remove('bg-danger', 'text-white');
                        }, 5000);
                        
                        // Show error message
                        document.getElementById('resultModalTitle').textContent = '错误';
                        document.getElementById('resultModalBody').innerHTML = `
                            <div class="alert alert-danger">
                                <p><strong>激活源失败</strong></p>
                                <p>${error.message}</p>
                            </div>
                        `;
                        
                        // 显示模态框
                        new bootstrap.Modal(document.getElementById('resultModal')).show();
                    });
                }
            });
            
            document.getElementById('deactivateSourceBtn').addEventListener('click', function() {
                if (selectedSource) {
                    showLoader(`停用源中: ${selectedSource}...`);
                    
                    fetch(`/api/sources/${selectedSource}`, {
                        method: 'PUT',
                        headers: {
                            'Content-Type': 'application/json'
                        },
                        body: JSON.stringify({
                            status: 'inactive'
                        })
                    })
                    .then(response => {
                        if (!response.ok) {
                            return response.json().then(err => {
                                throw new Error(err.detail || '停用源失败');
                            });
                        }
                        return response.json();
                    })
                    .then(result => {
                        hideLoader();
                        
                        // Reload sources
                        loadSources();
                        
                        // Reload source details
                        loadSourceDetails(selectedSource);
                        
                        // Show notification
                        alert(`源 "${result.name}" 已成功停用！`);
                    })
                    .catch(error => {
                        hideLoader();
                        
                        alert('停用源失败: ' + error.message);
                    });
                }
            });
            
            document.getElementById('deleteSourceBtn').addEventListener('click', function() {
                if (selectedSource) {
                    // Confirm deletion
                    fetch(`/api/sources/${selectedSource}`)
                    .then(response => response.json())
                    .then(source => {
                        document.getElementById('deleteSourceName').textContent = source.name;
                        new bootstrap.Modal(document.getElementById('deleteConfirmModal')).show();
                        
                        // Set up confirm button
                        document.getElementById('confirmDeleteBtn').onclick = function() {
                            deleteSource(selectedSource);
                            bootstrap.Modal.getInstance(document.getElementById('deleteConfirmModal')).hide();
                        };
                    })
                    .catch(error => {
                        console.error('Error loading source details:', error);
                        alert('Failed to load source details: ' + error.message);
                    });
                }
            });
            
        });
        
        // Helper functions
        function showLoader(message = 'Loading...') {
            document.getElementById('loaderMessage').textContent = message;
            document.getElementById('globalLoader').style.display = 'flex';
        }
        
        function hideLoader() {
            document.getElementById('globalLoader').style.display = 'none';
            
            // 也清除其他可能的遮罩层
            document.querySelectorAll('.loading-overlay, .overlay').forEach(overlay => {
                overlay.style.display = 'none';
            });
            
            // 确保body样式正常
            document.body.style.overflow = '';
            document.body.style.position = '';
        }
        
        function getFormData() {
            return {
                id: document.getElementById('sourceId').value,
                name: document.getElementById('sourceName').value,
                url: document.getElementById('sourceUrl').value,
                category: document.getElementById('sourceCategory').value,
                country: document.getElementById('sourceCountry').value,
                language: document.getElementById('sourceLanguage').value,
                update_interval: parseInt(document.getElementById('updateInterval').value),
                cache_ttl: parseInt(document.getElementById('cacheTtl').value),
                use_selenium: document.getElementById('useSelenium').checked,
                need_proxy: document.getElementById('needProxy').checked,
                proxy_fallback: document.getElementById('proxyFallback').checked,
                proxy_group: document.getElementById('proxyGroup').value,
                selectors: {
                    item: document.getElementById('itemSelector').value,
                    title: document.getElementById('titleSelector').value,
                    link: document.getElementById('linkSelector').value || '',
                    date: document.getElementById('dateSelector').value || '',
                    summary: document.getElementById('summarySelector').value || '',
                    content: document.getElementById('contentSelector').value || ''
                },
                html_example: htmlEditor.getValue()
            };
        }
        
        function generateSourceCode() {
            const data = getFormData();
            
            // Generate simple Python source code preview
            return `# Auto-generated source adapter for ${data.name}
import logging
from bs4 import BeautifulSoup
from worker.sources.web import WebNewsSource
from worker.sources.base import NewsItemModel

logger = logging.getLogger(__name__)

class ${data.id.split('-').map(word => word.charAt(0).toUpperCase() + word.slice(1)).join('')}Source(WebNewsSource):
    """
    ${data.name} adapter
    Fetches news from ${data.url}
    """
    
    def __init__(self, source_id="${data.id}", name="${data.name}", url="${data.url}"):
        super().__init__(
            source_id=source_id,
            name=name,
            url=url,
            update_interval=${data.update_interval},
            cache_ttl=${data.cache_ttl},
            category="${data.category}",
            country="${data.country}",
            language="${data.language}"${data.need_proxy ? `,
            # 代理设置
            config={
                "need_proxy": True,
                "proxy_fallback": ${data.proxy_fallback},
                "proxy_group": "${data.proxy_group}"
            }` : ''}
        )
    
    async def parse_response(self, html):
        # Parse HTML using selectors:
        # Item: ${data.selectors.item}
        # Title: ${data.selectors.title}
        # Link: ${data.selectors.link} 
        # Date: ${data.selectors.date}
        # Summary: ${data.selectors.summary}
        # Content: ${data.selectors.content}${data.need_proxy ? `
        # Using proxy: Yes (Group: ${data.proxy_group}, Fallback: ${data.proxy_fallback})` : ''}${data.use_selenium ? `
        # Using Selenium for JavaScript rendering` : ''}
        pass
`;
        }
        
        function createSource() {
            showLoader('创建源中...');
            
            const data = getFormData();
            
            // 自动为源ID添加custom-前缀，如果尚未添加
            if (!data.id.startsWith('custom-')) {
                data.id = 'custom-' + data.id;
                debugLog('已自动为源ID添加custom-前缀:', data.id);
            }
            
            // Call the API to create the source
            fetch('/api/source-test/create-custom-source', {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json'
                },
                body: JSON.stringify(data)
            })
            .then(response => {
                if (!response.ok) {
                    return response.json().then(err => {
                        throw new Error(err.detail || '创建源失败');
                    });
                }
                return response.json();
            })
            .then(result => {
                hideLoader();
                
                // Show success message
                document.getElementById('resultModalTitle').textContent = '源已创建';
                document.getElementById('resultModalBody').innerHTML = `
                    <div class="alert alert-success">
                        <p><strong>源 "${result.source.name}" 创建成功！</strong></p>
                        <p><strong>ID:</strong> <span class="badge bg-primary">${result.source.id}</span></p>
                        <p><strong>状态:</strong> <span class="badge ${result.source.status === 'active' ? 'bg-success' : 'bg-secondary'}">${result.source.status}</span></p>
                    </div>
                    <div class="alert alert-info">
                        <p><i class="bi bi-info-circle"></i> 点击"测试源"来测试这个新建的源适配器。</p>
                        <p><small>源ID: ${result.source.id} 将被用于测试</small></p>
                    </div>
                `;
                
                new bootstrap.Modal(document.getElementById('resultModal')).show();
            })
            .catch(error => {
                hideLoader();
                
                // Show error message
                document.getElementById('resultModalTitle').textContent = '错误';
                document.getElementById('resultModalBody').innerHTML = `
                    <div class="alert alert-danger">
                        <p><strong>创建源失败</strong></p>
                        <p>${error.message}</p>
                    </div>
                `;
                
                new bootstrap.Modal(document.getElementById('resultModal')).show();
            });
        }
        
        // Add new function to test a source
        document.getElementById('testNewSourceBtn').addEventListener('click', function() {
            const sourceId = document.getElementById('sourceId').value;
            
            if (!sourceId) {
                alert('请先输入有效的源ID');
                return;
            }
            
            // 自动为源ID添加custom-前缀，如果尚未添加
            let testId = sourceId;
            if (!testId.startsWith('custom-')) {
                testId = 'custom-' + testId;
            }
            
            debugLog('testNewSourceBtn click, sourceId:', testId);
            
            // 显示提示信息，告知用户测试结果将会显示在哪里
            const toast = new bootstrap.Toast(document.getElementById('notificationToast'));
            document.getElementById('toastMessage').textContent = `正在测试源 ${testId}，结果将显示在"测试结果"标签页中`;
            toast.show();
            
            // 切换到测试结果标签页
            if (document.getElementById('testResultTab')) {
                const tab = new bootstrap.Tab(document.getElementById('testResultTab'));
                tab.show();
            }
            
            // 开始测试
            testSource(testId);
        });
        
        function testSource(sourceId) {
            // 验证sourceId不为空
            if (!sourceId || sourceId.trim() === '') {
                alert('错误：源ID不能为空');
                console.error('测试源失败: 源ID为空');
                return;
            }
            
            // 自动为源ID添加custom-前缀，如果尚未添加
            if (!sourceId.startsWith('custom-')) {
                sourceId = 'custom-' + sourceId;
                debugLog('已自动为测试的源ID添加custom-前缀:', sourceId);
            }
            
            debugLog('开始测试源, sourceId:', sourceId);
            // 移除全局加载器的使用
            // showLoader(`测试源中: ${sourceId}...`);
            
            // 更新测试结果容器状态
            const testResultContainer = document.getElementById('sourceTestResultContainer');
            testResultContainer.innerHTML = `
                <div class="alert alert-info">
                    <div class="d-flex align-items-center">
                        <div class="loading me-3"></div>
                        <p class="mb-0">正在测试源 ${sourceId}...</p>
                    </div>
                </div>
            `;
            
            // 自动切换到测试结果标签页
            const testResultTab = document.getElementById('testResultTab');
            if (testResultTab) {
                const tab = new bootstrap.Tab(testResultTab);
                tab.show();
            }
            
            // 记录当前时间用于计算请求时长
            const startTime = new Date();
            
            // 生成API URL并记录
            const apiUrl = `/api/source-test/test-source/${sourceId}`;
            debugLog('测试源API URL:', apiUrl);
            
            // 检查API是否可用
            fetch('/api/source-test/source-types')
                .then(response => {
                    if (!response.ok) {
                        throw new Error(`API服务检查失败: ${response.status} ${response.statusText}`);
                    }
                    return response.json();
                })
                .then(sourceTypes => {
                    // API可用，记录所有源类型
                    debugLog('可用源类型:', sourceTypes);
                    
                    // 继续测试特定源
                    testSpecificSource(sourceId, apiUrl, startTime);
                })
                .catch(error => {
                    // API不可用
                    debugLog('API服务检查失败:', error);
                    
                    // 不再调用hideLoader
                    // hideLoader();
                    
                    testResultContainer.innerHTML = `
                        <div class="alert alert-danger">
                            <p><strong>API服务可能不可用</strong></p>
                            <p>${error.message}</p>
                            <button class="btn btn-sm btn-outline-primary mt-2" onclick="checkApiHealth()">检查API状态</button>
                        </div>
                    `;
                    
                    // 显示错误模态框
                    document.getElementById('resultModalTitle').textContent = 'API服务错误';
                    document.getElementById('resultModalBody').innerHTML = `
                        <div class="alert alert-danger">
                            <p><strong>API服务可能不可用</strong></p>
                            <p>${error.message}</p>
                        </div>
                        <div class="alert alert-warning">
                            <p><strong>可能的原因:</strong></p>
                            <ul>
                                <li>后端API服务未启动或无法访问</li>
                                <li>网络连接问题</li>
                                <li>服务器内部错误</li>
                            </ul>
                        </div>
                        <div class="mt-3">
                            <button class="btn btn-primary" onclick="checkApiHealth()">运行API健康检查</button>
                        </div>
                    `;
                    
                    new bootstrap.Modal(document.getElementById('resultModal')).show();
                });
        }
        
        function testSpecificSource(sourceId, apiUrl, startTime) {
            // Call the API to test the source
            fetch(apiUrl, {
                headers: {
                    'Accept': 'application/json'
                }
            })
            .then(response => {
                const endTime = new Date();
                const requestTime = ((endTime - startTime) / 1000).toFixed(2);
                
                debugLog(`API请求完成，响应状态: ${response.status} ${response.statusText}, 耗时: ${requestTime}秒`);
                console.log(`API请求响应状态: ${response.status} ${response.statusText}, 耗时: ${requestTime}秒`);
                
                if (!response.ok) {
                    if (response.status === 404) {
                        throw new Error(`找不到源 "${sourceId}". API响应: ${response.status} ${response.statusText}`);
                    } else {
                        return response.text().then(errorText => {
                            try {
                                // 尝试解析为JSON
                                const errorJson = JSON.parse(errorText);
                                throw new Error(errorJson.detail || `测试源失败. API响应: ${response.status} ${response.statusText}`);
                            } catch (e) {
                                // 如果不是JSON，则直接使用文本
                                throw new Error(`测试源失败. API响应: ${response.status} ${response.statusText}. 内容: ${errorText.substring(0, 100)}...`);
                            }
                        });
                    }
                }
                return response.json();
            })
            .then(result => {
                // 不再调用hideLoader
                // hideLoader();
                debugLog('测试源结果:', result);
                
                // 确保关闭所有可能的模态框，防止遮罩层问题
                document.querySelectorAll('.modal').forEach(modal => {
                    const bsModal = bootstrap.Modal.getInstance(modal);
                    if (bsModal) {
                        bsModal.hide();
                    }
                });
                
                // 强制清除所有可能的遮罩层
                document.querySelectorAll('.modal-backdrop').forEach(backdrop => {
                    backdrop.remove();
                });
                document.body.classList.remove('modal-open');
                document.body.style.overflow = '';
                document.body.style.paddingRight = '';
                
                // 更新测试结果容器
                const testResultContainer = document.getElementById('sourceTestResultContainer');
                if (result.success) {
                    testResultContainer.innerHTML = `
                        <div class="alert alert-success">
                            <p><strong>测试成功！</strong></p>
                            <p>源: ${result.source_name || sourceId}</p>
                            <p>找到条目数: ${result.items_count}</p>
                            <p>耗时: ${result.elapsed_time.toFixed(2)} 秒</p>
                        </div>
                        <div class="mb-3">
                            <button class="btn btn-success" id="activateSourceBtn">激活源</button>
                        </div>
                        ${result.items && result.items.length > 0 ? `
                            <div>
                                <h5>示例条目:</h5>
                                <div class="list-group">
                                    ${result.items.slice(0, 3).map(item => `
                                        <div class="list-group-item">
                                            <h6>${item.title}</h6>
                                            ${item.url ? `<p class="mb-1"><small><a href="${item.url}" target="_blank">${item.url}</a></small></p>` : ''}
                                            <p class="mb-0">${item.summary || ''}</p>
                                        </div>
                                    `).join('')}
                                </div>
                            </div>
                        ` : ''}
                        ${(result.items_count === 0 && result.debug_info) ? `
                            <div class="mt-3">
                                <div class="alert alert-warning">
                                    <p><strong>未找到任何条目</strong> - 以下是一些调试信息，可能帮助您调整选择器:</p>
                                </div>
                                <div class="accordion" id="debugAccordion">
                                    <div class="accordion-item">
                                        <h2 class="accordion-header">
                                            <button class="accordion-button collapsed" type="button" data-bs-toggle="collapse" data-bs-target="#logsCollapse">
                                                调试日志
                                            </button>
                                        </h2>
                                        <div id="logsCollapse" class="accordion-collapse collapse" data-bs-parent="#debugAccordion">
                                            <div class="accordion-body">
                                                <pre class="bg-light p-2" style="max-height: 300px; overflow: auto; font-size: 0.8rem;">${result.debug_info.logs ? result.debug_info.logs.join('\n') : '无调试日志'}</pre>
                                            </div>
                                        </div>
                                    </div>
                                    <div class="accordion-item">
                                        <h2 class="accordion-header">
                                            <button class="accordion-button collapsed" type="button" data-bs-toggle="collapse" data-bs-target="#selectorsCollapse">
                                                当前选择器
                                            </button>
                                        </h2>
                                        <div id="selectorsCollapse" class="accordion-collapse collapse" data-bs-parent="#debugAccordion">
                                            <div class="accordion-body">
                                                <div class="table-responsive">
                                                    <table class="table table-sm">
                                                        <thead>
                                                            <tr>
                                                                <th>选择器类型</th>
                                                                <th>当前值</th>
                                                            </tr>
                                                        </thead>
                                                        <tbody>
                                                            <tr>
                                                                <td>项目选择器</td>
                                                                <td><code>${result.debug_info.selectors.item || '未设置'}</code></td>
                                                            </tr>
                                                            <tr>
                                                                <td>标题选择器</td>
                                                                <td><code>${result.debug_info.selectors.title || '未设置'}</code></td>
                                                            </tr>
                                                            <tr>
                                                                <td>链接选择器</td>
                                                                <td><code>${result.debug_info.selectors.link || '未设置'}</code></td>
                                                            </tr>
                                                            <tr>
                                                                <td>日期选择器</td>
                                                                <td><code>${result.debug_info.selectors.date || '未设置'}</code></td>
                                                            </tr>
                                                            <tr>
                                                                <td>摘要选择器</td>
                                                                <td><code>${result.debug_info.selectors.summary || '未设置'}</code></td>
                                                            </tr>
                                                            <tr>
                                                                <td>内容选择器</td>
                                                                <td><code>${result.debug_info.selectors.content || '未设置'}</code></td>
                                                            </tr>
                                                        </tbody>
                                                    </table>
                                                </div>
                                            </div>
                                        </div>
                                    </div>
                                </div>
                            </div>
                        ` : ''}
                        <div class="mt-3">
                            <p><strong>技术信息:</strong></p>
                            <pre class="bg-light p-2 border" style="max-height: 200px; overflow: auto; font-size: 0.8rem;">${JSON.stringify(result, null, 2)}</pre>
                        </div>
                    `;
                    
                    // 自动切换到测试结果标签页
                    const testResultTab = document.getElementById('testResultTab');
                    if (testResultTab) {
                        // 创建一个bootstrap tab实例并显示
                        const tab = new bootstrap.Tab(testResultTab);
                        tab.show();
                        
                        // 向用户显示成功提示
                        const toast = new bootstrap.Toast(document.getElementById('notificationToast'));
                        document.getElementById('toastMessage').textContent = `源 ${sourceId} 测试成功，找到 ${result.items_count} 条内容！`;
                        toast.show();
                    }
                    
                    // Add event listener for activate button
                    document.getElementById('activateSourceBtn').addEventListener('click', function() {
                        activateSource(sourceId);
                    });
                } else {
                    // Display error in test result container
                    testResultContainer.innerHTML = `
                        <div class="alert alert-danger">
                            <p><strong>源测试失败</strong></p>
                            <p>${result.error || '发生未知错误'}</p>
                        </div>
                        <div class="mt-3">
                            <p><strong>错误详情:</strong></p>
                            <pre class="bg-light p-2 border" style="max-height: 200px; overflow: auto; font-size: 0.8rem;">${JSON.stringify(result, null, 2)}</pre>
                        </div>
                        <div class="mt-3">
                            <button class="btn btn-outline-primary" onclick="testSource('${sourceId}')">重试</button>
                        </div>
                    `;
                    
                    // 显示失败提示
                    const toast = new bootstrap.Toast(document.getElementById('notificationToast'));
                    document.getElementById('toastMessage').textContent = `源 ${sourceId} 测试失败! 请查看错误详情`;
                    toast.show();
                }
                
                // 不再显示模态框，结果直接显示在测试结果标签页中
            })
            .catch(error => {
                // 先隐藏加载器，确保所有遮罩层都被移除
                hideLoader();
                debugLog('测试源错误:', error);
                
                // 确保关闭所有可能的模态框，防止遮罩层问题
                document.querySelectorAll('.modal').forEach(modal => {
                    const bsModal = bootstrap.Modal.getInstance(modal);
                    if (bsModal) {
                        bsModal.hide();
                    }
                });
                
                // 强制清除所有可能的遮罩层
                document.querySelectorAll('.modal-backdrop').forEach(backdrop => {
                    backdrop.remove();
                });
                document.body.classList.remove('modal-open');
                document.body.style.overflow = '';
                document.body.style.paddingRight = '';
                
                // 更新测试结果容器
                const testResultContainer = document.getElementById('sourceTestResultContainer');
                testResultContainer.innerHTML = `
                    <div class="alert alert-danger">
                        <p><strong>测试源失败</strong></p>
                        <p>${error.message}</p>
                        <button class="btn btn-sm btn-outline-primary mt-2" onclick="testSource('${sourceId}')">重试</button>
                    </div>
                    <div class="mt-3">
                        <p><strong>调试信息:</strong></p>
                        <p>请求时间: ${new Date().toLocaleString()}</p>
                        <p>浏览器: ${navigator.userAgent}</p>
                        <p>如果问题持续出现，请尝试以下步骤:</p>
                        <ol>
                            <li>检查浏览器控制台是否有更详细的错误信息</li>
                            <li>确认后端服务运行正常</li>
                            <li>尝试直接在浏览器中访问: <a href="/api/source-test/source-types" target="_blank">/api/source-test/source-types</a> 验证API是否可用</li>
                            <li>检查源ID命名是否符合规范（仅使用小写字母、数字和连字符）</li>
                        </ol>
                    </div>
                `;
                
                // 切换到测试结果标签页并显示失败提示
                const testResultTab = document.getElementById('testResultTab');
                if (testResultTab) {
                    const tab = new bootstrap.Tab(testResultTab);
                    tab.show();
                    
                    const toast = new bootstrap.Toast(document.getElementById('notificationToast'));
                    document.getElementById('toastMessage').textContent = `源 ${sourceId} 测试失败! 请查看错误详情`;
                    toast.show();
                }
            });
        }
        
        // 添加API直接测试工具函数
        function showDirectApiTest(sourceId) {
            // 在结果模态框中添加API测试表单
            const testForm = document.createElement('div');
            testForm.className = 'mt-4 p-3 border rounded bg-light';
            testForm.innerHTML = `
                <h5>API直接测试工具</h5>
                <div class="mb-3">
                    <label class="form-label">API端点:</label>
                    <div class="input-group">
                        <input type="text" class="form-control" id="apiTestUrl" value="/api/source-test/test-source/${sourceId}" />
                        <input type="number" class="form-control" id="apiTimeout" placeholder="超时(秒)" value="60" style="max-width: 100px;" />
                        <button class="btn btn-primary" id="testApiDirectBtn">测试</button>
                    </div>
                    <div class="form-text">可以修改端点路径或参数进行测试</div>
                </div>
                <div class="mb-3" id="apiTestResult">
                    <div class="alert alert-info">点击"测试"按钮开始API测试</div>
                </div>
            `;
            
            document.getElementById('resultModalBody').appendChild(testForm);
            
            // 添加测试按钮事件
            document.getElementById('testApiDirectBtn').addEventListener('click', function() {
                const apiUrl = document.getElementById('apiTestUrl').value;
                const timeout = document.getElementById('apiTimeout').value;
                const resultContainer = document.getElementById('apiTestResult');
                
                resultContainer.innerHTML = `
                    <div class="alert alert-info">
                        <div class="d-flex align-items-center">
                            <div class="loading me-3"></div>
                            <p class="mb-0">正在测试API: ${apiUrl}?timeout=${timeout}...</p>
                        </div>
                    </div>
                `;
                
                // 执行API请求
                const startTime = new Date();
                fetch(`${apiUrl}?timeout=${timeout}`)
                    .then(response => {
                        const endTime = new Date();
                        const requestTime = ((endTime - startTime) / 1000).toFixed(2);
                        
                        // 显示响应头信息
                        const headers = Array.from(response.headers.entries())
                            .map(([key, value]) => `<tr><td>${key}</td><td>${value}</td></tr>`)
                            .join('');
                        
                        if (!response.ok) {
                            return response.text().then(text => {
                                let errorDetail = text;
                                try {
                                    const errorJson = JSON.parse(text);
                                    errorDetail = JSON.stringify(errorJson, null, 2);
                                } catch (e) {
                                    // Keep as text if not JSON
                                }
                                
                                resultContainer.innerHTML = `
                                    <div class="alert alert-danger">
                                        <p><strong>API请求失败</strong> (${response.status} ${response.statusText})</p>
                                        <p>请求时间: ${requestTime}秒</p>
                                        <p>错误详情:</p>
                                        <pre class="bg-dark text-light p-2 mt-2" style="max-height: 200px; overflow: auto;">${errorDetail}</pre>
                                        <p class="mt-2">响应头:</p>
                                        <div style="max-height: 150px; overflow: auto;">
                                            <table class="table table-sm table-bordered">
                                                <thead><tr><th>名称</th><th>值</th></tr></thead>
                                                <tbody>${headers}</tbody>
                                            </table>
                                        </div>
                                    </div>
                                `;
                                throw new Error(`API请求失败: ${response.status} ${response.statusText}`);
                            });
                        }
                        
                        return response.json().then(data => {
                            resultContainer.innerHTML = `
                                <div class="alert alert-success">
                                    <p><strong>API请求成功</strong> (${response.status} ${response.statusText})</p>
                                    <p>请求时间: ${requestTime}秒</p>
                                    <p>响应数据:</p>
                                    <pre class="bg-dark text-light p-2 mt-2" style="max-height: 200px; overflow: auto;">${JSON.stringify(data, null, 2)}</pre>
                                    <p class="mt-2">响应头:</p>
                                    <div style="max-height: 150px; overflow: auto;">
                                        <table class="table table-sm table-bordered">
                                            <thead><tr><th>名称</th><th>值</th></tr></thead>
                                            <tbody>${headers}</tbody>
                                        </table>
                                    </div>
                                </div>
                            `;
                            return data;
                        });
                    })
                    .catch(error => {
                        resultContainer.innerHTML = `
                            <div class="alert alert-danger">
                                <p><strong>请求发生错误</strong></p>
                                <p>${error.message}</p>
                            </div>
                        `;
                    });
            });
        }
        
        function activateSource(sourceId) {
            // 不再使用全局加载层
            // showLoader(`激活源中: ${sourceId}...`);
            
            // 在测试结果区域显示加载状态
            const testResultContainer = document.getElementById('sourceTestResultContainer');
            testResultContainer.innerHTML = `
                <div class="alert alert-info">
                    <div class="d-flex align-items-center">
                        <div class="loading me-3"></div>
                        <p class="mb-0">正在激活源 ${sourceId}...</p>
                    </div>
                </div>
            `;
            
            // Call the API to activate the source
            fetch(`/api/sources/${sourceId}`, {
                method: 'PUT',
                headers: {
                    'Content-Type': 'application/json'
                    // Removed auth headers:
                    // 'Authorization': 'Bearer ' + (localStorage.getItem('auth_token') || ''),
                    // 'X-API-Key': localStorage.getItem('api_key') || ''
                },
                body: JSON.stringify({
                    status: 'active'
                }),
                credentials: 'include' // 包含cookies，这对于会话认证很重要
            })
            .then(response => {
                if (!response.ok) {
                    // 详细记录错误
                    console.error('激活源失败，状态码:', response.status, response.statusText);
                    return response.text().then(text => {
                        let errorDetail = '激活源失败';
                        try {
                            const errorJson = JSON.parse(text);
                            errorDetail = errorJson.detail || `API错误: ${response.status} ${response.statusText}`;
                            console.error('API错误详情:', errorJson);
                        } catch (e) {
                            // 如果不是JSON，直接使用文本
                            errorDetail = `API错误: ${response.status} ${response.statusText}. ${text}`;
                            console.error('API响应内容:', text);
                        }
                        throw new Error(errorDetail);
                    });
                }
                return response.json();
            })
            .then(result => {
                // 不再使用hideLoader
                // hideLoader();
                
                // 更新测试结果区域显示成功状态
                testResultContainer.innerHTML = `
                    <div class="alert alert-success">
                        <p><strong>源 "${result.name}" 已成功激活！</strong></p>
                        <p>源现在处于活动状态，将用于新闻聚合。</p>
                    </div>
                `;
                
                // 显示成功提示
                const toast = new bootstrap.Toast(document.getElementById('notificationToast'));
                document.getElementById('toastMessage').textContent = `源 "${result.name}" 已成功激活！`;
                toast.show();
                
                // 更新源列表以反映状态变化
                loadSources();
                
                // 不再显示模态框，直接在测试结果区域显示结果信息
                /*
                // Show success message
                document.getElementById('resultModalTitle').textContent = '源已激活';
                document.getElementById('resultModalBody').innerHTML = `
                    <div class="alert alert-success">
                        <p><strong>源 "${result.name}" 已成功激活！</strong></p>
                        <p>源现在处于活动状态，将用于新闻聚合。</p>
                    </div>
                    <p>您可以在"管理源"部分管理此源。</p>
                `;
                
                // 显示模态框
                new bootstrap.Modal(document.getElementById('resultModal')).show();
                */
            })
            .catch(error => {
                // 不再使用hideLoader
                // hideLoader();
                
                console.error('激活源时出错:', error);
                
                // 在测试结果区域显示错误状态
                testResultContainer.innerHTML = `
                    <div class="alert alert-danger">
                        <p><strong>激活源失败</strong></p>
                        <p>${error.message}</p>
                        <button class="btn btn-sm btn-outline-primary mt-2" onclick="activateSource('${sourceId}')">重试</button>
                    </div>
                `;
                
                // 检查是否是认证错误
                if (error.message.includes('Not authenticated') || 
                    error.message.includes('401') || 
                    error.message.includes('auth') || 
                    error.message.includes('认证')) {
                    
                    // 处理认证错误
                    handleAuthError(error, () => {
                        // 认证成功后重新尝试激活
                        activateSource(sourceId);
                    });
                    return;
                }
                
                // 使用Toast显示错误
                const toast = new bootstrap.Toast(document.getElementById('notificationToast'));
                document.getElementById('toastMessage').textContent = `激活源失败: ${error.message}`;
                document.getElementById('notificationToast').classList.add('bg-danger', 'text-white');
                toast.show();
                
                // 5秒后恢复原来的样式
                setTimeout(() => {
                    document.getElementById('notificationToast').classList.remove('bg-danger', 'text-white');
                }, 5000);
                
                // 不再显示模态框，直接在测试结果区域显示错误信息
                /*
                // Show error message
                document.getElementById('resultModalTitle').textContent = '错误';
                document.getElementById('resultModalBody').innerHTML = `
                    <div class="alert alert-danger">
                        <p><strong>激活源失败</strong></p>
                        <p>${error.message}</p>
                    </div>
                `;
                
                // 显示模态框
                new bootstrap.Modal(document.getElementById('resultModal')).show();
                */
            });
        }
        
        function loadSources() {
            const sourceListContainer = document.getElementById('sourceListContainer');
            
            // Show loading indicator
            sourceListContainer.innerHTML = `
                <div class="text-center py-3">
                    <div class="loading"></div>
                    <p class="mt-2">加载源中...</p>
                </div>
            `;
            
            // Fetch sources from API
            fetch('/api/sources')
            .then(response => {
                if (!response.ok) {
                    return response.json().then(err => {
                        throw new Error(err.detail || '加载源失败');
                    });
                }
                return response.json();
            })
            .then(sources => {
                // Filter to show only custom sources
                const customSources = sources.filter(source => 
                    source.config && 
                    source.config.auto_generated
                );
                
                if (customSources.length === 0) {
                    sourceListContainer.innerHTML = `
                        <div class="alert alert-info">
                            <p>未找到自定义源。请先创建一个新源。</p>
                        </div>
                    `;
                    return;
                }
                
                // Render sources
                sourceListContainer.innerHTML = '';
                
                customSources.forEach(source => {
                    const sourceItem = document.createElement('a');
                    sourceItem.href = '#';
                    sourceItem.className = 'list-group-item list-group-item-action source-list-item';
                    sourceItem.dataset.sourceId = source.id;
                    
                    // Determine status badge class
                    let statusBadgeClass = 'bg-secondary';
                    if (source.status === 'active') statusBadgeClass = 'bg-success';
                    if (source.status === 'error') statusBadgeClass = 'bg-danger';
                    if (source.status === 'warning') statusBadgeClass = 'bg-warning text-dark';
                    
                    sourceItem.innerHTML = `
                        <div class="d-flex justify-content-between align-items-center">
                            <div>
                                <h6 class="mb-0">${source.name}</h6>
                                <small class="text-muted">${source.id}</small>
                            </div>
                            <span class="badge ${statusBadgeClass}">${source.status}</span>
                        </div>
                    `;
                    
                    // Add click event
                    sourceItem.addEventListener('click', (e) => {
                        e.preventDefault();
                        
                        // Remove active class from all sources
                        document.querySelectorAll('.source-list-item').forEach(item => {
                            item.classList.remove('active');
                        });
                        
                        // Add active class to this source
                        sourceItem.classList.add('active');
                        
                        // Load source details
                        loadSourceDetails(source.id);
                        
                        // Enable action buttons
                        document.getElementById('testSelectedSourceBtn').disabled = false;
                        document.getElementById('activateSourceBtn').disabled = source.status === 'active';
                        document.getElementById('deactivateSourceBtn').disabled = source.status !== 'active';
                        document.getElementById('deleteSourceBtn').disabled = false;
                    });
                    
                    sourceListContainer.appendChild(sourceItem);
                });
            })
            .catch(error => {
                console.error('Error loading sources:', error);
                
                sourceListContainer.innerHTML = `
                    <div class="alert alert-danger">
                        <p><strong>加载源失败</strong></p>
                        <p>${error.message}</p>
                        <button class="btn btn-sm btn-outline-primary mt-2" onclick="loadSources()">重试</button>
                    </div>
                `;
            });
        }
        
        function loadSourceDetails(sourceId) {
            // Show loading indicator in all tabs
            document.getElementById('sourceDetailsContainer').innerHTML = `
                <div class="text-center py-3">
                    <div class="loading"></div>
                    <p class="mt-2">加载详情中...</p>
                </div>
            `;
            
            document.getElementById('sourceStatsContainer').innerHTML = `
                <div class="text-center py-3">
                    <div class="loading"></div>
                    <p class="mt-2">加载统计信息中...</p>
                </div>
            `;
            
            document.getElementById('sourceConfigContainer').innerHTML = `
                <div class="text-center py-3">
                    <div class="loading"></div>
                    <p class="mt-2">加载配置中...</p>
                </div>
            `;
            
            document.getElementById('sourceTestResultContainer').innerHTML = `
                <div class="alert alert-info">
                    <p>点击"测试源"来运行测试并查看结果。</p>
                </div>
            `;
            
            // Set selected source
            selectedSource = sourceId;
            
            // Fetch source details from API
            Promise.all([
                fetch(`/api/sources/${sourceId}`).then(response => response.json()),
                fetch(`/api/sources/${sourceId}/stats`).then(response => response.json()).catch(() => ({}))
            ])
            .then(([sourceDetails, sourceStats]) => {
                // Display source details
                displaySourceDetails(sourceDetails);
                
                // Display source stats
                displaySourceStats(sourceStats);
                
                // Display source config
                displaySourceConfig(sourceDetails);
            })
            .catch(error => {
                console.error('Error loading source details:', error);
                
                document.getElementById('sourceDetailsContainer').innerHTML = `
                    <div class="alert alert-danger">
                        <p><strong>加载源详情失败</strong></p>
                        <p>${error.message}</p>
                    </div>
                `;
            });
        }
        
        // 加载所有类别
        let allCategories = [];
        
        function loadCategories() {
            fetch('/api/categories/')
                .then(response => response.json())
                .then(categories => {
                    allCategories = categories;
                    console.log('加载了类别:', categories);
                    
                    // 初始化类别选择器
                    const categorySelect = document.getElementById('editSourceCategory');
                    categorySelect.innerHTML = '';
                    
                    categories.forEach(category => {
                        const option = document.createElement('option');
                        option.value = category.id;
                        option.textContent = category.name;
                        categorySelect.appendChild(option);
                    });
                })
                .catch(error => console.error('加载类别失败:', error));
        }
        
        // 在页面加载时获取类别列表
        loadCategories();

        // 根据category_id获取类别名称
        function getCategoryNameById(categoryId) {
            const category = allCategories.find(c => c.id === categoryId);
            return category ? category.name : '未知';
        }
        
        // 在源详情中显示类别名称
        function displaySourceDetails(source) {
            const container = document.getElementById('sourceDetailsContainer');
            
            if (!source) {
                container.innerHTML = `
                    <div class="alert alert-info">
                        <p>请从列表中选择一个源以查看其详情。</p>
                    </div>
                `;
                return;
            }
            
            // 获取类别名称
            const categoryName = getCategoryNameById(source.category_id);
            
            container.innerHTML = `
                <div class="d-flex justify-content-between align-items-start mb-3">
                    <h5>${source.name}</h5>
                    <span class="badge ${getStatusBadgeClass(source.status)}">${source.status}</span>
                </div>
                
                <p class="text-muted">${source.description || '无描述'}</p>
                
                <div class="row">
                    <div class="col-md-6">
                        <dl>
                            <dt>源ID</dt>
                            <dd>${source.id}</dd>
                            
                            <dt>URL</dt>
                            <dd>
                                <a href="${source.url}" target="_blank" rel="noopener noreferrer">
                                    ${source.url || '无URL'}
                                    <i class="bi bi-box-arrow-up-right"></i>
                                </a>
                            </dd>
                            
                            <dt>类型</dt>
                            <dd>${source.type || '未知'}</dd>
                            
                            <dt>类别</dt>
                            <dd>${categoryName}</dd>
                        </dl>
                    </div>
                    
                    <div class="col-md-6">
                        <dl>
                            <dt>更新间隔</dt>
                            <dd>${formatSeconds(source.update_interval)}</dd>
                            
                            <dt>缓存TTL</dt>
                            <dd>${formatSeconds(source.cache_ttl)}</dd>
                            
                            <dt>国家/地区</dt>
                            <dd>${source.country || '全球'}</dd>
                            
                            <dt>语言</dt>
                            <dd>${source.language || '未知'}</dd>
                        </dl>
                    </div>
                </div>
                
                <div class="d-flex justify-content-end mt-3">
                    <button class="btn btn-outline-primary" id="editDetailsBtn">
                        <i class="bi bi-pencil"></i> 编辑详情
                    </button>
                </div>
            `;
            
            // Add event listener for edit button
            document.getElementById('editDetailsBtn').addEventListener('click', () => {
                openEditModal(source, 'details');
            });
        }

        function displaySourceStats(stats) {
            const container = document.getElementById('sourceStatsContainer');
            
            if (!stats || Object.keys(stats).length === 0) {
                container.innerHTML = `
                    <div class="alert alert-info">
                        <p>暂无可用的统计信息。</p>
                    </div>
                `;
                return;
            }
            
            container.innerHTML = `
                <div class="row">
                    <div class="col-md-6">
                        <div class="card">
                            <div class="card-body">
                                <h6 class="card-title">新闻数量</h6>
                                <p class="card-text display-6">${stats.news_count || 0}</p>
                            </div>
                        </div>
                    </div>
                    
                    <div class="col-md-6">
                        <div class="card">
                            <div class="card-body">
                                <h6 class="card-title">最后更新</h6>
                                <p class="card-text">${formatDate(stats.last_updated) || '从未'}</p>
                            </div>
                        </div>
                    </div>
                </div>
                
                <div class="row mt-3">
                    <div class="col-md-6">
                        <div class="card">
                            <div class="card-body">
                                <h6 class="card-title">错误数量</h6>
                                <p class="card-text display-6">${stats.error_count || 0}</p>
                            </div>
                        </div>
                    </div>
                    
                    <div class="col-md-6">
                        <div class="card">
                            <div class="card-body">
                                <h6 class="card-title">最后错误</h6>
                                <p class="card-text text-danger">${stats.last_error || '无'}</p>
                            </div>
                        </div>
                    </div>
                </div>
            `;
        }
        
        function displaySourceConfig(source) {
            const container = document.getElementById('sourceConfigContainer');
            
            if (!source.config) {
                container.innerHTML = `
                    <div class="alert alert-info">
                        <p>无可用的配置信息。</p>
                    </div>
                `;
                return;
            }
            
            container.innerHTML = `
                <div class="mb-3">
                    <h6>源配置</h6>
                    <div id="configViewEditor"></div>
                </div>
                
                <div class="d-flex justify-content-end mt-3">
                    <button class="btn btn-outline-primary" id="editConfigBtn">
                        <i class="bi bi-pencil"></i> 编辑配置
                    </button>
                </div>
            `;
            
            // Initialize CodeMirror
            const configViewEditor = CodeMirror(document.getElementById('configViewEditor'), {
                value: JSON.stringify(source.config, null, 2),
                mode: { name: 'javascript', json: true },
                theme: 'monokai',
                lineNumbers: true,
                readOnly: true
            });
            
            // Add event listener for edit button
            document.getElementById('editConfigBtn').addEventListener('click', () => {
                openEditModal(source, 'config');
            });
        }
        
        function openEditModal(source, tab = 'details') {
            // Set up modal form
            document.getElementById('editSourceId').value = source.id;
            document.getElementById('editSourceName').value = source.name;
            document.getElementById('editSourceUrl').value = source.url;
            document.getElementById('editSourceDescription').value = source.description || `自动生成的源：${source.url}`;
            
            // 设置正确的类别
            const categorySelect = document.getElementById('editSourceCategory');
            if (source.category_id) {
                categorySelect.value = source.category_id;
            }
            
            document.getElementById('editSourceStatus').value = source.status;
            document.getElementById('editUpdateInterval').value = source.update_interval;
            document.getElementById('editCacheTtl').value = source.cache_ttl;
            
            // Set up config editor
            configEditor.setValue(JSON.stringify(source.config || {}, null, 2));
            
            // Show modal
            new bootstrap.Modal(document.getElementById('editSourceModal')).show();
            
            // Set up save button
            document.getElementById('saveSourceBtn').onclick = () => saveSource(source.id);
        }
        
        function saveSource(sourceId) {
            showLoader('保存更改中...');
            
            // Get form data
            const data = {
                name: document.getElementById('editSourceName').value,
                url: document.getElementById('editSourceUrl').value,
                description: document.getElementById('editSourceDescription').value || `Custom source for ${document.getElementById('editSourceUrl').value}`,
                category_id: parseInt(document.getElementById('editSourceCategory').value),
                status: document.getElementById('editSourceStatus').value,
                update_interval: parseInt(document.getElementById('editUpdateInterval').value),
                cache_ttl: parseInt(document.getElementById('editCacheTtl').value)
            };
            
            // Try to parse JSON config
            try {
                data.config = JSON.parse(configEditor.getValue());
            } catch (error) {
                hideLoader();
                alert('JSON配置无效: ' + error.message);
                return;
            }
            
            // Update source
            fetch(`/api/sources/${sourceId}`, {
                method: 'PUT',
                headers: {
                    'Content-Type': 'application/json'
                    // Removed auth headers:
                    // 'Authorization': 'Bearer ' + (localStorage.getItem('auth_token') || ''),
                    // 'X-API-Key': localStorage.getItem('api_key') || ''
                },
                body: JSON.stringify(data),
                credentials: 'include' // 包含cookies，这对于会话认证很重要
            })
            .then(response => {
                if (!response.ok) {
                    // 详细记录错误
                    console.error('更新源失败，状态码:', response.status, response.statusText);
                    return response.text().then(text => {
                        let errorDetail = '更新源失败';
                        try {
                            const errorJson = JSON.parse(text);
                            errorDetail = errorJson.detail || `API错误: ${response.status} ${response.statusText}`;
                            console.error('API错误详情:', errorJson);
                        } catch (e) {
                            // 如果不是JSON，直接使用文本
                            errorDetail = `API错误: ${response.status} ${response.statusText}. ${text}`;
                            console.error('API响应内容:', text);
                        }
                        throw new Error(errorDetail);
                    });
                }
                return response.json();
            })
            .then(result => {
                hideLoader();
                
                // 显示成功提示
                const toast = new bootstrap.Toast(document.getElementById('notificationToast'));
                document.getElementById('toastMessage').textContent = `源 ${data.name} 更新成功！`;
                toast.show();
                
                // Hide modal
                bootstrap.Modal.getInstance(document.getElementById('editSourceModal')).hide();
                
                // Reload source details
                loadSourceDetails(sourceId);
                
                // Reload source list to update status
                loadSources();
            })
            .catch(error => {
                hideLoader();
                
                console.error('保存源时出错:', error);
                
                // 检查是否是认证错误
                if (error.message.includes('Not authenticated') || 
                    error.message.includes('401') || 
                    error.message.includes('auth') || 
                    error.message.includes('认证')) {
                    
                    // 处理认证错误
                    handleAuthError(error, () => {
                        // 认证成功后重新尝试保存
                        saveSource(sourceId);
                    });
                    return;
                }
                
                // 使用Toast显示错误，而不是alert
                const toast = new bootstrap.Toast(document.getElementById('notificationToast'));
                document.getElementById('toastMessage').textContent = `更新源失败: ${error.message}`;
                document.getElementById('notificationToast').classList.add('bg-danger', 'text-white');
                toast.show();
                
                // 5秒后恢复原来的样式
                setTimeout(() => {
                    document.getElementById('notificationToast').classList.remove('bg-danger', 'text-white');
                }, 5000);
            });
        }
        
        // Helper functions for formatting
        function formatSeconds(seconds) {
            if (!seconds) return '未指定';
            
            const hours = Math.floor(seconds / 3600);
            const minutes = Math.floor((seconds % 3600) / 60);
            const secs = seconds % 60;
            
            let result = '';
            if (hours > 0) result += `${hours}小时 `;
            if (minutes > 0) result += `${minutes}分钟 `;
            if (secs > 0 || result === '') result += `${secs}秒`;
            
            return result;
        }
        
        function formatDate(dateStr) {
            if (!dateStr) return '不可用';
            
            const date = new Date(dateStr);
            return date.toLocaleString();
        }
        
        function getStatusBadgeClass(status) {
            switch (status) {
                case 'active': return 'bg-success';
                case 'error': return 'bg-danger';
                case 'warning': return 'bg-warning text-dark';
                case 'inactive': return 'bg-secondary';
                default: return 'bg-secondary';
            }
        }
        
        function deleteSource(sourceId) {
            showLoader(`删除源中: ${sourceId}...`);
            
            fetch(`/api/sources/${sourceId}`, {
                method: 'DELETE'
            })
            .then(response => {
                if (!response.ok) {
                    return response.json().then(err => {
                        throw new Error(err.detail || '删除源失败');
                    });
                }
                return response.json();
            })
            .then(result => {
                hideLoader();
                
                // Reload sources
                loadSources();
                
                // Clear selected source
                selectedSource = null;
                
                // Clear source details
                document.getElementById('sourceDetailsContainer').innerHTML = `
                    <div class="alert alert-info">
                        <p>从列表中选择一个源以查看其详情。</p>
                    </div>
                `;
                
                document.getElementById('sourceStatsContainer').innerHTML = `
                    <div class="alert alert-info">
                        <p>从列表中选择一个源以查看其统计信息。</p>
                    </div>
                `;
                
                document.getElementById('sourceConfigContainer').innerHTML = `
                    <div class="alert alert-info">
                        <p>从列表中选择一个源以查看和编辑其配置。</p>
                    </div>
                `;
                
                document.getElementById('sourceTestResultContainer').innerHTML = `
                    <div class="alert alert-info">
                        <p>点击"测试源"来运行测试并查看结果。</p>
                    </div>
                `;
                
                // Disable action buttons
                document.getElementById('testSelectedSourceBtn').disabled = true;
                document.getElementById('activateSourceBtn').disabled = true;
                document.getElementById('deactivateSourceBtn').disabled = true;
                document.getElementById('deleteSourceBtn').disabled = true;
                
                // Show notification
                alert(`源 "${sourceId}" 已成功删除`);
            })
            .catch(error => {
                hideLoader();
                
                alert('删除源失败: ' + error.message);
            });
        }
        
        // 添加HTML分析函数
        function analyzeHtml() {
            try {
                // 获取HTML内容
                const htmlContent = htmlEditor.getValue().trim();
                if (!htmlContent) {
                    showToast('提示', '请先输入或粘贴HTML内容', 'warning');
                    return;
                }
                
                console.log('开始分析HTML内容...');
                
                // 在DOM中解析HTML
                const parser = new DOMParser();
                const htmlDoc = parser.parseFromString(htmlContent, 'text/html');
                
                // 初始化一个对象存储找到的选择器
                const foundSelectors = {
                    container: [],
                    item: [],
                    title: [],
                    link: [],
                    date: [],
                    summary: [],
                    content: []
                };
                
                // 分析潜在的新闻容器
                console.log('分析潜在的新闻容器...');
                foundSelectors.container = analyzeContainers(htmlDoc);
                
                // 如果找到了容器，分析容器中的列表项
                if (foundSelectors.container.length > 0) {
                    const containerSelector = validateAndFixSelector(foundSelectors.container[0].selector, 'container');
                    try {
                        const container = htmlDoc.querySelector(containerSelector);
                        if (container) {
                            console.log('分析条目...');
                            foundSelectors.item = analyzeListItems(container, containerSelector);
                        }
                    } catch (e) {
                        console.error(`使用容器选择器分析时出错: ${e.message}`);
                    }
                }
                
                // 如果找到了列表项，分析其中的标题、链接等
                if (foundSelectors.item.length > 0) {
                    const itemSelector = validateAndFixSelector(foundSelectors.item[0].selector, 'item');
                    try {
                        const itemElement = htmlDoc.querySelector(itemSelector);
                        if (itemElement) {
                            console.log('分析标题元素...');
                            foundSelectors.title = analyzeTitleElement(itemElement, itemSelector);
                            
                            console.log('分析链接元素...');
                            foundSelectors.link = analyzeLinkElement(itemElement, itemSelector);
                            
                            console.log('分析日期元素...');
                            foundSelectors.date = analyzeDateElement(itemElement, itemSelector);
                            
                            console.log('分析摘要元素...');
                            foundSelectors.summary = analyzeSummaryElement(itemElement, itemSelector);
                            
                            console.log('分析内容元素...');
                            foundSelectors.content = analyzeContentElement(itemElement, itemSelector);
                        }
                    } catch (e) {
                        console.error(`使用条目选择器分析时出错: ${e.message}`);
                    }
                }
                
                // 创建结果消息
                let resultMessage = createResultMessage(foundSelectors, htmlDoc);
                
                // 显示结果
                const resultModalBody = document.getElementById('resultModalBody');
                resultModalBody.innerHTML = resultMessage;
                
                // 第五步：尝试填充表单字段
                try {
                    // 根据分析结果填充表单字段
                    if (foundSelectors.container && foundSelectors.container.length > 0) {
                        setSelector('container', foundSelectors.container[0].selector);
                    }
                    
                    if (foundSelectors.item && foundSelectors.item.length > 0) {
                        setSelector('item', foundSelectors.item[0].selector);
                    }
                    
                    if (foundSelectors.title && foundSelectors.title.length > 0) {
                        const titleSelector = foundSelectors.title[0].selector;
                        setSelector('title', titleSelector);
                    }
                    
                    if (foundSelectors.link && foundSelectors.link.length > 0) {
                        const linkSelector = foundSelectors.link[0].selector;
                        setSelector('link', linkSelector);
                    }
                    
                    if (foundSelectors.date && foundSelectors.date.length > 0) {
                        setSelector('date', foundSelectors.date[0].selector);
                    }
                    
                    if (foundSelectors.summary && foundSelectors.summary.length > 0) {
                        setSelector('summary', foundSelectors.summary[0].selector);
                    }
                    
                    if (foundSelectors.content && foundSelectors.content.length > 0) {
                        setSelector('content', foundSelectors.content[0].selector);
                    }
                    
                    console.log('自动填充表单字段完成');
                } catch (e) {
                    console.error('填充表单字段时出错:', e);
                }
                
                // 存储解析后的HTML文档用于后续测试
                window.parsedHtmlDoc = htmlDoc;
                
                // 设置测试按钮事件处理
                setupTestButtons();
                
                // 显示模态框
                const resultModal = new bootstrap.Modal(document.getElementById('resultModal'));
                resultModal.show();
                
                console.log('HTML分析完成');
                
            } catch (error) {
                console.error('分析HTML时出错:', error);
                showToast('错误', `分析HTML时出错: ${error.message}`, 'danger');
            }
        }
        
        // 设置测试按钮的事件处理
        function setupTestButtons() {
            // 从结果中获取选择器值
            const getCodeValueFromElement = (element) => {
                if (!element) return '';
                const codeEl = safeQuerySelector(element, 'code', false);
                return codeEl ? codeEl.textContent : '';
            };
            
            // 获取各个选择器的值
            let containerSelector = '';
            let itemSelector = '';
            let titleSelector = '';
            let linkSelector = '';
            let dateSelector = '';
            let summarySelector = '';
            let contentSelector = '';
            
            // 从结果中提取选择器
            const selectorItems = safeQuerySelector(document, '#resultModalBody li', true);
            for (let i = 0; i < selectorItems.length; i++) {
                const itemText = selectorItems[i].textContent;
                if (itemText.includes('容器选择器:')) {
                    containerSelector = getCodeValueFromElement(selectorItems[i]);
                    console.log('提取容器选择器:', containerSelector);
                } else if (itemText.includes('条目选择器:')) {
                    itemSelector = getCodeValueFromElement(selectorItems[i]);
                    console.log('提取条目选择器:', itemSelector);
                } else if (itemText.includes('标题选择器:')) {
                    titleSelector = getCodeValueFromElement(selectorItems[i]);
                    console.log('提取标题选择器:', titleSelector);
                } else if (itemText.includes('链接选择器:')) {
                    linkSelector = getCodeValueFromElement(selectorItems[i]);
                    console.log('提取链接选择器:', linkSelector);
                } else if (itemText.includes('日期选择器:')) {
                    dateSelector = getCodeValueFromElement(selectorItems[i]);
                    console.log('提取日期选择器:', dateSelector);
                } else if (itemText.includes('摘要选择器:')) {
                    summarySelector = getCodeValueFromElement(selectorItems[i]);
                    console.log('提取摘要选择器:', summarySelector);
                } else if (itemText.includes('内容选择器:')) {
                    contentSelector = getCodeValueFromElement(selectorItems[i]);
                    console.log('提取内容选择器:', contentSelector);
                }
            }
            
            // 如果没有从li元素中找到选择器，尝试从表格中获取
            if (!titleSelector || !linkSelector) {
                console.log('尝试从表格中获取标题和链接选择器');
                
                // 尝试从标题表格中获取最高分的选择器
                const titleTable = safeQuerySelector(document, '#resultModalBody table:nth-of-type(1)', false);
                if (titleTable && !titleSelector) {
                    const firstRow = safeQuerySelector(titleTable, 'tbody tr:first-child', false);
                    if (firstRow) {
                        const firstCell = safeQuerySelector(firstRow, 'td:first-child code', false);
                        if (firstCell) {
                            titleSelector = firstCell.textContent;
                            console.log('从表格中提取标题选择器:', titleSelector);
                        }
                    }
                }
                
                // 尝试从链接表格中获取最高分的选择器
                const linkTable = safeQuerySelector(document, '#resultModalBody table:nth-of-type(2)', false);
                if (linkTable && !linkSelector) {
                    const firstRow = safeQuerySelector(linkTable, 'tbody tr:first-child', false);
                    if (firstRow) {
                        const firstCell = safeQuerySelector(firstRow, 'td:first-child code', false);
                        if (firstCell) {
                            linkSelector = firstCell.textContent;
                            console.log('从表格中提取链接选择器:', linkSelector);
                        }
                    }
                }
            }
            
            // 容器选择器测试
            const containerBtn = document.getElementById('test_container_btn');
            if (containerBtn) {
                containerBtn.onclick = function() {
                    testSelectorWithValue('container', containerSelector);
                };
            }
            
            // 条目选择器测试
            const itemBtn = document.getElementById('test_item_btn');
            if (itemBtn) {
                itemBtn.onclick = function() {
                    testSelectorWithValue('item', itemSelector);
                };
            }
            
            // 标题选择器测试
            const titleBtn = document.getElementById('test_title_btn');
            if (titleBtn) {
                titleBtn.onclick = function() {
                    testSelectorWithValue('title', titleSelector);
                };
            }
            
            // 链接选择器测试
            const linkBtn = document.getElementById('test_link_btn');
            if (linkBtn) {
                linkBtn.onclick = function() {
                    testSelectorWithValue('link', linkSelector);
                };
            }
            
            // 日期选择器测试
            const dateBtn = document.getElementById('test_date_btn');
            if (dateBtn) {
                dateBtn.onclick = function() {
                    testSelectorWithValue('date', dateSelector);
                };
            }
            
            // 摘要选择器测试
            const summaryBtn = document.getElementById('test_summary_btn');
            if (summaryBtn) {
                summaryBtn.onclick = function() {
                    testSelectorWithValue('summary', summarySelector);
                };
            }
            
            // 内容选择器测试
            const contentBtn = document.getElementById('test_content_btn');
            if (contentBtn) {
                contentBtn.onclick = function() {
                    testSelectorWithValue('content', contentSelector);
                };
            }
        }
        
        // 在页面加载完成后设置事件处理
        document.addEventListener('DOMContentLoaded', function() {
            // 设置"分析HTML"按钮的点击事件
            document.getElementById('analyzeHtmlBtn').addEventListener('click', analyzeHtml);
            
            // 测试按钮会在analyzeHtml函数完成后动态创建，所以不需要在这里设置
            // setupTestButtons();
        });
        
        // 辅助函数：判断字符串是否可能是日期
        function isLikelyDateString(text) {
            // 检查是否包含日期格式
            return /\d{1,4}[-\/\.年]\d{1,2}[-\/\.月]\d{1,2}/.test(text) || // 年-月-日格式
                  /\d{1,2}[-\/\.]\d{1,2}[-\/\.]\d{2,4}/.test(text) || // 日-月-年格式
                  /\d{1,2}:\d{1,2}/.test(text) || // 时:分格式
                  /\d{4}年\d{1,2}月\d{1,2}日/.test(text) || // 中文日期格式
                  /\d{2}-\d{2}\s\d{2}:\d{2}/.test(text) || // 和讯网格式 MM-DD HH:MM
                  /\d{2}-\d{2}/.test(text); // 简单的MM-DD格式
        }
        
        // 定义选择器按钮的点击处理函数，避免匿名函数重复定义
        function selectorButtonClickHandler() {
            const targetId = this.getAttribute('data-target');
            const value = this.getAttribute('data-value');
            document.getElementById(targetId).value = value;
            // 可选：在使用后高亮显示按钮，提供视觉反馈
            this.classList.remove('btn-outline-primary');
            this.classList.add('btn-primary');
            this.textContent = '已使用';
        }
        
        function formatHtmlContent(html) {
            // 移除多余的空白和空行
            html = html.trim();
            
            // 使用正则表达式进行初步处理
            // 将多个空格替换为单个空格
            html = html.replace(/\s{2,}/g, ' ');
            
            // 处理自闭合标签
            html = html.replace(/<([^\/][^>]*?)\/>/g, '<$1></$1>');
            
            // 防止一些特殊情况下标签之间的文本被错误地缩进
            html = html.replace(/>\s+</g, '> <');
            
            // 特别处理常见的新闻结构
            // 特殊处理liveNews、newsDl等特定类
            const specialClasses = ['liveNews', 'newsDl', 'newsBox', 'newsList', 'clearfix'];
            for (const className of specialClasses) {
                // 添加注释标记重要结构
                html = html.replace(new RegExp(`class=(["\'])[^"\']*${className}[^"\']*\\1`, 'gi'), 
                                  (match) => `${match} data-important="true"`);
            }
            
            let formatted = '';
            let indent = '';
            
            // 处理每个字符
            const len = html.length;
            let inTag = false;
            let inTagName = false;
            let tagName = '';
            let currentTagContent = '';
            let inComment = false;
            let inQuote = false; 
            let quoteChar = '';
            let lastNonSpaceChar = '';
            
            for (let i = 0; i < len; i++) {
                const char = html.charAt(i);
                const nextChar = i < len - 1 ? html.charAt(i + 1) : '';
                const prevChar = i > 0 ? html.charAt(i - 1) : '';
                
                // 更新最后一个非空格字符
                if (char !== ' ' && char !== '\n' && char !== '\t') {
                    lastNonSpaceChar = char;
                }
                
                // 处理注释
                if (char === '<' && nextChar === '!' && i + 3 < len && html.charAt(i + 2) === '-' && html.charAt(i + 3) === '-') {
                    inComment = true;
                    formatted += '\n' + indent + '<!-- ';
                    i += 3; // 跳过 "!--"
                    continue;
                }
                
                if (inComment) {
                    if (char === '-' && nextChar === '-' && i + 2 < len && html.charAt(i + 2) === '>') {
                        inComment = false;
                        formatted += ' -->';
                        i += 2; // 跳过 "->"
                        continue;
                    }
                    formatted += char;
                    continue;
                }
                
                // 处理引号
                if (inTag && (char === '"' || char === "'") && prevChar !== '\\') {
                    if (!inQuote) {
                        inQuote = true;
                        quoteChar = char;
                    } else if (char === quoteChar) {
                        inQuote = false;
                    }
                    formatted += char;
                    continue;
                }
                
                // 在引号内保持原样
                if (inQuote) {
                    formatted += char;
                    continue;
                }
                
                // 处理标签开始
                if (char === '<' && !inTag) {
                    inTag = true;
                    inTagName = true;
                    tagName = '';
                    currentTagContent = '<';
                    
                    // 处理结束标签缩进
                    if (nextChar === '/') {
                        if (indent.length > 0) {
                            indent = indent.substring(2);
                        }
                        formatted += '\n' + indent;
                    } else {
                        // 为非内联元素添加换行和缩进
                        // 特殊处理dl/dd/dt标签，使其对齐更美观
                        const nextTag = getTagName(html.substring(i));
                        const isSpecial = nextTag === 'dl' || nextTag === 'dt' || nextTag === 'dd';
                        
                        if ((isSpecial || !isInlineElement(nextTag)) && lastNonSpaceChar !== '>') {
                            formatted += '\n' + indent;
                        }
                    }
                    
                    continue;
                }
                
                // 收集标签名称
                if (inTag && inTagName && char !== ' ' && char !== '>' && char !== '/') {
                    tagName += char.toLowerCase();
                    currentTagContent += char;
                } else if (inTagName && inTag) {
                    inTagName = false;
                    currentTagContent += char;
                } else if (inTag) {
                    currentTagContent += char;
                }
                
                // 处理标签结束
                if (inTag && char === '>') {
                    inTag = false;
                    formatted += currentTagContent;
                    
                    // 特殊处理data-important属性
                    if (currentTagContent.includes('data-important="true"')) {
                        // 在重要结构前后添加空行
                        if (!currentTagContent.startsWith('</')) {
                            formatted += '\n' + indent + '<!-- 重要结构: ' + tagName + ' -->';
                        }
                    }
                    
                    // 为非内联元素和非自闭合标签添加缩进
                    if (!currentTagContent.includes('</') && !currentTagContent.includes('/>') && 
                        !isInlineElement(tagName) && nextChar !== '<') {
                        indent += '  ';
                    }
                    
                    continue;
                }
                
                // 只有在不在标签内时才添加字符，因为我们已经在处理标签结束时添加了完整的标签内容
                if (!inTag) {
                    formatted += char;
                }
            }
            
            // 最终清理
            // 删除首行的空行
            formatted = formatted.replace(/^\s*\n/, '');
            // 合并多个空行
            formatted = formatted.replace(/\n\s*\n/g, '\n');
            // 移除辅助属性
            formatted = formatted.replace(/data-important="true"/g, '');
            
            return formatted;
        }
        
        // 辅助函数：检查是否为内联元素
        function isInlineElement(tagName) {
            const inlineElements = ['a', 'abbr', 'acronym', 'b', 'bdo', 'big', 'br', 'button', 'cite', 'code', 
                                   'dfn', 'em', 'i', 'img', 'input', 'kbd', 'label', 'map', 'object', 'output', 
                                   'q', 'samp', 'script', 'select', 'small', 'span', 'strong', 'sub', 'sup', 
                                   'textarea', 'time', 'tt', 'var'];
            
            return inlineElements.includes(tagName);
        }
        
        // 辅助函数：从标签字符串中提取标签名
        function getTagName(tagString) {
            const match = tagString.match(/<\/?([a-z][a-z0-9]*)/i);
            return match ? match[1].toLowerCase() : '';
        }
        
        // 格式化HTML内容的函数
        function formatHtml() {
            try {
                const htmlContent = htmlEditor.getValue();
        
                if (!htmlContent || htmlContent.trim().length === 0) {
                    showToast('警告', '请先粘贴HTML内容', 'warning');
                    hideLoader();
                    return;
                }
                
                // 创建一个格式化后的HTML字符串
                let formattedHtml = '';
                
                try {
                    // 尝试使用更高级的格式化方法
                    formattedHtml = formatHtmlContent(htmlContent);
                } catch (err) {
                    console.error('高级格式化失败，回退到基础格式化', err);
                    
                    // 如果高级格式化失败，回退到基础格式化
                    try {
                        // 使用DOMParser解析HTML
                        const parser = new DOMParser();
                        const doc = parser.parseFromString(htmlContent, 'text/html');
                        
                        // 使用XMLSerializer重新序列化
                        const serializer = new XMLSerializer();
                        formattedHtml = serializer.serializeToString(doc);
                        
                        // 简单清理
                        formattedHtml = formattedHtml.replace(/><(?!\/)/g, '>\n<');
                    } catch (basicErr) {
                        // 如果两种方法都失败，保持原始内容
                        console.error('基础格式化失败', basicErr);
                        formattedHtml = htmlContent;
                        
                        showToast('错误', '格式化失败，HTML结构可能有问题', 'danger');
                        hideLoader();
                        return;
                    }
                }
                
                // 更新编辑器内容
                htmlEditor.setValue(formattedHtml);
                
                // 通知用户格式化完成
                hideLoader();
                showToast('成功', 'HTML已成功格式化！', 'success');
            } catch (error) {
                hideLoader();
                console.error('HTML格式化出错:', error);
                showToast('错误', '格式化HTML时出错: ' + error.message, 'danger');
            }
        }
        
        // 显示Toast消息
        function showToast(title, message, type = 'info') {
            // 创建toast容器，如果不存在
            let toastContainer = document.getElementById('toastContainer');
            if (!toastContainer) {
                toastContainer = document.createElement('div');
                toastContainer.id = 'toastContainer';
                toastContainer.className = 'toast-container position-fixed bottom-0 end-0 p-3';
                document.body.appendChild(toastContainer);
            }
            
            // 创建随机ID
            const toastId = 'toast-' + Math.random().toString(36).substr(2, 9);
            
            // 创建toast元素
            const toastHtml = `
                <div class="toast" id="${toastId}" role="alert" aria-live="assertive" aria-atomic="true">
                    <div class="toast-header bg-${type} text-white">
                        <strong class="me-auto">${title}</strong>
                        <button type="button" class="btn-close btn-close-white" data-bs-dismiss="toast" aria-label="Close"></button>
                    </div>
                    <div class="toast-body">
                        ${message}
                    </div>
                </div>
            `;
            
            // 添加toast到容器
            toastContainer.insertAdjacentHTML('beforeend', toastHtml);
            
            // 初始化并显示toast
            const toastElement = document.getElementById(toastId);
            const toast = new bootstrap.Toast(toastElement, {
                delay: 3000,
                autohide: true
            });
            
            toast.show();
            
            // 自动移除toast元素
            toastElement.addEventListener('hidden.bs.toast', function() {
                toastElement.remove();
            });
        }
        
        // 添加API健康检查函数
        function checkApiHealth() {
            // 先关闭可能已经存在的模态窗口实例，确保清理所有背景遮罩
            const existingModal = bootstrap.Modal.getInstance(document.getElementById('apiHealthModal'));
            if (existingModal) {
                existingModal.hide();
                
                // 强制清除所有可能的遮罩层
                document.querySelectorAll('.modal-backdrop').forEach(backdrop => {
                    backdrop.remove();
                });
                document.body.classList.remove('modal-open');
                document.body.style.overflow = '';
                document.body.style.paddingRight = '';
            }
            
            // 延迟一点再显示新的模态窗口，确保上一个完全关闭
            setTimeout(() => {
                const modal = new bootstrap.Modal(document.getElementById('apiHealthModal'));
                modal.show();
                
                // 定义API端点
            const endpoints = [
                { name: 'API信息', url: '/api-info', method: 'GET' },
                { name: '源类型列表', url: '/api/source-test/source-types', method: 'GET' },
                    // 标记为可选的有问题的端点
                    { name: '测试源示例', url: '/api/source-test/test-source/test', method: 'GET', optional: true },
                    { name: '创建源端点', url: '/api/source-test/create-custom-source', method: 'POST', optional: true }
                ];
                
                // 清空结果表格
                document.getElementById('apiHealthTable').innerHTML = `
                        <tr>
                            <th>端点名称</th>
                            <th>URL</th>
                            <th>状态</th>
                            <th>响应时间</th>
                            <th>操作</th>
                        </tr>
                `;
                
                // 创建一个函数来检查单个端点
                async function checkEndpoint(endpoint) {
            const startTime = performance.now();
                    try {
                        // 根据请求方法发送不同的请求
            const options = {
                            method: endpoint.method,
                            headers: {
                                'Accept': 'application/json'
                            }
            };
            
                        // 如果是POST请求，添加一个空的请求体
            if (endpoint.method === 'POST') {
                            options.body = JSON.stringify({});
                            options.headers['Content-Type'] = 'application/json';
                        }
                        
                        const response = await fetch(endpoint.url, options);
                    const endTime = performance.now();
                    const responseTime = (endTime - startTime).toFixed(2);
                        
                        // 更新表格
                        const statusClass = response.ok ? 'bg-success' : 'bg-danger';
                        const statusText = response.ok ? '可用' : (endpoint.optional ? '可选' : '错误 ' + response.status);
                        const rowClass = response.ok ? '' : (endpoint.optional ? 'table-warning' : 'table-danger');
                        
                        const row = document.createElement('tr');
                        row.className = rowClass;
                        row.innerHTML = `
                            <td>${endpoint.name}</td>
                            <td>${endpoint.url}</td>
                            <td><span class="badge ${response.ok ? 'bg-success' : (endpoint.optional ? 'bg-warning' : 'bg-danger')}">${statusText}</span></td>
                            <td>${responseTime} ms</td>
                            <td><button class="btn btn-sm btn-primary" onclick="showEndpointDetails(${JSON.stringify(endpoint).replace(/"/g, '&quot;')}, ${response.ok ? 'null' : 'new Error(\''+response.status+' '+response.statusText+'\')'}, ${responseTime})">详情</button></td>
                        `;
                        document.getElementById('apiHealthTable').appendChild(row);
                        
                        // 如果请求成功，获取响应内容并显示详情
                        if (response.ok) {
                            showEndpointDetails(endpoint, response, responseTime);
                        }
                        
                        return { success: response.ok, status: response.status, statusText: response.statusText };
                    } catch (error) {
                        console.error(`检查端点 ${endpoint.url} 时出错:`, error);
                    const endTime = performance.now();
                    const responseTime = (endTime - startTime).toFixed(2);
                        
                        // 更新表格
                        const row = document.createElement('tr');
                        row.className = endpoint.optional ? 'table-warning' : 'table-danger';
                        row.innerHTML = `
                            <td>${endpoint.name}</td>
                            <td>${endpoint.url}</td>
                            <td><span class="badge ${endpoint.optional ? 'bg-warning' : 'bg-danger'}">${endpoint.optional ? '可选' : '错误'}</span></td>
                            <td>${responseTime} ms</td>
                            <td><button class="btn btn-sm btn-primary" onclick="showEndpointDetails(${JSON.stringify(endpoint).replace(/"/g, '&quot;')}, new Error('${error.message}'), ${responseTime})">详情</button></td>
                        `;
                        document.getElementById('apiHealthTable').appendChild(row);
                        
                        return { success: false, error: error.message };
                    }
                }
                
                // 检查所有端点
                Promise.all(endpoints.map(checkEndpoint))
                    .then(results => {
                        // 计算API健康状态
                        const successCount = results.filter(r => r.success).length;
                        const requiredEndpoints = endpoints.filter(e => !e.optional).length;
                        const requiredSuccessCount = results.filter((r, i) => r.success && !endpoints[i].optional).length;
                    
                    // 更新状态
                        const healthPercentage = requiredEndpoints > 0 ? 
                            Math.round((requiredSuccessCount / requiredEndpoints) * 100) : 100;
                        
                        document.getElementById('apiHealthStatus').innerHTML = `
                            <div class="d-flex align-items-center">
                                <div class="progress flex-grow-1 me-3" style="height: 20px;">
                                    <div class="progress-bar ${healthPercentage >= 70 ? 'bg-success' : healthPercentage >= 40 ? 'bg-warning' : 'bg-danger'}" 
                                        role="progressbar" style="width: ${healthPercentage}%;" 
                                        aria-valuenow="${healthPercentage}" aria-valuemin="0" aria-valuemax="100">
                                        ${healthPercentage}%
                                    </div>
                                </div>
                                <span class="badge ${healthPercentage >= 70 ? 'bg-success' : healthPercentage >= 40 ? 'bg-warning' : 'bg-danger'}">
                                    ${healthPercentage >= 70 ? '健康' : healthPercentage >= 40 ? '不稳定' : '不健康'}
                                </span>
                            </div>
                        `;
                    });
            }, 100); // 短暂延迟以确保先前的模态窗口完全关闭
        }
        
        function showEndpointDetails(endpoint, response, responseTime) {
            const detailsContainer = document.getElementById('apiCheckDetails');
            
            // 将响应克隆一份，因为response.text()只能消费一次
            response.text().then(text => {
                let formattedContent = '<pre>无内容</pre>';
                
                try {
                    // 尝试解析为JSON
                    if (text.trim() && !endpoint.skipContent) {
                        const json = JSON.parse(text);
                        formattedContent = `<pre class="bg-dark text-light p-2">${JSON.stringify(json, null, 2)}</pre>`;
                    } else if (text.trim() && !endpoint.skipContent) {
                        formattedContent = `<pre class="bg-dark text-light p-2">${text}</pre>`;
                    }
                } catch (e) {
                    // 如果不是JSON，则显示原始文本
                    if (text.trim() && !endpoint.skipContent) {
                        formattedContent = `<pre class="bg-dark text-light p-2">${text}</pre>`;
                    }
                }
                
                // 获取响应头
                const headers = Array.from(response.headers.entries())
                    .map(([key, value]) => `<tr><td><strong>${key}</strong></td><td>${value}</td></tr>`)
                    .join('');
                
                detailsContainer.innerHTML = `
                    <div class="card">
                        <div class="card-header d-flex justify-content-between align-items-center">
                            <h5 class="mb-0">端点详情: ${endpoint.url}</h5>
                            <span class="badge ${response.ok ? 'bg-success' : 'bg-danger'}">
                                ${response.status} ${response.statusText}
                            </span>
                        </div>
                        <div class="card-body">
                            <p><strong>请求方法:</strong> ${endpoint.method}</p>
                            <p><strong>响应时间:</strong> ${responseTime} ms</p>
                            
                            <h6>响应头:</h6>
                            <div class="table-responsive" style="max-height: 200px; overflow-y: auto;">
                                <table class="table table-sm table-striped">
                                    <tbody>
                                        ${headers}
                                    </tbody>
                                </table>
                            </div>
                            
                            ${!endpoint.skipContent ? `
                                <h6 class="mt-3">响应内容:</h6>
                                <div style="max-height: 300px; overflow-y: auto;">
                                    ${formattedContent}
                                </div>
                            ` : '<p>响应内容已跳过</p>'}
                        </div>
                    </div>
                `;
            });
        }
        
        function handleAuthError(error, callback) {
            console.error('认证错误:', error);
            
            // 显示通知
            const toast = new bootstrap.Toast(document.getElementById('notificationToast'));
            document.getElementById('toastMessage').textContent = `需要认证: ${error.message}`;
            document.getElementById('notificationToast').classList.add('bg-warning', 'text-dark');
            toast.show();
            
            // 5秒后恢复原来的样式
            setTimeout(() => {
                document.getElementById('notificationToast').classList.remove('bg-warning', 'text-dark');
            }, 5000);
            
            // 保存回调，以便成功后调用
            window.authCallback = callback;
            
            // 显示认证模态框
            new bootstrap.Modal(document.getElementById('authModal')).show();
            
            return false; // 阻止事件冒泡
        }
        
        // 辅助函数：分析容器元素
        function analyzeContainers(htmlDoc) {
            const containerCandidates = [];
            
            // 尝试查找可能的新闻容器
            const possibleContainerSelectors = [
                // ID选择器 - 优先级高
                '#immeList', '#newslist', '#news', '#content', '#main', 
                '#newsList', '#articleList', '#article-list', '#news-container',
                
                // 具有特定ID模式的元素
                '[id*="news"]', '[id*="article"]', '[id*="list"]', '[id*="content"]',
                
                // 常见类选择器
                '.liveNews', '.newsBox', '.newsList', '.newsContainer', '.news-list',
                '.news-container', '.article-list', '.article-container', '.content-list',
                '.m_news', '.ntb', '.jd', '.jar', '.clearfix',
                
                // 具有特定类名模式的元素
                '[class*="news"]', '[class*="article"]', '[class*="list"]', 
                '[class*="content"]', '[class*="container"]'
            ];
            
            // 对每个选择器计算一个权重分数
            possibleContainerSelectors.forEach(selector => {
                try {
                    const elements = htmlDoc.querySelectorAll(selector);
                    
                    elements.forEach(element => {
                        if (element) {
                            // 初始权重
                            let weight = 0;
                            
                            // 容器直接子元素数量
                            const childCount = element.children.length;
                            if (childCount >= 3) weight += 10;  // 有多个子元素的容器可能性更大
                            if (childCount >= 10) weight += 15; // 有大量子元素的容器更可能是新闻列表
                            
                            // 检查容器是否包含列表项或类似结构
                            const liItems = element.querySelectorAll('li');
                            if (liItems.length >= 3) weight += 20;
                            
                            const dlItems = element.querySelectorAll('dl');
                            if (dlItems.length >= 3) weight += 20;
                            
                            const articles = element.querySelectorAll('article');
                            if (articles.length >= 3) weight += 25;
                            
                            // 检查子元素是否包含链接
                            const linkItems = element.querySelectorAll('a[href]');
                            if (linkItems.length >= 5) weight += 15;
                            
                            // 检查是否有重复模式子元素（同类标签的一级子元素）
                            const childTags = {};
                            Array.from(element.children).forEach(child => {
                                const tag = child.tagName.toLowerCase();
                                childTags[tag] = (childTags[tag] || 0) + 1;
                            });
                            
                            // 如果有3个以上相同标签的子元素，额外加分
                            Object.values(childTags).forEach(count => {
                                if (count >= 3) weight += 15;
                                if (count >= 10) weight += 10;
                            });
                            
                            // 优先考虑ID选择器
                            if (selector.startsWith('#')) weight += 30;
                            
                            // 如果是已知的新闻网站特殊容器，提高权重
                            if (['#immeList', '.ntb', '.m_news', '#toutiao'].includes(selector)) {
                                weight += 50;
                            }
                            
                            // 创建精确的选择器
                            let refinedSelector = selector;
                            // 如果初始选择器是类型选择器，尝试构建更精确的选择器
                            if (!selector.startsWith('#') && !selector.startsWith('.') && element.id) {
                                refinedSelector = `#${element.id}`;
                                weight += 20; // 优先考虑ID
                            } else if (!selector.startsWith('#') && element.className && element.className.trim()) {
                                refinedSelector = `.${element.className.trim().replace(/\s+/g, '.')}`;
                            }
                            
                            // 将候选项添加到结果中
                            containerCandidates.push({
                                selector: refinedSelector,
                                weight: weight,
                                childCount: childCount,
                                element: element
                            });
                        }
                    });
                } catch (e) {
                    console.error(`检查容器选择器 ${selector} 时出错:`, e);
                }
            });
            
            // 去重
            const uniqueCandidates = [];
            const seenSelectors = new Set();
            
            containerCandidates.forEach(candidate => {
                if (!seenSelectors.has(candidate.selector)) {
                    seenSelectors.add(candidate.selector);
                    uniqueCandidates.push(candidate);
                }
            });
            
            // 按权重排序
            return uniqueCandidates.sort((a, b) => b.weight - a.weight);
        }
        
        // 辅助函数：分析列表项
        function analyzeListItems(containerElement, containerSelector) {
            const itemCandidates = [];
            
            // 1. 检查常见的列表项模式
            const possibleItemSelectors = [
                // 标准HTML列表
                'ul > li', 'ol > li',  // 移除单独的'li'选择器，改用更具体的选择器
                
                // 通用的新闻列表项
                '.item', '.news-item', '.article', '.post', '.entry',
                
                // 定义列表
                'dl', 'dt', 'dd',
                
                // 常见的文章/新闻容器
                'article', '.article', '.news', '.post', 
                
                // 通用的网格/卡片布局
                '.card', '.cell', '.grid-item', '.box', '.block',
                
                // 含有特殊类名的元素
                '[class*="item"]', '[class*="article"]', '[class*="news"]',
                
                // 特定网站类
                '.jd > li', '.jar > li', '.ntb > li'
            ];
            
            // 添加容器子元素的直接选择器
            const directChildSelectors = [];
            const childTypes = new Map();
            
            // 遍历直接子元素并计数
            Array.from(containerElement.children).forEach(child => {
                const tagName = child.tagName.toLowerCase();
                if (!childTypes.has(tagName)) {
                    childTypes.set(tagName, 1);
                } else {
                    childTypes.set(tagName, childTypes.get(tagName) + 1);
                }
            });
            
            // 查找重复出现的子元素，这很可能是列表项
            childTypes.forEach((count, tagName) => {
                if (count >= 3) {
                    // 创建子元素的简单选择器 - 移除开头的 '>'
                    const simpleSelector = `${tagName}`;  // 改为仅使用标签名
                    
                    // 添加到候选列表
                    directChildSelectors.push(simpleSelector);
                    
                    // 检查是否有特定类名
                    const elementsWithClass = Array.from(containerElement.children)
                        .filter(el => el.tagName.toLowerCase() === tagName && el.className);
                    
                    // 如果多个元素有相同的类名，这可能是一个更精确的选择器
                    if (elementsWithClass.length >= 3) {
                        const classes = new Map();
                        
                        elementsWithClass.forEach(el => {
                            el.classList.forEach(className => {
                                if (!classes.has(className)) {
                                    classes.set(className, 1);
                                } else {
                                    classes.set(className, classes.get(className) + 1);
                                }
                            });
                        });
                        
                        // 查找出现在多个元素上的类名
                        classes.forEach((count, className) => {
                            if (count >= 3) {
                                directChildSelectors.push(`${tagName}.${className}`);  // 使用标签名.类名格式
                            }
                        });
                    }
                }
            });
            
            // 合并通用选择器和直接子元素选择器
            const allSelectors = [...possibleItemSelectors, ...directChildSelectors];
            
            // 对每个选择器评估分数
            allSelectors.forEach(selector => {
                try {
                    // 验证和修复选择器语法
                    let validSelector = selector;
                    try {
                        // 简单验证选择器语法
                        document.createElement('div').querySelector(validSelector);
                    } catch (syntaxError) {
                        console.error(`无效的选择器语法: ${selector}，尝试修复...`);
                        
                        // 修复常见的选择器问题
                        if (selector === 'li') {
                            validSelector = 'ul > li, ol > li, dl > li';
                            console.log(`将'li'选择器修正为: ${validSelector}`);
                        } else if (selector.includes('>') && !selector.includes(' > ')) {
                            validSelector = selector.replace(/>/g, ' > ');
                            console.log(`修正选择器空格: ${selector} -> ${validSelector}`);
                        }
                        
                        // 再次验证修复后的选择器
                        try {
                            document.createElement('div').querySelector(validSelector);
                        } catch (e) {
                            console.error(`无法修复选择器 ${selector}, 跳过此选择器`);
                            return; // 跳过此选择器
                        }
                    }
                    
                    // 构建完整选择器
                    const fullSelector = containerSelector ? 
                        `${containerSelector} ${validSelector}` : validSelector;
                    
                    // 查找匹配的元素
                    let items;
                    try {
                        items = containerElement.querySelectorAll(validSelector);
                    } catch (queryError) {
                        console.error(`执行querySelectorAll失败，选择器: ${validSelector}，错误: ${queryError.message}`);
                        return; // 跳过此选择器
                    }
                    
                    if (items.length >= 3) {
                        // 初始分数
                        let score = 0;
                        
                        // 项目数量得分
                        score += Math.min(items.length, 30) * 2;
                        
                        // 检查项目是否包含链接 - 新闻列表通常包含链接
                        let linkCount = 0;
                        items.forEach(item => {
                            if (item.querySelector('a')) linkCount++;
                        });
                        
                        // 如果大多数项目包含链接，增加分数
                        if (linkCount / items.length > 0.7) score += 30;
                        
                        // 检查相似性 - 新闻列表项通常有类似的结构
                        const structuralSimilarity = checkItemSimilarity(items);
                        score += structuralSimilarity * 20;
                        
                        // 优先考虑直接子元素
                        if (directChildSelectors.includes(selector)) score += 20;
                        
                        // 优先考虑带有类名的选择器
                        if (selector.includes('.')) score += 15;
                        
                        // 如果是特定网站专用选择器，给予高分
                        if (['.jd > li', '.jar > li', '.ntb > li'].includes(selector)) score += 50;
                        
                        // 添加到候选项
                        itemCandidates.push({
                            selector: fullSelector,
                            count: items.length,
                            score: score,
                            similarity: structuralSimilarity
                        });
                    }
                } catch (e) {
                    console.error(`分析列表项选择器 ${selector} 时出错:`, e);
                }
            });
            
            // 按分数排序
            return itemCandidates.sort((a, b) => b.score - a.score);
        }
        
        // 辅助函数：检查项目的结构相似性
        function checkItemSimilarity(items) {
            if (items.length < 3) return 0;
            
            // 只取前10个项目做相似性分析
            const sampleItems = Array.from(items).slice(0, Math.min(10, items.length));
            
            // 检查HTML结构相似性（简化版）
            const structures = sampleItems.map(item => {
                return {
                    hasLink: !!item.querySelector('a'),
                    hasImg: !!item.querySelector('img'),
                    hasParagraph: !!item.querySelector('p'),
                    hasHeading: !!item.querySelector('h1, h2, h3, h4, h5, h6'),
                    hasSpan: !!item.querySelector('span'),
                    hasTime: !!item.querySelector('time'),
                    childrenCount: item.children.length,
                    textLength: item.textContent.trim().length
                };
            });
            
            // 计算属性的一致性
            const consistencies = {};
            ['hasLink', 'hasImg', 'hasParagraph', 'hasHeading', 'hasSpan', 'hasTime'].forEach(prop => {
                const trueCount = structures.filter(s => s[prop]).length;
                consistencies[prop] = Math.max(trueCount, structures.length - trueCount) / structures.length;
            });
            
            // 计算子元素数量一致性（简化）
            const childrenCounts = structures.map(s => s.childrenCount);
            const avgChildren = childrenCounts.reduce((a, b) => a + b, 0) / childrenCounts.length;
            const childrenDeviation = childrenCounts.map(c => Math.abs(c - avgChildren)).reduce((a, b) => a + b, 0) / childrenCounts.length;
            const childrenConsistency = 1 - (childrenDeviation / (avgChildren || 1));
            
            // 计算文本长度一致性（简化）
            const textLengths = structures.map(s => s.textLength);
            const avgTextLength = textLengths.reduce((a, b) => a + b, 0) / textLengths.length;
            const textLengthDeviation = textLengths.map(l => Math.abs(l - avgTextLength)).reduce((a, b) => a + b, 0) / textLengths.length;
            const textLengthConsistency = 1 - (textLengthDeviation / (avgTextLength || 1));
            
            // 计算总体一致性分数（0-1范围）
            const weights = {
                hasLink: 0.3,
                hasImg: 0.1,
                hasParagraph: 0.1,
                hasHeading: 0.1,
                hasSpan: 0.1,
                hasTime: 0.1,
                childrenConsistency: 0.1,
                textLengthConsistency: 0.1
            };
            
            let totalScore = 0;
            Object.keys(consistencies).forEach(prop => {
                totalScore += consistencies[prop] * weights[prop];
            });
            
            totalScore += childrenConsistency * weights.childrenConsistency;
            totalScore += textLengthConsistency * weights.textLengthConsistency;
            
            return Math.min(1, Math.max(0, totalScore));
        }
        
        // 辅助函数：安全的querySelector，带有选择器验证
        function safeQuerySelector(element, selector, isAll = false) {
            if (!element || !selector) return isAll ? [] : null;
            
            // 预处理以 '>' 开头的选择器
            let processedSelector = selector;
            if (selector.trim().startsWith('>')) {
                // 去掉开头的 '>'，因为它需要前面有元素才有效
                processedSelector = selector.trim().substring(1).trim();
                console.log(`修正以'>'开头的选择器: ${selector} -> ${processedSelector}`);
                
                // 如果处理后的选择器为空，返回空结果
                if (!processedSelector.trim()) {
                    return isAll ? [] : null;
                }
            }
            
            try {
                // 验证选择器
                document.createElement('div').querySelector(processedSelector);
                
                // 执行查询
                return isAll ? element.querySelectorAll(processedSelector) : element.querySelector(processedSelector);
            } catch (e) {
                console.error(`选择器语法错误: ${processedSelector}，尝试修复...`);
                
                // 尝试修复常见的选择器错误
                let fixedSelector = processedSelector;
                
                if (processedSelector === 'li') {
                    fixedSelector = 'ul > li, ol > li, dl > li';
                    console.log(`修复选择器: ${processedSelector} -> ${fixedSelector}`);
                } else if (processedSelector.includes('>') && !processedSelector.includes(' > ')) {
                    fixedSelector = processedSelector.replace(/>/g, ' > ');
                    console.log(`修复选择器: ${processedSelector} -> ${fixedSelector}`);
                }
                
                // 再次测试修复后的选择器
                try {
                    document.createElement('div').querySelector(fixedSelector);
                    console.log(`选择器修复成功: ${fixedSelector}`);
                    return isAll ? element.querySelectorAll(fixedSelector) : element.querySelector(fixedSelector);
                } catch (fixError) {
                    console.error(`无法修复选择器: ${selector}，错误: ${fixError.message}`);
                    return isAll ? [] : null;
                }
            }
        }
        
        // 辅助函数：分析标题元素
        function analyzeTitleElement(itemElement, itemSelector) {
            const titleCandidates = [];
            console.log('======= 开始分析标题元素 =======');
            
            try {
                // 第一步：收集条目中所有的链接和标题元素
                const allLinks = safeQuerySelector(itemElement, 'a[href]', true);
                const allHeadings = safeQuerySelector(itemElement, 'h1, h2, h3, h4, h5, h6', true);
                console.log(`在条目中找到 ${allLinks.length} 个链接和 ${allHeadings.length} 个标题标签`);
                
                // 如果是和讯网，使用更具体的选择器
                try {
                    // 和讯网特定选择器
                    const hexunSelectors = [
                        // 和讯财经网常用选择器
                        '.ntb > li > a',
                        '.ntb li > a',
                        'li > span > a',
                        '.title > a',
                        '.list li > a',
                        '.immeList li > a'
                    ];
                    
                    for (const selector of hexunSelectors) {
                        try {
                            const elements = safeQuerySelector(itemElement, selector, true);
                            if (elements.length > 0) {
                                console.log(`找到和讯网特定选择器 "${selector}" 匹配的元素: ${elements.length} 个`);
                                
                                // 检查这些元素是否包含较长的文本（可能是标题）
                                for (let i = 0; i < elements.length; i++) {
                                    const element = elements[i];
                                    const text = element.textContent.trim();
                                    const textLength = text.length;
                                    
                                    if (textLength > 10) {  // 标题通常超过10个字符
                                        const selector = buildElementSelector(element, itemElement);
                                        titleCandidates.push({
                                            element: element,
                                            text: text,
                                            selector: selector,
                                            textLength: textLength,
                                            isLink: element.tagName.toLowerCase() === 'a',
                                            score: 85 + Math.min(textLength, 30),  // 较长的文本得分更高
                                            href: element.getAttribute('href') || ''
                                        });
                                        
                                        console.log(`添加和讯网特定候选标题: "${text}", 长度: ${textLength}, 分数: ${85 + Math.min(textLength, 30)}`);
                                    }
                                }
                            }
                        } catch (e) {
                            console.error(`检查和讯网选择器 ${selector} 时出错:`, e);
                        }
                    }
                } catch (e) {
                    console.error('尝试和讯网特定选择器时出错:', e);
                }
                
                // 第二步：查找每个列表项中最长文本的链接
                if (itemElement.tagName.toLowerCase() === 'li' || itemElement.closest('li')) {
                    const li = itemElement.tagName.toLowerCase() === 'li' ? itemElement : itemElement.closest('li');
                    const linksInLi = safeQuerySelector(li, 'a[href]', true);
                    
                    if (linksInLi.length > 0) {
                        // 找出最长文本的链接
                        let maxLength = 0;
                        let longestLink = null;
                        
                        for (let i = 0; i < linksInLi.length; i++) {
                            const link = linksInLi[i];
                            const text = link.textContent.trim();
                            const textLength = text.length;
                            
                            // 排除明显不是标题的链接
                            if (
                                text.includes('更多') || 
                                text.includes('详情') ||
                                text.match(/^\d{1,2}[-:]\d{1,2}/)  // 日期/时间格式
                            ) {
                                continue;
                            }
                            
                            if (textLength > maxLength) {
                                maxLength = textLength;
                                longestLink = link;
                            }
                        }
                        
                        // 如果找到最长的链接，添加为候选项
                        if (longestLink && maxLength > 5) {
                            const selector = buildElementSelector(longestLink, itemElement);
                            titleCandidates.push({
                                element: longestLink,
                                text: longestLink.textContent.trim(),
                                selector: selector,
                                textLength: maxLength,
                                isLink: true,
                                score: 90 + Math.min(maxLength, 30),  // 列表项中最长的链接得分更高
                                href: longestLink.getAttribute('href') || ''
                            });
                            
                            console.log(`添加列表项中最长文本链接候选: "${longestLink.textContent.trim()}", 长度: ${maxLength}, 分数: ${90 + Math.min(maxLength, 30)}`);
                        }
                    }
                }
                
                // 第三步：分析所有链接，特别关注文本长度
                for (let i = 0; i < allLinks.length; i++) {
                    const link = allLinks[i];
                    const text = link.textContent.trim();
                    const textLength = text.length;
                    
                    // 排除明显不是标题的链接
                    if (
                        text.includes('更多') || 
                        text.includes('详情') ||
                        text.length < 5 ||
                        text.match(/^\d{1,2}[-:]\d{1,2}/)  // 日期/时间格式
                    ) {
                        continue;
                    }
                    
                    // 基础分数
                    let score = 50;
                    
                    // 根据文本长度评分 - 通常标题在10-60字符之间
                    if (textLength >= 10 && textLength <= 60) {
                        score += Math.min(textLength, 30);  // 最多加30分
                    } else if (textLength > 60) {
                        score += 30 - Math.min((textLength - 60) / 10, 15);  // 过长的文本适当减分
                    } else {
                        score -= (10 - textLength) * 2;  // 太短的文本减分
                    }
                    
                    // 检查父元素 - 标题标签内的链接得分高
                    const parent = link.parentElement;
                    if (parent) {
                        const parentTag = parent.tagName.toLowerCase();
                        
                        // 标题标签内的链接
                        if (['h1', 'h2', 'h3', 'h4', 'h5', 'h6'].includes(parentTag)) {
                            score += 25;
                            console.log(`链接在标题标签(${parentTag})内 +25分`);
                        }
                        
                        // 特殊标签内的链接
                        if (['strong', 'b', 'em'].includes(parentTag)) {
                            score += 10;
                            console.log(`链接在强调标签(${parentTag})内 +10分`);
                        }
                        
                        // 特定类名的父元素
                        if (parent.className) {
                            const className = parent.className.toLowerCase();
                            if (className.includes('title') || className.includes('headline')) {
                                score += 20;
                                console.log(`链接父元素类名包含title/headline +20分`);
                            }
                        }
                    }
                    
                    // 检查链接是否在列表项内
                    const parentLi = link.closest('li');
                    if (parentLi) {
                        const linksInLi = safeQuerySelector(parentLi, 'a[href]', true);
                        
                        // 如果是列表项中唯一的链接，可能性更高
                        if (linksInLi.length === 1) {
                            score += 15;
                            console.log(`是列表项中唯一的链接 +15分`);
                        }
                        // 如果列表项中有多个链接，检查是否是第一个
                        else if (linksInLi.length > 1 && linksInLi[0] === link) {
                            score += 10;
                            console.log(`是列表项中的第一个链接 +10分`);
                        }
                    }
                    
                    // 构建选择器
                    const selector = buildElementSelector(link, itemElement);
                    
                    // 添加到候选项
                    titleCandidates.push({
                        element: link,
                        text: text,
                        selector: selector,
                        textLength: textLength,
                        isLink: true,
                        score: score,
                        href: link.getAttribute('href') || ''
                    });
                    
                    console.log(`添加链接候选: "${text.substring(0, 30)}${text.length > 30 ? '...' : ''}", 长度: ${textLength}, 分数: ${score}`);
                }
                
                // 第四步：分析标题标签
                for (let i = 0; i < allHeadings.length; i++) {
                    const heading = allHeadings[i];
                    const text = heading.textContent.trim();
                    const textLength = text.length;
                    
                    if (textLength < 5) continue;  // 跳过太短的标题
                    
                    // 标题标签自动获得高分
                    let score = 80;
                    
                    // 根据标题级别调整分数
                    const level = parseInt(heading.tagName.substring(1));
                    score += (7 - level) * 5;  // h1得分最高，h6得分最低
                    
                    // 根据文本长度调整
                    if (textLength > 10 && textLength < 100) {
                        score += Math.min(textLength / 2, 15);  // 最多加15分
                    }
                    
                    // 检查是否包含链接
                    const links = safeQuerySelector(heading, 'a', true);
                    const isLink = links.length > 0;
                    let href = '';
                    
                    if (isLink && links.length === 1) {
                        href = links[0].getAttribute('href') || '';
                    }
                    
                    // 构建选择器
                    const selector = buildElementSelector(heading, itemElement);
                    
                    // 添加到候选项
                    titleCandidates.push({
                        element: heading,
                        text: text,
                        selector: selector,
                        textLength: textLength,
                        isLink: isLink,
                        score: score,
                        href: href
                    });
                    
                    console.log(`添加标题标签候选: "${text.substring(0, 30)}${text.length > 30 ? '...' : ''}", 长度: ${textLength}, 分数: ${score}`);
                }
                
                // 按分数排序
                const sortedCandidates = titleCandidates.sort((a, b) => b.score - a.score);
                
                console.log(`找到 ${sortedCandidates.length} 个标题候选项，排序后最高分: ${sortedCandidates.length > 0 ? sortedCandidates[0].score : 0}`);
                if (sortedCandidates.length > 0) {
                    const topCandidate = sortedCandidates[0];
                    console.log(`最终选择的标题: "${topCandidate.text.substring(0, 50)}${topCandidate.text.length > 50 ? '...' : ''}", 选择器: ${topCandidate.selector}`);
                }
                console.log('======= 标题分析完成 =======');
                
                return sortedCandidates;
                
            } catch (e) {
                console.error('分析标题元素时出错:', e);
                return titleCandidates;  // 返回已收集的候选项
            }
        }
        
        // 辅助函数：分析链接元素
        function analyzeLinkElement(itemElement, itemSelector) {
            const linkCandidates = [];
            console.log('======= 开始分析链接元素 =======');
            
            try {
                // 第一步：获取标题分析结果，如果标题是链接，直接使用它作为主链接
                const titleCandidates = analyzeTitleElement(itemElement, itemSelector);
                let titleLink = null;
                
                if (titleCandidates.length > 0 && titleCandidates[0].isLink) {
                    const topTitle = titleCandidates[0];
                    console.log(`使用标题链接作为主链接: "${topTitle.text.substring(0, 30)}..."`);
                    
                    // 将标题链接添加为第一候选项，给予最高分数
                    linkCandidates.push({
                        selector: topTitle.selector,
                        href: topTitle.href || topTitle.element.getAttribute('href'),
                        text: topTitle.text,
                        score: 100, // 最高分
                        element: topTitle.element,
                        isTitleLink: true,
                        textLength: topTitle.textLength
                    });
                    
                    titleLink = topTitle.element;
                }
                
                // 第二步：收集条目中所有的链接
                const allLinks = safeQuerySelector(itemElement, 'a[href]', true);
                console.log(`在条目中找到 ${allLinks.length} 个链接`);
                
                if (allLinks.length === 0) {
                    console.log('未找到链接，无法提取链接选择器');
                    return linkCandidates; // 可能已经有标题链接
                }
                
                // 第三步：评估每个链接
                for (let i = 0; i < allLinks.length; i++) {
                    const link = allLinks[i];
                    
                    // 跳过已处理的标题链接
                    if (link === titleLink) {
                        console.log('跳过已处理的标题链接');
                        continue;
                    }
                    
                    const href = link.getAttribute('href');
                    if (!href || href === '#' || href.toLowerCase().startsWith('javascript:')) {
                        console.log(`跳过无效链接: ${href}`);
                        continue;
                    }
                    
                    const text = link.textContent.trim();
                    const textLength = text ? text.length : 0;
                    
                    // 基础分数
                    let score = 40;
                    
                    // 根据链接类型评分
                    if (href.match(/\.html?$/)) score += 15; // 链接到HTML页面
                    if (href.match(/\d{6,}/)) score += 10;   // 包含数字ID的链接
                    
                    // 和讯网特殊处理 - 同一个列表项中多个链接时
                    const parentLi = link.closest('li');
                    if (parentLi) {
                        const linksInLi = safeQuerySelector(parentLi, 'a', true);
                        
                        if (linksInLi.length > 1) {
                            // 如果标题已经是链接，并且是当前列表项中的一个，
                            // 那么其他链接可能是详情链接
                            if (titleLink && Array.from(linksInLi).includes(titleLink)) {
                                score += 5;
                                console.log(`同一列表项中与标题链接同时存在，可能是详情链接 +5分`);
                            }
                            
                            // 找出最长文本的链接
                            let maxLength = 0;
                            let longestLink = null;
                            for (let j = 0; j < linksInLi.length; j++) {
                                const l = linksInLi[j];
                                const lText = l.textContent.trim();
                                if (lText && lText.length > maxLength) {
                                    maxLength = lText.length;
                                    longestLink = l;
                                }
                            }
                            
                            // 如果当前链接是最长文本的链接，加分
                            if (link === longestLink) {
                                score += 15;
                                console.log(`列表项中最长文本的链接 +15分`);
                            }
                        }
                    }
                    
                    // 分析链接文本
                    if (text) {
                        if (text.length < 5) {
                            score -= 5; // 太短的文本，可能不是主要链接
                        } else if (text.length > 15) {
                            score += 5; // 较长的文本，可能是标题链接
                        }
                        
                        // 排除导航类链接
                        if (
                            text.includes('查看更多') || 
                            text.includes('更多') || 
                            text.includes('详情') ||
                            text.match(/^\d{1,2}[-:]\d{1,2}/) // 日期/时间格式
                        ) {
                            score -= 15;
                            console.log(`导航类链接扣分: "${text}" -15分`);
                        }
                    }
                    
                    // 检查父元素
                    const parent = link.parentElement;
                    if (parent) {
                        const parentTag = parent.tagName.toLowerCase();
                        
                        // 标题标签内的链接
                        if (['h1', 'h2', 'h3', 'h4', 'h5', 'h6'].includes(parentTag)) {
                            score += 10;
                            console.log(`链接在标题标签内 +10分`);
                        }
                        
                        // 特殊标签内的链接
                        if (['strong', 'b', 'em'].includes(parentTag)) {
                            score += 5;
                            console.log(`链接在强调标签内 +5分`);
                        }
                        
                        // 特定类名的父元素
                        if (parent.className) {
                            const className = parent.className.toLowerCase();
                            if (className.includes('title') || className.includes('headline')) {
                                score += 10;
                                console.log(`链接父元素类名包含title/headline +10分`);
                            }
                        }
                    }
                    
                    // 构建选择器
                    const selector = buildElementSelector(link, itemElement);
                    
                    // 添加到候选项
                    linkCandidates.push({
                        selector: selector,
                        href: href,
                        text: text,
                        score: score,
                        element: link,
                        isTitleLink: false,
                        textLength: textLength
                    });
                    
                    console.log(`添加链接候选: "${text ? text.substring(0, 30) + '...' : href.substring(0, 30) + '...'}", 评分: ${score}`);
                }
                
                // 按分数排序
                const sortedCandidates = linkCandidates.sort((a, b) => b.score - a.score);
                console.log(`最终选择的链接: ${sortedCandidates.length > 0 ? 
                    (sortedCandidates[0].href.substring(0, 30) + (sortedCandidates[0].href.length > 30 ? '...' : '')) : '无'}`);
                console.log('======= 链接分析完成 =======');
                return sortedCandidates;
                
            } catch (e) {
                console.error('分析链接元素时出错:', e);
                return linkCandidates; // 返回已收集的候选项
            }
        }
        
        // 辅助函数：构建元素选择器
        function buildElementSelector(element, contextElement) {
            if (!element) return '';
            
            // 尝试构建一个尽可能简洁但唯一的选择器
            let selector = '';
            let current = element;
            
            // ID选择器是最精确的
            if (element.id) {
                return `#${element.id}`;
            }
            
            // 尝试使用元素类型和类名
            if (element.className && element.className.trim()) {
                const classNames = element.className.trim().split(/\s+/);
                if (classNames.length > 0) {
                    // 使用第一个类名作为选择器
                    selector = `${element.tagName.toLowerCase()}.${classNames[0]}`;
                    
                    // 检查在上下文中是否唯一
                    if (contextElement.querySelectorAll(selector).length === 1) {
                        return selector;
                    }
                    
                    // 如果有多个类名，尝试组合以获得唯一性
                    if (classNames.length > 1) {
                        selector = `${element.tagName.toLowerCase()}.${classNames.join('.')}`;
                        if (contextElement.querySelectorAll(selector).length === 1) {
                            return selector;
                        }
                    }
                }
            }
            
            // 如果无法通过类名构建唯一选择器，尝试使用位置
            selector = element.tagName.toLowerCase();
            
            // 检查在上下文中是否唯一
            if (contextElement.querySelectorAll(selector).length === 1) {
                return selector;
            }
            
            // 如果不是唯一的，尝试使用简单路径
            let path = [];
            current = element;
            
            while (current !== contextElement && current.parentElement) {
                let tag = current.tagName.toLowerCase();
                
                // 如果有ID，使用ID并结束
                if (current.id) {
                    path.unshift(`#${current.id}`);
                    break;
                }
                
                // 如果有类名，添加第一个类
                if (current.className && current.className.trim()) {
                    const firstClass = current.className.trim().split(/\s+/)[0];
                    tag += `.${firstClass}`;
                }
                
                path.unshift(tag);
                current = current.parentElement;
                
                // 如果路径已经很长了，为避免过于复杂，提前结束
                if (path.length >= 3) break;
            }
            
            return path.join(' > ');
        }
        
        // 辅助函数：分析日期元素
        function analyzeDateElement(itemElement, titleCandidates) {
            const dateCandidates = [];
            
            // 通用日期选择器
            const commonDateSelectors = [
                '.date', '.time', '.publish-date', '.publish-time', '.post-date', '.post-time',
                '[class*="date"]', '[class*="time"]', '.timestamp', '.meta-date',
                'time', 'span.time', 'p.time', 'small', 'span small'
            ];
            
            // 遍历选择器并评估
            commonDateSelectors.forEach(selector => {
                try {
                    const elements = safeQuerySelector(itemElement, selector, true);
                    
                    elements.forEach(element => {
                        if (!element) return;
                        
                        const text = element.textContent.trim();
                        if (!text) return;
                        
                        // 排除可能是标题的元素
                        if (titleCandidates.some(title => title.element === element)) return;
                        
                        // 初始分数
                        let score = 0;
                        
                        // 检查是否有日期格式
                        if (isDateLike(text)) {
                            score += (isLikelyDateString(text) ? 50 : 20);
                            
                            // 如果包含"分钟前"、"小时前"等相对时间，增加分数
                            if (text.match(/(\d+)\s*(分钟|小时|天|周|月|年)前/)) {
                                score += 30;
                            }
                        } else {
                            // 非日期文本，减分
                            score -= 20;
                        }
                        
                        // 检查标签
                        const tagName = element.tagName.toLowerCase();
                        if (tagName === 'time') score += 30;
                        if (tagName === 'span' || tagName === 'small') score += 10;
                        
                        // 检查类名
                        if (element.className) {
                            const classLower = element.className.toLowerCase();
                            if (classLower.includes('date')) score += 25;
                            if (classLower.includes('time')) score += 25;
                            if (classLower.includes('pubdate')) score += 30;
                            if (classLower.includes('timestamp')) score += 20;
                        }
                        
                        // 构建选择器
                        let elementSelector = buildElementSelector(element, itemElement);
                        
                        // 添加到候选列表
                        dateCandidates.push({
                            selector: elementSelector,
                            text: text,
                            score: score,
                            element: element
                        });
                    });
                } catch (e) {
                    console.error(`分析日期选择器 ${selector} 时出错:`, e);
                }
            });
            
            // 特殊处理：如果没有找到日期元素，尝试分析文本节点
            if (dateCandidates.length === 0) {
                // 尝试从文本节点中找日期
                walkTextNodesForDate(itemElement, dateCandidates);
            }
            
            // 按分数排序
            return dateCandidates.sort((a, b) => b.score - a.score);
        }
        
        // 辅助函数：检查文本是否类似日期
        function isDateLike(text) {
            // 检查是否包含日期格式
            return /\d{1,4}[-\/\.年]\d{1,2}[-\/\.月]\d{1,2}/.test(text) || // 年-月-日格式
                  /\d{1,2}[-\/\.]\d{1,2}[-\/\.]\d{2,4}/.test(text) || // 日-月-年格式
                  /\d{1,2}:\d{1,2}/.test(text) || // 时:分格式
                  /\d{4}年\d{1,2}月\d{1,2}日/.test(text) || // 中文日期格式
                  /\d{2}-\d{2}\s\d{2}:\d{2}/.test(text) || // 和讯网格式 MM-DD HH:MM
                  /\d{2}-\d{2}/.test(text) || // 简单的MM-DD格式
                  /(\d+)\s*(分钟|小时|天|周|月|年)前/.test(text); // 相对时间格式，如"30分钟前"
        }
        
        // 新增：处理相对时间，将"x分钟前"、"x小时前"等格式转换为JavaScript Date对象
        function parseRelativeTime(text) {
            if (!text) return null;
            
            // 获取当前时间
            const now = new Date();
            let result = null;
            
            // 匹配"x分钟前"、"x小时前"等格式
            const minutesMatch = text.match(/(\d+)\s*分钟前/);
            if (minutesMatch) {
                const minutes = parseInt(minutesMatch[1], 10);
                result = new Date(now.getTime() - minutes * 60 * 1000);
                console.log(`解析相对时间 "${text}" 为 ${result.toISOString()}`);
                return result;
            }
            
            const hoursMatch = text.match(/(\d+)\s*小时前/);
            if (hoursMatch) {
                const hours = parseInt(hoursMatch[1], 10);
                result = new Date(now.getTime() - hours * 60 * 60 * 1000);
                console.log(`解析相对时间 "${text}" 为 ${result.toISOString()}`);
                return result;
            }
            
            const daysMatch = text.match(/(\d+)\s*天前/);
            if (daysMatch) {
                const days = parseInt(daysMatch[1], 10);
                result = new Date(now.getTime() - days * 24 * 60 * 60 * 1000);
                console.log(`解析相对时间 "${text}" 为 ${result.toISOString()}`);
                return result;
            }
            
            const weeksMatch = text.match(/(\d+)\s*周前/);
            if (weeksMatch) {
                const weeks = parseInt(weeksMatch[1], 10);
                result = new Date(now.getTime() - weeks * 7 * 24 * 60 * 60 * 1000);
                console.log(`解析相对时间 "${text}" 为 ${result.toISOString()}`);
                return result;
            }
            
            const monthsMatch = text.match(/(\d+)\s*月前/);
            if (monthsMatch) {
                const months = parseInt(monthsMatch[1], 10);
                result = new Date(now);
                result.setMonth(result.getMonth() - months);
                console.log(`解析相对时间 "${text}" 为 ${result.toISOString()}`);
                return result;
            }
            
            const yearsMatch = text.match(/(\d+)\s*年前/);
            if (yearsMatch) {
                const years = parseInt(yearsMatch[1], 10);
                result = new Date(now);
                result.setFullYear(result.getFullYear() - years);
                console.log(`解析相对时间 "${text}" 为 ${result.toISOString()}`);
                return result;
            }
            
            // 如果没有匹配到相对时间格式，返回null
            return null;
        }
        
        // 辅助函数：从文本节点中查找日期
        function walkTextNodesForDate(element, dateCandidates) {
            try {
                const textWalker = document.createTreeWalker(
                    element,
                    NodeFilter.SHOW_TEXT,
                    {
                        acceptNode: function(node) {
                            return node.textContent.trim() ? NodeFilter.FILTER_ACCEPT : NodeFilter.FILTER_REJECT;
                        }
                    },
                    false
                );
                
                let textNode;
                while (textNode = textWalker.nextNode()) {
                    const text = textNode.textContent.trim();
                    if (isDateLike(text)) {
                        // 找到包含日期的文本节点
                        const parentElement = textNode.parentElement;
                        if (!parentElement) continue;
                        
                        // 构建选择器
                        let elementSelector = buildElementSelector(parentElement, element);
                        
                        // 评分
                        let score = 20; // 基础分
                        
                        // 如果是相对时间格式，增加分数
                        if (text.match(/(\d+)\s*(分钟|小时|天|周|月|年)前/)) {
                            score += 30;
                        }
                        
                        // 添加到候选列表
                        dateCandidates.push({
                            selector: elementSelector,
                            text: text,
                            score: score,
                            element: parentElement,
                            isTextNode: true
                        });
                    }
                }
            } catch (e) {
                console.error('分析文本节点日期时出错:', e);
            }
        }
        
        // 辅助函数：分析摘要元素
        function analyzeSummaryElement(itemElement, titleCandidates, dateCandidates) {
            const summaryCandidates = [];
            
            // 通用摘要选择器
            const commonSummarySelectors = [
                'p:not(:first-child)', '.summary', '.excerpt', '.description', '.desc',
                '[class*="summary"]', '[class*="excerpt"]', '[class*="desc"]',
                '.content p:first-child', 'p.intro', '.introduction'
            ];
            
            // 遍历选择器并评估
            commonSummarySelectors.forEach(selector => {
                try {
                    const elements = safeQuerySelector(itemElement, selector, true);
                    
                    elements.forEach(element => {
                        if (!element) return;
                        
                        const text = element.textContent.trim();
                        if (!text || text.length < 10) return; // 摘要通常至少有10个字符
                        
                        // 跳过可能是标题或日期的元素
                        if (titleCandidates.some(title => title.element === element)) return;
                        if (dateCandidates.some(date => date.element === element)) return;
                        
                        // 初始分数
                        let score = 0;
                        
                        // 基于文本长度给分 - 摘要通常在30-300字符范围内
                        const textLength = text.length;
                        if (textLength >= 30 && textLength <= 300) {
                            score += 20;
                            // 理想长度范围给更高分
                            if (textLength >= 50 && textLength <= 200) score += 10;
                        } else if (textLength > 300) {
                            // 太长可能是内容而不是摘要
                            score -= (textLength - 300) / 20;
                        }
                        
                        // 检查标签
                        const tagName = element.tagName.toLowerCase();
                        if (tagName === 'p') score += 15;
                        
                        // 检查类名
                        if (element.className) {
                            const classLower = element.className.toLowerCase();
                            if (classLower.includes('summary')) score += 30;
                            if (classLower.includes('excerpt')) score += 30;
                            if (classLower.includes('desc')) score += 25;
                            if (classLower.includes('intro')) score += 20;
                        }
                        
                        // 构建选择器
                        let elementSelector = buildElementSelector(element, itemElement);
                        
                        // 添加到候选列表
                        summaryCandidates.push({
                            selector: elementSelector,
                            text: text,
                            score: score,
                            element: element
                        });
                    });
                } catch (e) {
                    console.error(`分析摘要选择器 ${selector} 时出错:`, e);
                }
            });
            
            // 按分数排序
            return summaryCandidates.sort((a, b) => b.score - a.score);
        }
        
        // 辅助函数：分析内容元素
        function analyzeContentElement(itemElement, titleCandidates, summaryCandidates, dateCandidates) {
            const contentCandidates = [];
            
            // 通用内容选择器
            const commonContentSelectors = [
                '.content', '.article-body', '.article-content', '.text', '.body',
                '[class*="content"]', '[class*="body"]', '.main-text',
                'article p', '.article p', '.post-content'
            ];
            
            // 遍历选择器并评估
            commonContentSelectors.forEach(selector => {
                try {
                    const elements = safeQuerySelector(itemElement, selector, true);
                    
                    elements.forEach(element => {
                        if (!element) return;
                        
                        const text = element.textContent.trim();
                        if (!text || text.length < 20) return; // 内容通常至少有20个字符
                        
                        // 跳过可能是标题、摘要或日期的元素
                        if (titleCandidates.some(title => title.element === element)) return;
                        if (summaryCandidates.some(summary => summary.element === element)) return;
                        if (dateCandidates.some(date => date.element === element)) return;
                        
                        // 初始分数
                        let score = 0;
                        
                        // 基于文本长度给分 - 内容通常比较长
                        const textLength = text.length;
                        if (textLength >= 100) {
                            score += 20;
                            if (textLength >= 200) score += 10;
                        }
                        
                        // 检查元素
                        const tagName = element.tagName.toLowerCase();
                        if (tagName === 'div' || tagName === 'article') score += 10;
                        
                        // 检查类名
                        if (element.className) {
                            const classLower = element.className.toLowerCase();
                            if (classLower.includes('content')) score += 25;
                            if (classLower.includes('article')) score += 20;
                            if (classLower.includes('body')) score += 20;
                            if (classLower.includes('text')) score += 15;
                        }
                        
                        // 构建选择器
                        let elementSelector = buildElementSelector(element, itemElement);
                        
                        // 添加到候选列表
                        contentCandidates.push({
                            selector: elementSelector,
                            text: text.substring(0, 100) + (text.length > 100 ? '...' : ''),
                            fullText: text,
                            score: score,
                            element: element
                        });
                    });
                } catch (e) {
                    console.error(`分析内容选择器 ${selector} 时出错:`, e);
                }
            });
            
            // 按分数排序
            return contentCandidates.sort((a, b) => b.score - a.score);
        }
        
        // 辅助函数：创建分析结果消息
        function createResultMessage(foundSelectors, htmlDoc) {
            let message = '<div class="alert alert-success">HTML分析完成！</div>';
            
            // 确定找到的条目数量
            let itemsCount = 0;
            if (foundSelectors.item && foundSelectors.item.length > 0 && foundSelectors.item[0].selector) {
                try {
                    const elements = safeQuerySelector(htmlDoc, foundSelectors.item[0].selector, true);
                    itemsCount = elements.length;
                } catch (e) {
                    console.error('计算条目数量时出错:', e);
                }
            }
            
            message += `<p>找到 ${itemsCount} 个可能的新闻条目。</p>`;
            
            // 添加自动选择的选择器
            message += '<h5>自动选择的选择器：</h5><ul>';
            
            // 容器选择器
            if (foundSelectors.container && foundSelectors.container.length > 0) {
                message += `<li>容器选择器: <code>${foundSelectors.container[0].selector}</code> <button id="test_container_btn" class="btn btn-sm btn-outline-primary ml-2">测试</button></li>`;
            } else {
                message += '<li>容器选择器: <span class="text-warning">未找到</span></li>';
            }
            
            // 条目选择器
            if (foundSelectors.item && foundSelectors.item.length > 0) {
                message += `<li>条目选择器: <code>${foundSelectors.item[0].selector}</code> (${itemsCount}个条目) <button id="test_item_btn" class="btn btn-sm btn-outline-primary ml-2">测试</button></li>`;
            } else {
                message += '<li>条目选择器: <span class="text-warning">未找到</span></li>';
            }
            
            // 标题选择器
            if (foundSelectors.title && foundSelectors.title.length > 0) {
                const topTitle = foundSelectors.title[0];
                message += `<li>标题选择器: <code>${topTitle.selector}</code> (${topTitle.isLink ? '是' : '否'}链接, 文本长度: ${topTitle.textLength}, 分数: ${topTitle.score}) <button id="test_title_btn" class="btn btn-sm btn-outline-primary ml-2">测试</button></li>`;
                
                // 添加标题示例
                if (topTitle.text) {
                    message += `<li class="ml-4">示例: ${topTitle.text}</li>`;
                }
            } else {
                message += '<li>标题选择器: <span class="text-warning">未找到</span></li>';
            }
            
            // 链接选择器
            if (foundSelectors.link && foundSelectors.link.length > 0) {
                const topLink = foundSelectors.link[0];
                message += `<li>链接选择器: <code>${topLink.selector}</code> (${topLink.isTitleLink ? '是' : '否'}标题链接, 分数: ${topLink.score}) <button id="test_link_btn" class="btn btn-sm btn-outline-primary ml-2">测试</button></li>`;
                
                // 添加链接示例
                if (topLink.href) {
                    message += `<li class="ml-4">示例: ${topLink.href}</li>`;
                }
            } else {
                message += '<li>链接选择器: <span class="text-warning">未找到</span></li>';
            }
            
            // 日期选择器
            if (foundSelectors.date && foundSelectors.date.length > 0) {
                message += `<li>日期选择器: <code>${foundSelectors.date[0].selector}</code> <button id="test_date_btn" class="btn btn-sm btn-outline-primary ml-2">测试</button></li>`;
                
                // 添加日期示例
                if (foundSelectors.date[0].text) {
                    message += `<li class="ml-4">示例: ${foundSelectors.date[0].text}</li>`;
                }
            } else {
                message += '<li>日期选择器: <span class="text-warning">未找到</span></li>';
            }
            
            // 可能的其他元素
            message += '<li>可能还有单独的摘要内容。</li>';
            message += '<li>内容可能在详情页面中，此处无法获取。</li>';
            
            message += '</ul>';
            
            // 添加表格显示标题候选项详情
            if (foundSelectors.title && foundSelectors.title.length > 0) {
                message += '<h5 class="mt-4">标题候选项详细信息（按评分排序）：</h5>';
                message += '<table class="table table-sm table-bordered">';
                message += '<thead><tr><th>选择器</th><th>文本</th><th>链接</th><th>文本长度</th><th>评分</th></tr></thead>';
                message += '<tbody>';
                
                // 最多显示前10个候选项
                const titleCandidates = foundSelectors.title.slice(0, 10);
                for (let i = 0; i < titleCandidates.length; i++) {
                    const candidate = titleCandidates[i];
                    message += `<tr>
                        <td><code>${candidate.selector}</code></td>
                        <td>${candidate.text ? candidate.text.substring(0, 30) + (candidate.text.length > 30 ? '...' : '') : ''}</td>
                        <td>${candidate.isLink ? '是' : '否'}</td>
                        <td>${candidate.textLength || 0}</td>
                        <td>${candidate.score}</td>
                    </tr>`;
                }
                
                message += '</tbody></table>';
            }
            
            // 添加表格显示链接候选项详情
            if (foundSelectors.link && foundSelectors.link.length > 0) {
                message += '<h5 class="mt-4">链接候选项详细信息（按评分排序）：</h5>';
                message += '<table class="table table-sm table-bordered">';
                message += '<thead><tr><th>选择器</th><th>链接</th><th>文本长度</th><th>是标题链接</th><th>评分</th></tr></thead>';
                message += '<tbody>';
                
                // 最多显示前10个候选项
                const linkCandidates = foundSelectors.link.slice(0, 10);
                for (let i = 0; i < linkCandidates.length; i++) {
                    const candidate = linkCandidates[i];
                    message += `<tr>
                        <td><code>${candidate.selector}</code></td>
                        <td>${candidate.href ? candidate.href.substring(0, 30) + (candidate.href.length > 30 ? '...' : '') : ''}</td>
                        <td>${candidate.textLength || 0}</td>
                        <td>${candidate.isTitleLink ? '是' : '否'}</td>
                        <td>${candidate.score}</td>
                    </tr>`;
                }
                
                message += '</tbody></table>';
            }
            
            return message;
        }
        
        // 辅助函数：测试选择器，显示匹配元素的信息
        function testSelector(type) {
            try {
                // 获取选择器
                let selector = getSelector(type);
                
                if (!selector) {
                    showToast('提示', '请先输入要测试的选择器', 'warning');
                    return;
                }
                
                // 获取HTML文档
                const htmlDoc = window.parsedHtmlDoc;
                if (!htmlDoc) {
                    showToast('提示', '请先分析HTML内容', 'warning');
                    return;
                }
                
                // 找到父元素容器
                let parentElement = htmlDoc;
                
                // 如果是测试条目选择器，先找到容器
                if (type === 'item') {
                    const containerSelector = getSelector('container');
                    if (containerSelector) {
                        try {
                            const containers = htmlDoc.querySelectorAll(containerSelector);
                            if (containers.length > 0) {
                                parentElement = containers[0];
                                console.log(`使用容器选择器 "${containerSelector}" 找到第一个容器作为上下文`);
                            }
                        } catch (e) {
                            console.error(`查找容器时出错: ${e.message}`);
                        }
                    }
                }
                
                // 如果是测试标题、链接等元素选择器，需要先获取条目元素作为上下文
                if (['title', 'link', 'date', 'summary', 'content'].includes(type)) {
                    const itemSelector = getSelector('item');
                    if (itemSelector) {
                        try {
                            // 使用条目选择器获取第一个条目作为上下文
                            const items = htmlDoc.querySelectorAll(itemSelector);
                            if (items.length > 0) {
                                parentElement = items[0];
                                console.log(`使用条目选择器 "${itemSelector}" 找到第一个条目作为上下文`);
                            }
                        } catch (e) {
                            console.error(`查找条目时出错: ${e.message}`);
                        }
                    }
                }
                
                // 查询匹配的元素
                let elements = [];
                try {
                    if (type === 'container') {
                        // 容器是在整个文档中查找的
                        elements = htmlDoc.querySelectorAll(selector);
                    } else {
                        // 其他元素在父元素(容器或条目)中查找
                        elements = parentElement.querySelectorAll(selector);
                    }
                } catch (e) {
                    throw new Error(`选择器语法错误: ${e.message}`);
                }
                
                // 创建测试结果消息
                let resultMessage = `<div class="p-3 bg-light">
                    <h5>选择器测试结果: <code>${selector}</code></h5>`;
                
                // 检查是否找到匹配元素
                if (elements.length === 0) {
                    resultMessage += `<div class="alert alert-warning">未找到匹配的元素</div>`;
                } else {
                    const maxDisplayElements = 5; // 最多显示5个元素
                    resultMessage += `<div>共找到 <strong>${elements.length}</strong> 个匹配元素。</div>`;
                    
                    // 如果是测试条目选择器，并且找到了很多元素，提供警告
                    if (type === 'item' && elements.length > 30) {
                        resultMessage += `<div class="alert alert-warning">找到的条目数量较多，请确认选择器是否正确。理想情况下，条目选择器应该只匹配新闻列表中的项目。</div>`;
                    }
                    
                    // 如果是测试标题或链接选择器，并且找到了很多元素，提供更精确的建议
                    if ((type === 'title' || type === 'link') && elements.length > 10) {
                        resultMessage += `<div class="alert alert-warning">找到的${type === 'title' ? '标题' : '链接'}元素数量较多，这可能导致不准确的结果。建议使用更精确的选择器，例如：</div>
                        <ul>
                            <li>如果所有新闻都在列表项中：<code>li > a.title</code> 或 <code>li > h3 > a</code></li>
                            <li>使用特定的类名：<code>a.news-title</code> 或 <code>.headline > a</code></li>
                            <li>限制在特定容器中：<code>.news-container a:first-child</code></li>
                        </ul>`;
                    }
                    
                    // 显示元素示例
                    resultMessage += `<h6 class="mt-3">匹配元素示例:</h6>`;
                    
                    // 根据选择器类型显示不同的信息
                    for (let i = 0; i < Math.min(elements.length, maxDisplayElements); i++) {
                        const element = elements[i];
                        const elementPath = showElementPath(element);
                        resultMessage += `<div class="card mb-2">
                            <div class="card-header bg-light">元素 ${i + 1}: <code>${elementPath}</code></div>
                            <div class="card-body">`;
                        
                        // 显示元素内容和属性
                        const text = element.textContent.trim();
                        resultMessage += `<p>文本长度: ${text.length} 字符</p>`;
                        
                        // 根据不同类型显示详细信息
                        if (type === 'title' || type === 'link') {
                            // 对于标题和链接，显示文本和URL
                            resultMessage += `<p>文本: <strong>${text}</strong></p>`;
                            
                            // 如果元素是链接或包含链接
                            const links = element.tagName.toLowerCase() === 'a' ? [element] : element.querySelectorAll('a');
                            if (links.length > 0) {
                                resultMessage += `<p>链接:</p><ul>`;
                                for (let j = 0; j < links.length; j++) {
                                    const link = links[j];
                                    const href = link.getAttribute('href') || '#';
                                    const linkText = link.textContent.trim();
                                    resultMessage += `<li><a href="${href}" target="_blank">${href}</a> (文本: "${linkText}")</li>`;
                                }
                                resultMessage += `</ul>`;
                            }
                            
                            // 检查父元素中的同级链接
                            if (element.parentElement) {
                                const siblingLinks = Array.from(element.parentElement.querySelectorAll('a')).filter(a => a !== element);
                                if (siblingLinks.length > 0) {
                                    resultMessage += `<p>同级链接:</p><ul>`;
                                    for (let j = 0; j < siblingLinks.length; j++) {
                                        const link = siblingLinks[j];
                                        const href = link.getAttribute('href') || '#';
                                        const linkText = link.textContent.trim();
                                        resultMessage += `<li><a href="${href}" target="_blank">${href}</a> (文本: "${linkText}")</li>`;
                                    }
                                    resultMessage += `</ul>`;
                                }
                            }
                        } else if (type === 'date') {
                            // 对于日期，显示文本和可能的格式
                            resultMessage += `<p>文本: <strong>${text}</strong></p>`;
                            if (text.match(/\d{4}[-\/\.]\d{1,2}[-\/\.]\d{1,2}/) || 
                                text.match(/\d{1,2}[-\/\.]\d{1,2}[-\/\.]\d{4}/) ||
                                text.match(/\d{1,2}[-\/\.]\d{1,2}/) ||
                                text.match(/\d{1,2}:\d{1,2}/)) {
                                resultMessage += `<p class="text-success">可能是日期或时间格式</p>`;
                            }
                            
                            // 新增：解析相对时间
                            const relativeTimeMatch = text.match(/(\d+)\s*(分钟|小时|天|周|月|年)前/);
                            if (relativeTimeMatch) {
                                const parsedDate = parseRelativeTime(text);
                                if (parsedDate) {
                                    // 格式化日期时间
                                    const formattedDate = parsedDate.toISOString().replace('T', ' ').substring(0, 19);
                                    resultMessage += `<p class="text-success">解析为相对时间: <strong>${formattedDate}</strong></p>`;
                                    resultMessage += `<p><small>将保存为ISO格式: ${parsedDate.toISOString()}</small></p>`;
                                }
                            }
                        } else {
                            // 对于其他类型，显示HTML内容预览
                            resultMessage += `<p>${text.length > 100 ? text.substring(0, 100) + '...' : text}</p>`;
                            
                            if (type === 'container' || type === 'item') {
                                // 显示子元素计数
                                const childElementsCount = element.children.length;
                                resultMessage += `<p>子元素数量: ${childElementsCount}</p>`;
                                
                                // 显示内部链接数量
                                const linksCount = element.querySelectorAll('a').length;
                                if (linksCount > 0) {
                                    resultMessage += `<p>内部链接数量: ${linksCount}</p>`;
                                }
                            }
                        }
                        
                        resultMessage += `</div></div>`;
                    }
                    
                    // 如果还有更多元素，显示提示
                    if (elements.length > maxDisplayElements) {
                        resultMessage += `<div class="text-muted">共有 ${elements.length} 个匹配元素，仅显示前 ${maxDisplayElements} 个</div>`;
                    }
                }
                
                resultMessage += `</div>`;
                
                // 显示结果
                const resultModalBody = document.getElementById('testResultModalBody');
                if (resultModalBody) {
                    resultModalBody.innerHTML = resultMessage;
                    
                    // 显示模态框
                    const resultModal = new bootstrap.Modal(document.getElementById('testResultModal'));
                    resultModal.show();
                } else {
                    console.error('找不到测试结果模态框');
                    showToast('错误', '找不到测试结果模态框', 'danger');
                }
                
            } catch (error) {
                console.error('测试选择器时出错:', error);
                showToast('错误', `测试选择器时出错: ${error.message}`, 'danger');
            }
        }
        
        // 辅助函数：显示元素路径
        function showElementPath(element, maxLevels = 3) {
            let path = '';
            let current = element;
            let level = 0;
            
            while (current && level < maxLevels) {
                const tag = current.tagName.toLowerCase();
                let selector = tag;
                
                // 添加ID
                if (current.id) {
                    selector += `#${current.id}`;
                }
                
                // 添加类名（最多显示2个）
                if (current.classList && current.classList.length > 0) {
                    const classes = Array.from(current.classList).slice(0, 2);
                    selector += `.${classes.join('.')}`;
                }
                
                path = path ? `${selector} > ${path}` : selector;
                current = current.parentElement;
                level++;
            }
            
            if (current) {
                path = '... > ' + path;
            }
            
            return path;
        }
        
        // 辅助函数：优化选择器
        function optimizeSelector(type, selector) {
            // 如果没有选择器，返回原样
            if (!selector) return selector;
            
            try {
                // 根据类型优化选择器
                if (type === 'title') {
                    // 对于"a"这样的通用选择器，提供更精确的版本
                    if (selector === 'a') {
                        // 获取条目选择器
                        const itemSelector = document.getElementById('item_selector').value;
                        if (itemSelector) {
                            // 尝试几种更精确的组合
                            // 例如，如果条目选择器是 '.ntb > li'，则尝试 '.ntb > li > a'
                            if (itemSelector.includes('li')) {
                                return 'li > a:first-child';
                            } else if (itemSelector.includes('.ntb')) {
                                return '.ntb li > a';
                            } else {
                                return 'a:first-child';
                            }
                        }
                    }
                } else if (type === 'link') {
                    // 类似的链接选择器优化
                    if (selector === 'a') {
                        // 如果标题选择器不是链接，尝试使用标题选择器的子元素
                        const titleSelector = document.getElementById('title_selector').value;
                        if (titleSelector && titleSelector !== 'a') {
                            return `${titleSelector} a`;
                        } else {
                            // 否则使用条目中的第一个链接
                            return 'a:first-child';
                        }
                    }
                }
                
                // 如果没有特殊优化，返回原始选择器
                return selector;
            } catch (e) {
                console.error('优化选择器时出错:', e);
                return selector;
            }
        }
        
        // 辅助函数：获取指定类型的选择器
        function getSelector(type) {
            let selector = '';
            let element = null;
            
            try {
                if (type === 'container') {
                    element = document.getElementById('containerSelector');
                } else if (type === 'item') {
                    element = document.getElementById('itemSelector');
                } else if (type === 'title') {
                    element = document.getElementById('titleSelector');
                } else if (type === 'link') {
                    element = document.getElementById('linkSelector');
                } else if (type === 'date') {
                    element = document.getElementById('dateSelector');
                } else if (type === 'summary') {
                    element = document.getElementById('summarySelector');
                } else if (type === 'content') {
                    element = document.getElementById('contentSelector');
                }
                
                // 如果元素存在，获取其值
                if (element && element.value) {
                    selector = element.value.trim();
                }
            } catch (e) {
                console.error(`获取选择器 ${type} 时出错:`, e);
            }
            
            // 优化选择器
            if (['title', 'link'].includes(type) && selector === 'a') {
                return optimizeSelector(type, selector);
            }
            
            return selector;
        }
        
        // 辅助函数：设置选择器
        function setSelector(type, value) {
            if (type === 'container') {
                document.getElementById('container_selector').value = value;
            } else if (type === 'item') {
                document.getElementById('item_selector').value = value;
            } else if (type === 'title') {
                document.getElementById('title_selector').value = value;
            } else if (type === 'link') {
                document.getElementById('link_selector').value = value;
            } else if (type === 'date') {
                document.getElementById('date_selector').value = value;
            } else if (type === 'summary') {
                document.getElementById('summary_selector').value = value;
            } else if (type === 'content') {
                document.getElementById('content_selector').value = value;
            }
        }
        
        // 辅助函数：设置选择器
        function setSelectorValue(type, value) {
            try {
                let element = null;
                
                if (type === 'container') {
                    element = document.getElementById('containerSelector');
                } else if (type === 'item') {
                    element = document.getElementById('itemSelector');
                } else if (type === 'title') {
                    element = document.getElementById('titleSelector');
                } else if (type === 'link') {
                    element = document.getElementById('linkSelector');
                } else if (type === 'date') {
                    element = document.getElementById('dateSelector');
                } else if (type === 'summary') {
                    element = document.getElementById('summarySelector');
                } else if (type === 'content') {
                    element = document.getElementById('contentSelector');
                }
                
                // 如果元素存在，设置其值
                if (element) {
                    element.value = value;
                } else {
                    console.warn(`无法找到选择器输入框: ${type}`);
                }
            } catch (e) {
                console.error(`设置选择器 ${type} 时出错:`, e);
            }
        }
        
        // 辅助函数：使用指定的选择器值进行测试
        function testSelectorWithValue(type, selectorValue) {
            try {
                // 获取HTML文档
                const htmlDoc = window.parsedHtmlDoc;
                if (!htmlDoc) {
                    showToast('提示', '请先分析HTML内容', 'warning');
                    console.error('HTML文档不存在，请先分析HTML内容');
                    return;
                }
                
                // 确保有选择器值
                if (!selectorValue) {
                    showToast('提示', `${type}选择器值为空，请检查分析结果或选择其他选择器`, 'warning');
                    console.error(`${type}选择器值为空`);
                    return;
                }
                
                console.log(`开始测试${type}选择器:`, selectorValue);
                
                // 验证选择器语法是否有效
                try {
                    // 使用createElement创建一个临时元素，测试选择器是否有效
                    document.createElement('div').querySelector(selectorValue);
                } catch (syntaxError) {
                    console.error(`选择器语法错误: ${syntaxError.message}`);
                    
                    // 尝试自动修正常见选择器错误
                    let correctedSelector = selectorValue;
                    
                    // 1. 如果只是一个简单标签名，加上通用选择器
                    if (/^[a-z]+$/i.test(selectorValue)) {
                        correctedSelector = `${selectorValue}`;
                    }
                    
                    // 2. 修正选择器中的空格问题，确保 > 周围有空格
                    correctedSelector = correctedSelector.replace(/\s*>\s*/g, ' > ');
                    
                    // 3. 检查选择器是否是纯标签名或类名
                    if (correctedSelector === 'li') {
                        correctedSelector = 'li'; // 有效但需要更具体
                    } else if (correctedSelector === '.t') {
                        correctedSelector = '.t'; // 有效类选择器
                    }
                    
                    // 再次验证修正后的选择器
                    try {
                        document.createElement('div').querySelector(correctedSelector);
                        console.log(`选择器已修正: ${selectorValue} -> ${correctedSelector}`);
                        selectorValue = correctedSelector;
                    } catch (e) {
                        // 如果仍然无效，显示错误并使用模态框提供帮助
                        let errorMessage = `
                        <div class="alert alert-danger">
                            <h5>选择器语法错误</h5>
                            <p>选择器 "<code>${selectorValue}</code>" 不是有效的CSS选择器。</p>
                            <p>常见的选择器语法:</p>
                            <ul>
                                <li><code>div</code> - 选择所有div元素</li>
                                <li><code>.className</code> - 选择所有带有className类的元素</li>
                                <li><code>#id</code> - 选择具有指定ID的元素</li>
                                <li><code>div.className</code> - 选择带有className类的div元素</li>
                                <li><code>div > span</code> - 选择div直接子元素中的span元素</li>
                                <li><code>div span</code> - 选择div内的所有span元素</li>
                            </ul>
                        </div>
                        `;
                        
                        // 显示错误消息
                        showModal('选择器语法错误', errorMessage);
                        throw syntaxError;
                    }
                }
                
                // 找到父元素容器
                let parentElement = htmlDoc;
                
                // 如果是测试条目选择器，先找到容器
                if (type === 'item') {
                    // 从分析结果中获取容器选择器
                    let containerSelector = '';
                    const containerResults = document.querySelectorAll('#resultModalBody li');
                    for (let i = 0; i < containerResults.length; i++) {
                        if (containerResults[i].textContent.includes('容器选择器:')) {
                            const codeEl = containerResults[i].querySelector('code');
                            if (codeEl) {
                                containerSelector = codeEl.textContent;
                                break;
                            }
                        }
                    }
                    
                    if (containerSelector) {
                        try {
                            const containers = htmlDoc.querySelectorAll(containerSelector);
                            if (containers.length > 0) {
                                parentElement = containers[0];
                                console.log(`使用容器选择器 "${containerSelector}" 找到第一个容器作为上下文`);
                            } else {
                                console.warn(`容器选择器 "${containerSelector}" 未找到任何元素`);
                            }
                        } catch (e) {
                            console.error(`查找容器时出错: ${e.message}`);
                        }
                    } else {
                        console.warn('未找到容器选择器，将在整个文档中查找条目');
                    }
                }
                
                // 如果是测试标题、链接等元素选择器，需要先获取条目元素作为上下文
                if (['title', 'link', 'date', 'summary', 'content'].includes(type)) {
                    // 从分析结果中获取条目选择器
                    let itemSelector = '';
                    const itemResults = document.querySelectorAll('#resultModalBody li');
                    for (let i = 0; i < itemResults.length; i++) {
                        if (itemResults[i].textContent.includes('条目选择器:')) {
                            const codeEl = itemResults[i].querySelector('code');
                            if (codeEl) {
                                itemSelector = codeEl.textContent;
                                break;
                            }
                        }
                    }
                    
                    // 如果在li中未找到，尝试从表格中获取
                    if (!itemSelector) {
                        // 尝试直接使用第一个表格行中的条目选择器值
                        const itemSelector_input = document.getElementById('itemSelector');
                        if (itemSelector_input && itemSelector_input.value) {
                            itemSelector = itemSelector_input.value;
                            console.log('从输入框获取条目选择器:', itemSelector);
                        }
                    }
                    
                    if (itemSelector) {
                        try {
                            // 使用条目选择器获取第一个条目作为上下文
                            const items = htmlDoc.querySelectorAll(itemSelector);
                            if (items.length > 0) {
                                parentElement = items[0];
                                console.log(`使用条目选择器 "${itemSelector}" 找到第一个条目作为上下文`);
                            } else {
                                console.warn(`条目选择器 "${itemSelector}" 未找到任何元素，将使用整个文档作为上下文`);
                            }
                        } catch (e) {
                            console.error(`查找条目时出错: ${e.message}`);
                        }
                    } else {
                        console.warn(`未找到条目选择器，将在整个文档中查找${type}元素`);
                    }
                }
                
                // 查询匹配的元素
                let elements = [];
                try {
                    // 检查选择器语法是否有效
                    try {
                        // 使用一个简单的检查来验证选择器语法
                        // 如果选择器无效，document.createElement会抛出异常
                        document.createElement('div').querySelector(selectorValue);
                    } catch (syntaxError) {
                        // 尝试修复常见的选择器错误
                        let correctedSelector = selectorValue;
                        
                        // 检查是否只有标签名
                        if (/^[a-z0-9]+$/i.test(selectorValue)) {
                            // 纯标签名是有效的，但可能需要更具体
                            // 针对"li"这样的纯标签选择器，尝试自动添加更多上下文
                            if (selectorValue === 'li') {
                                // 如果是测试li元素，可以尝试使用更具体的选择器如：
                                if (type === 'item') {
                                    correctedSelector = 'ul > li, ol > li, dl > li, .list > li';
                                    console.log('尝试使用更具体的li选择器:', correctedSelector);
                                }
                            } else if (selectorValue === 'a') {
                                // 如果是测试a标签，可以尝试添加更多上下文
                                correctedSelector = 'li > a, .item > a, .title > a, a[href]';
                                console.log('尝试使用更具体的a选择器:', correctedSelector);
                            }
                        }
                        // 检查是否只是一个CSS类
                        else if (/^\.[a-z0-9_-]+$/i.test(selectorValue)) {
                            // 纯类名是有效的，不需要修复
                        }
                        // 检查是否是标签名加类名，但格式不正确
                        else if (/^[a-z0-9]+\.[a-z0-9_-]+$/i.test(selectorValue)) {
                            // 正确的格式，不需要修复
                        }
                        // 检查是否是不完整的复杂选择器
                        else if (selectorValue.includes('>')) {
                            // 检查是否缺少空格
                            if (selectorValue.includes('>') && !selectorValue.includes(' > ')) {
                                // 修复空格问题
                                correctedSelector = selectorValue.replace(/>/g, ' > ');
                            }
                        }
                        
                        if (correctedSelector !== selectorValue) {
                            console.log(`尝试修复选择器: "${selectorValue}" -> "${correctedSelector}"`);
                            selectorValue = correctedSelector;
                        } else {
                            // 如果无法自动修复，则抛出原始错误
                            throw syntaxError;
                        }
                    }
                    
                    if (type === 'container') {
                        // 容器是在整个文档中查找的
                        elements = htmlDoc.querySelectorAll(selectorValue);
                        console.log(`在整个文档中查找容器，找到 ${elements.length} 个`);
                    } else {
                        // 其他元素在父元素(容器或条目)中查找
                        elements = parentElement.querySelectorAll(selectorValue);
                        console.log(`在父元素中查找${type}，找到 ${elements.length} 个`);
                    }
                } catch (e) {
                    // 选择器语法错误，提供更友好的错误信息
                    let errorMessage = `选择器语法错误: ${e.message}`;
                    console.error(errorMessage);
                    
                    // 显示错误信息的模态框
                    let errorModal = `<div class="alert alert-danger">
                        <h5>选择器语法错误</h5>
                        <p>${errorMessage}</p>
                        <hr>
                        <h6>常见选择器语法:</h6>
                        <ul>
                            <li><code>div</code> - 选择所有 div 元素</li>
                            <li><code>.class-name</code> - 选择所有带有 class="class-name" 的元素</li>
                            <li><code>#id-name</code> - 选择 id="id-name" 的元素</li>
                            <li><code>div.class-name</code> - 选择所有带有 class="class-name" 的 div 元素</li>
                            <li><code>div > a</code> - 选择作为 div 直接子元素的所有 a 元素</li>
                        </ul>
                    </div>`;
                    
                    showModal('选择器错误', errorModal);
                    return;
                }
                
                // 创建测试结果消息
                let resultMessage = `<div class="p-3 bg-light">
                    <h5>选择器测试结果: <code>${selectorValue}</code></h5>`;
                
                // 检查是否找到匹配元素
                if (elements.length === 0) {
                    resultMessage += `<div class="alert alert-warning">未找到匹配的元素</div>`;
                } else {
                    const maxDisplayElements = 5; // 最多显示5个元素
                    resultMessage += `<div>共找到 <strong>${elements.length}</strong> 个匹配元素。</div>`;
                    
                    // 如果是测试条目选择器，并且找到了很多元素，提供警告
                    if (type === 'item' && elements.length > 30) {
                        resultMessage += `<div class="alert alert-warning">找到的条目数量较多，请确认选择器是否正确。理想情况下，条目选择器应该只匹配新闻列表中的项目。</div>`;
                    }
                    
                    // 如果是测试标题或链接选择器，并且找到了很多元素，提供更精确的建议
                    if ((type === 'title' || type === 'link') && elements.length > 10) {
                        resultMessage += `<div class="alert alert-warning">找到的${type === 'title' ? '标题' : '链接'}元素数量较多，这可能导致不准确的结果。建议使用更精确的选择器，例如：</div>
                        <ul>
                            <li>如果所有新闻都在列表项中：<code>li > a.title</code> 或 <code>li > h3 > a</code></li>
                            <li>使用特定的类名：<code>a.news-title</code> 或 <code>.headline > a</code></li>
                            <li>限制在特定容器中：<code>.news-container a:first-child</code></li>
                        </ul>`;
                    }
                    
                    // 显示元素示例
                    resultMessage += `<h6 class="mt-3">匹配元素示例:</h6>`;
                    
                    // 根据选择器类型显示不同的信息
                    for (let i = 0; i < Math.min(elements.length, maxDisplayElements); i++) {
                        const element = elements[i];
                        const elementPath = showElementPath(element);
                        resultMessage += `<div class="card mb-2">
                            <div class="card-header bg-light">元素 ${i + 1}: <code>${elementPath}</code></div>
                            <div class="card-body">`;
                        
                        // 显示元素内容和属性
                        const text = element.textContent.trim();
                        resultMessage += `<p>文本长度: ${text.length} 字符</p>`;
                        
                        // 根据不同类型显示详细信息
                        if (type === 'title' || type === 'link') {
                            // 对于标题和链接，显示文本和URL
                            resultMessage += `<p>文本: <strong>${text}</strong></p>`;
                            
                            // 如果元素是链接或包含链接
                            const links = element.tagName.toLowerCase() === 'a' ? [element] : element.querySelectorAll('a');
                            if (links.length > 0) {
                                resultMessage += `<p>链接:</p><ul>`;
                                for (let j = 0; j < links.length; j++) {
                                    const link = links[j];
                                    const href = link.getAttribute('href') || '#';
                                    const linkText = link.textContent.trim();
                                    resultMessage += `<li><a href="${href}" target="_blank">${href}</a> (文本: "${linkText}")</li>`;
                                }
                                resultMessage += `</ul>`;
                            }
                            
                            // 检查父元素中的同级链接
                            if (element.parentElement) {
                                const siblingLinks = Array.from(element.parentElement.querySelectorAll('a')).filter(a => a !== element);
                                if (siblingLinks.length > 0) {
                                    resultMessage += `<p>同级链接:</p><ul>`;
                                    for (let j = 0; j < siblingLinks.length; j++) {
                                        const link = siblingLinks[j];
                                        const href = link.getAttribute('href') || '#';
                                        const linkText = link.textContent.trim();
                                        resultMessage += `<li><a href="${href}" target="_blank">${href}</a> (文本: "${linkText}")</li>`;
                                    }
                                    resultMessage += `</ul>`;
                                }
                            }
                        } else if (type === 'date') {
                            // 对于日期，显示文本和可能的格式
                            resultMessage += `<p>文本: <strong>${text}</strong></p>`;
                            if (text.match(/\d{4}[-\/\.]\d{1,2}[-\/\.]\d{1,2}/) || 
                                text.match(/\d{1,2}[-\/\.]\d{1,2}[-\/\.]\d{4}/) ||
                                text.match(/\d{1,2}[-\/\.]\d{1,2}/) ||
                                text.match(/\d{1,2}:\d{1,2}/)) {
                                resultMessage += `<p class="text-success">可能是日期或时间格式</p>`;
                            }
                            
                            // 新增：解析相对时间
                            const relativeTimeMatch = text.match(/(\d+)\s*(分钟|小时|天|周|月|年)前/);
                            if (relativeTimeMatch) {
                                const parsedDate = parseRelativeTime(text);
                                if (parsedDate) {
                                    // 格式化日期时间
                                    const formattedDate = parsedDate.toISOString().replace('T', ' ').substring(0, 19);
                                    resultMessage += `<p class="text-success">解析为相对时间: <strong>${formattedDate}</strong></p>`;
                                    resultMessage += `<p><small>将保存为ISO格式: ${parsedDate.toISOString()}</small></p>`;
                                }
                            }
                        } else {
                            // 对于其他类型，显示HTML内容预览
                            resultMessage += `<p>${text.length > 100 ? text.substring(0, 100) + '...' : text}</p>`;
                            
                            if (type === 'container' || type === 'item') {
                                // 显示容器或条目中的第一个链接和标题
                                const firstLink = element.querySelector('a');
                                const firstHeading = element.querySelector('h1, h2, h3, h4, h5, h6');
                                
                                if (firstLink) {
                                    const href = firstLink.getAttribute('href') || '#';
                                    const linkText = firstLink.textContent.trim();
                                    resultMessage += `<p>第一个链接: <a href="${href}" target="_blank">${href}</a> (文本: "${linkText}")</p>`;
                                }
                                
                                if (firstHeading) {
                                    resultMessage += `<p>第一个标题: ${firstHeading.textContent.trim()}</p>`;
                                }
                            }
                        }
                        
                        resultMessage += `</div></div>`;
                    }
                }
                
                // 关闭div
                resultMessage += `</div>`;
                
                // 在结果模态框中显示
                showModal('选择器测试结果', resultMessage);
            } catch (e) {
                console.error(`测试${type}选择器时出错:`, e);
                showToast('错误', `测试${type}选择器时出错: ${e.message}`, 'error');
            }
        }
        
        // 辅助函数：显示模态框
        function showModal(title, body) {
            // 检查测试结果模态框是否存在
            let testResultModal = document.getElementById('testResultModal');
            
            // 如果模态框不存在，创建一个
            if (!testResultModal) {
                testResultModal = document.createElement('div');
                testResultModal.id = 'testResultModal';
                testResultModal.className = 'modal fade';
                testResultModal.tabIndex = -1;
                testResultModal.setAttribute('aria-labelledby', 'testResultModalLabel');
                testResultModal.setAttribute('aria-hidden', 'true');
                
                testResultModal.innerHTML = `
                    <div class="modal-dialog modal-lg">
                        <div class="modal-content">
                            <div class="modal-header">
                                <h5 class="modal-title" id="testResultModalLabel">测试结果</h5>
                                <button type="button" class="btn-close" data-bs-dismiss="modal" aria-label="Close"></button>
                            </div>
                            <div class="modal-body" id="testResultModalBody">
                            </div>
                            <div class="modal-footer">
                                <button type="button" class="btn btn-secondary" data-bs-dismiss="modal">关闭</button>
                            </div>
                        </div>
                    </div>
                `;
                
                document.body.appendChild(testResultModal);
            }
            
            // 设置标题和内容
            const modalTitle = document.getElementById('testResultModalLabel');
            const modalBody = document.getElementById('testResultModalBody');
            
            if (modalTitle) modalTitle.textContent = title;
            if (modalBody) modalBody.innerHTML = body;
            
            // 显示模态框
            try {
                const modal = new bootstrap.Modal(testResultModal);
                modal.show();
            } catch (e) {
                console.error('显示模态框时出错:', e);
                // 备用方法：使用jQuery显示
                try {
                    $(testResultModal).modal('show');
                } catch (e2) {
                    console.error('尝试使用jQuery显示模态框时出错:', e2);
                    showToast('错误', '无法显示测试结果模态框', 'error');
                }
            }
        }

        // 添加一个通用的选择器验证函数
        function validateAndFixSelector(selector, context) {
            if (!selector) return '';
            
            try {
                // 测试选择器是否有效
                document.createElement('div').querySelector(selector);
                return selector; // 选择器有效，直接返回
            } catch (e) {
                console.error(`选择器语法错误 "${selector}": ${e.message}`);
                
                // 尝试修复常见的选择器错误
                let correctedSelector = selector;
                
                // 处理纯标签选择器
                if (/^[a-z0-9]+$/i.test(selector)) {
                    // 纯标签选择器有效，但可能太宽泛
                    if (selector === 'li') {
                        correctedSelector = 'ul > li, ol > li, dl > li, .list > li';
                    } else if (selector === 'a') {
                        correctedSelector = 'a[href]';
                    }
                }
                // 处理具有>但缺少空格的选择器
                else if (selector.includes('>') && !selector.includes(' > ')) {
                    correctedSelector = selector.replace(/>/g, ' > ');
                }
                
                // 再次测试修复后的选择器
                try {
                    document.createElement('div').querySelector(correctedSelector);
                    console.log(`选择器已修正: "${selector}" -> "${correctedSelector}"`);
                    return correctedSelector;
                } catch (fixError) {
                    // 如果修复后仍然无效，记录错误并返回一个安全的后备选择器
                    console.error(`无法修复选择器 "${selector}": ${fixError.message}`);
                    
                    // 返回一个空选择器或默认选择器
                    if (context === 'container') return 'div.container, main, article, section';
                    if (context === 'item') return 'ul > li, ol > li, dl > dt';
                    if (context === 'title') return 'h1, h2, h3, a[href]';
                    if (context === 'link') return 'a[href]';
                    if (context === 'date') return 'time, .date, .time';
                    
                    return 'div'; // 最后的后备选择器
                }
            }
        }
    </script>

    <!-- 添加页面函数 -->
    <script>
        /**
         * 设置选择器值
         * @param {string} selectorType - 选择器类型（item, title, link等）
         * @param {string} selectorValue - 选择器值
         */
        function setSelector(selectorType, selectorValue) {
            if (!selectorType || !selectorValue) return;
            
            // 查找对应的选择器输入框
            const inputId = `selector${selectorType.charAt(0).toUpperCase() + selectorType.slice(1)}`;
            const inputElement = document.getElementById(inputId);
            
            if (inputElement) {
                inputElement.value = selectorValue;
                inputElement.classList.add('is-valid');
                
                // 提示用户已设置选择器
            const toast = new bootstrap.Toast(document.getElementById('notificationToast'));
                document.getElementById('toastMessage').textContent = `已设置${selectorType}选择器: ${selectorValue}`;
            toast.show();
            
                // 关闭模态框
                if (bootstrap.Modal.getInstance(document.getElementById('resultModal'))) {
                    bootstrap.Modal.getInstance(document.getElementById('resultModal')).hide();
                }
            }
        }
    </script>
    
    <!-- 认证模态框 -->
    <div class="modal fade" id="authModal" tabindex="-1" aria-hidden="true">
        <div class="modal-dialog">
            <div class="modal-content">
                <div class="modal-header">
                    <h5 class="modal-title">认证</h5>
                    <button type="button" class="btn-close" data-bs-dismiss="modal" aria-label="Close"></button>
                </div>
                <div class="modal-body">
                    <div class="alert alert-info">
                        <p>您需要登录或提供API密钥才能执行此操作。</p>
                    </div>
                    
                    <ul class="nav nav-tabs" id="authTabs">
                        <li class="nav-item">
                            <a class="nav-link active" data-bs-toggle="tab" href="#loginTab">登录</a>
                        </li>
                        <li class="nav-item">
                            <a class="nav-link" data-bs-toggle="tab" href="#apiKeyTab">API密钥</a>
                        </li>
                    </ul>
                    
                    <div class="tab-content mt-3">
                        <div class="tab-pane fade show active" id="loginTab">
                            <form id="loginForm">
                                <div class="mb-3">
                                    <label for="username" class="form-label">用户名</label>
                                    <input type="text" class="form-control" id="username" required>
                                </div>
                                <div class="mb-3">
                                    <label for="password" class="form-label">密码</label>
                                    <input type="password" class="form-control" id="password" required>
                                </div>
                                <div class="d-grid">
                                    <button type="submit" class="btn btn-primary">登录</button>
                                </div>
                            </form>
                        </div>
                        <div class="tab-pane fade" id="apiKeyTab">
                            <form id="apiKeyForm">
                                <div class="mb-3">
                                    <label for="apiKey" class="form-label">API密钥</label>
                                    <input type="text" class="form-control" id="apiKey" required>
                                </div>
                                <div class="d-grid">
                                    <button type="submit" class="btn btn-primary">保存</button>
                                </div>
                            </form>
                        </div>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <!-- 添加通知Toast -->
    <div id="notificationToast" class="toast" role="alert" aria-live="assertive" aria-atomic="true">
        <div class="toast-header">
            <strong class="me-auto">通知</strong>
            <button type="button" class="btn-close" data-bs-dismiss="toast" aria-label="Close"></button>
        </div>
        <div class="toast-body" id="toastMessage">
            
        </div>
    </div>
    
    <!-- API健康检查模态框 -->
    <div class="modal fade" id="apiHealthModal" tabindex="-1" aria-hidden="true">
        <div class="modal-dialog modal-lg">
            <div class="modal-content">
                <div class="modal-header">
                    <h5 class="modal-title">API健康检查</h5>
                    <button type="button" class="btn-close" data-bs-dismiss="modal" aria-label="Close" onclick="clearModalBackdrops()"></button>
                </div>
                <div class="modal-body">
                    <div id="apiHealthStatus" class="mb-3"></div>
                    <div class="table-responsive">
                        <table class="table table-bordered">
                            <thead>
                                <tbody id="apiHealthTable">
                                    <tr>
                                        <th>端点名称</th>
                                        <th>URL</th>
                                        <th>状态</th>
                                        <th>响应时间</th>
                                        <th>操作</th>
                                    </tr>
                                </tbody>
                            </thead>
                        </table>
                    </div>
                    <div id="apiCheckDetails" class="mt-3"></div>
                </div>
                <div class="modal-footer">
                    <button type="button" class="btn btn-secondary" data-bs-dismiss="modal" onclick="clearModalBackdrops()">关闭</button>
                    <button type="button" class="btn btn-primary" onclick="checkApiHealth()">重新检查</button>
                </div>
            </div>
        </div>
    </div>

    <!-- 测试结果模态框 -->
    <div class="modal fade" id="testResultModal" tabindex="-1" aria-hidden="true">
        <div class="modal-dialog modal-lg">
            <div class="modal-content">
                <div class="modal-header">
                    <h5 class="modal-title">选择器测试结果</h5>
                    <button type="button" class="btn-close" data-bs-dismiss="modal" aria-label="Close"></button>
                </div>
                <div class="modal-body" id="testResultModalBody">
                    <!-- 测试结果将动态插入此处 -->
                </div>
                <div class="modal-footer">
                    <button type="button" class="btn btn-secondary" data-bs-dismiss="modal">关闭</button>
                </div>
            </div>
        </div>
    </div>
</body>
</html> 